<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Spring Cache (3) - Pointcut、Advice 和 Advisor]]></title>
      <url>https://HaleLu.github.io/2020/06/spring-cache-3/</url>
      <content type="html"><![CDATA[<h1 id="Spring-Cache-配置的-Pointcut、Advice-和-Advisor"><a href="#Spring-Cache-配置的-Pointcut、Advice-和-Advisor" class="headerlink" title="Spring Cache 配置的 Pointcut、Advice 和 Advisor"></a>Spring Cache 配置的 Pointcut、Advice 和 Advisor</h1><p>上篇讲到，Spring Cache 在 <code>AdviceMode.Proxy</code> 模式会注入 <code>AutoProxyRegistrar</code> 和 <code>ProxyCachingConfiguration</code> 这两个类，其中 <code>AutoProxyRegistrar</code> 是一个与 cache 功能无关的 AOP 类，已经在上一篇中介绍过。</p>
<p>这篇将详细深入 <code>ProxyCachingConfiguration</code> 的配置类。</p>
<a id="more"></a>

<h2 id="ProxyCachingConfiguration-解析"><a href="#ProxyCachingConfiguration-解析" class="headerlink" title="ProxyCachingConfiguration 解析"></a>ProxyCachingConfiguration 解析</h2><p>首先可以看到 <code>ProxyCachingConfiguration</code> 继承自 <code>AbstractCachingConfiguration</code>，所以我们先看 <code>AbstractCachingConfiguration</code> 的源码。</p>
<p><em>注：这个 <code>AbstractCachingConfiguration</code> 也是其他代理模式下配置的基类</em></p>
<h3 id="ProxyCachingConfiguration-的基类-——-AbstractCachingConfiguration"><a href="#ProxyCachingConfiguration-的基类-——-AbstractCachingConfiguration" class="headerlink" title="ProxyCachingConfiguration 的基类 —— AbstractCachingConfiguration"></a>ProxyCachingConfiguration 的基类 —— AbstractCachingConfiguration</h3><h4 id="AbstractCachingConfiguration-源码"><a href="#AbstractCachingConfiguration-源码" class="headerlink" title="AbstractCachingConfiguration 源码"></a>AbstractCachingConfiguration 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCachingConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AnnotationAttributes enableCaching;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> CacheResolver cacheResolver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> KeyGenerator keyGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> CacheErrorHandler errorHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enableCaching = AnnotationAttributes.fromMap(</span><br><span class="line">                importMetadata.getAnnotationAttributes(EnableCaching.class.getName(), <span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.enableCaching == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"@EnableCaching is not present on importing class "</span> + importMetadata.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(Collection&lt;CachingConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configurers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(configurers.size() + <span class="string">" implementations of "</span> +</span><br><span class="line">                    <span class="string">"CachingConfigurer were found when only 1 was expected. "</span> +</span><br><span class="line">                    <span class="string">"Refactor the configuration such that CachingConfigurer is "</span> +</span><br><span class="line">                    <span class="string">"implemented only once or not at all."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CachingConfigurer configurer = configurers.iterator().next();</span><br><span class="line">        useCachingConfigurer(configurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">useCachingConfigurer</span><span class="params">(CachingConfigurer config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheManager = config.cacheManager();</span><br><span class="line">        <span class="keyword">this</span>.cacheResolver = config.cacheResolver();</span><br><span class="line">        <span class="keyword">this</span>.keyGenerator = config.keyGenerator();</span><br><span class="line">        <span class="keyword">this</span>.errorHandler = config.errorHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到一个 <code>CachingConfigurer</code> 的接口，容器内应当注册了 0 个或 1 个 <code>CachingConfigurer</code>，当有 <code>CachingConfigurer</code> 的时候，会为 Cache 功能提供 <code>CacheManager</code>、<code>CacheResolver</code>、<code>KeyGenerator</code>、<code>CacheErrorHandler</code> 这四项配置。顺便从容器取到 <code>@EnableCaching</code> 注解的参数保存在 <code>enableCaching</code> 中。</p>
<h4 id="AbstractCachingConfiguration-总结"><a href="#AbstractCachingConfiguration-总结" class="headerlink" title="AbstractCachingConfiguration 总结"></a>AbstractCachingConfiguration 总结</h4><p>如果有配置 CachingConfigurer，则将其中的 <code>CacheManager</code>、<code>CacheResolver</code>、<code>KeyGenerator</code>、<code>CacheErrorHandler</code> 保存在类中。同时取到 <code>@EnableCaching</code> 注解的参数保存在类中。</p>
<h3 id="ProxyCachingConfiguration-定义"><a href="#ProxyCachingConfiguration-定义" class="headerlink" title="ProxyCachingConfiguration 定义"></a>ProxyCachingConfiguration 定义</h3><h4 id="ProxyCachingConfiguration-源码"><a href="#ProxyCachingConfiguration-源码" class="headerlink" title="ProxyCachingConfiguration 源码"></a>ProxyCachingConfiguration 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCachingConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)</span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">        advisor.setCacheOperationSource(cacheOperationSource());</span><br><span class="line">        advisor.setAdvice(cacheInterceptor());</span><br><span class="line">        advisor.setOrder(<span class="keyword">this</span>.enableCaching.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheOperationSource <span class="title">cacheOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationCacheOperationSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheInterceptor <span class="title">cacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheInterceptor interceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">        interceptor.setCacheOperationSources(cacheOperationSource());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cacheResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interceptor.setCacheResolver(<span class="keyword">this</span>.cacheResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.cacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interceptor.setCacheManager(<span class="keyword">this</span>.cacheManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keyGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interceptor.setKeyGenerator(<span class="keyword">this</span>.keyGenerator);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interceptor.setErrorHandler(<span class="keyword">this</span>.errorHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注：所有的 Configuration 和 Bean 都加上了 <code>@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</code> 以便于被 <code>AutoProxyRegistrar</code> 过滤注册。具体逻辑见上一篇。</em></p>
<p>配置类一共注入了三个类：<code>CacheOperationSource</code>、<code>CacheInterceptor</code>、<code>BeanFactoryCacheOperationSourceAdvisor</code>。额外做的操作就是将基类拿到的 <code>CacheManager</code>、<code>CacheResolver</code>、<code>KeyGenerator</code>、<code>CacheErrorHandler</code> 尽可能注入 <code>CacheInterceptor</code> 中，将 <code>EnableCaching</code> 注解中的 <code>order</code> 注入到 <code>BeanFactoryCacheOperationSourceAdvisor</code> 中，并将这三者接线。</p>
<p>我们就按 <code>CacheOperationSource</code>、<code>CacheInterceptor</code>、<code>BeanFactoryCacheOperationSourceAdvisor</code> 的顺序看这三个类。</p>
<h3 id="ProxyCachingConfiguration-注入的类"><a href="#ProxyCachingConfiguration-注入的类" class="headerlink" title="ProxyCachingConfiguration 注入的类"></a>ProxyCachingConfiguration 注入的类</h3><h4 id="从-CacheOperationSource-到-AnnotationCacheOperationSource"><a href="#从-CacheOperationSource-到-AnnotationCacheOperationSource" class="headerlink" title="从 CacheOperationSource 到 AnnotationCacheOperationSource"></a>从 CacheOperationSource 到 AnnotationCacheOperationSource</h4><p><code>CacheOperationSource</code> 只是一个接口，实际注册的是 <code>AnnotationCacheOperationSource</code>。</p>
<p><code>CacheOperationSource</code> 接口只包含一个 <code>Collection&lt;CacheOperation&gt; getCacheOperations(Method method, Class&lt;?&gt; targetClass)</code> 方法，targetClass 和 method 分别是调用者的类和调用的方法。接口方法应当将 method 上的 <code>Cacheable</code> 之类的注解，将其解析为 <code>CacheOperation</code> 集合并返回。关于 <code>CacheOperation</code> 的细节见<a href="#CacheOperation">下文，点击跳转</a>。</p>
<p><code>AbstractFallbackCacheOperationSource</code> 实现了 <code>CacheOperationSource</code>，并做了一级 CacheOperations 的缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Collection&lt;CacheOperation&gt;&gt; attributeCache =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Object, Collection&lt;CacheOperation&gt;&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>getCacheOperations 方法优先从 attributeCache 缓存拿 CacheOperation 集合，否则使用 computeCacheOperations 方法计算 CacheOperation 集合并放进缓存。</p>
<p>computeCacheOperations 源码如下，过程加了注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">computeCacheOperations</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果需要的话，不处理非 public 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法可能是在接口上，但是我们需要从目标类获取属性</span></span><br><span class="line">    <span class="comment">// 如果目标类为空，则方法不会改变</span></span><br><span class="line">    Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line">    <span class="comment">// 如果我们处理的是带泛型参数的方法，则需要找到原始方法（桥接方法）</span></span><br><span class="line">    specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先尝试从目标类中的方法上取 CacheOperation</span></span><br><span class="line">    Collection&lt;CacheOperation&gt; opDef = findCacheOperations(specificMethod);</span><br><span class="line">    <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> opDef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次尝试从目标类上取 CacheOperation</span></span><br><span class="line">    opDef = findCacheOperations(specificMethod.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> opDef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">        <span class="comment">// 降级则从原始方法上取 CacheOperation</span></span><br><span class="line">        opDef = findCacheOperations(method);</span><br><span class="line">        <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> opDef;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次降级则从原始方法的类上取 CacheOperation</span></span><br><span class="line">        opDef = findCacheOperations(method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> opDef;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于 findCacheOperations(Class&lt;?&gt; clazz) 和 findCacheOperations(Method method) 是由子类实现的抽象方法。</p>
<p>AnnotationCacheOperationSource 继承自 AbstractFallbackCacheOperationSource，根据不同的构造方式可以指定 publicMethodsOnly 和 annotationParsers，这里以默认构造函数为例。</p>
<p>默认构造函数只指定了 publicMethodsOnly 为 true，annotationParsers 只包含一个 SpringCacheAnnotationParser。</p>
<p>下一章我们再来详细看一看 SpringCacheAnnotationParser 这个类，现在我们先暂时知道 SpringCacheAnnotationParser 是一个取到 method 或 clazz 上注解并解析整理成 CacheOperation 集合的解析器类就可以了。</p>
<p>AnnotationCacheOperationSource 关键的功能代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> determineCacheOperations(<span class="keyword">new</span> CacheOperationProvider() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(CacheAnnotationParser parser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(<span class="keyword">final</span> Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> determineCacheOperations(<span class="keyword">new</span> CacheOperationProvider() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(CacheAnnotationParser parser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">determineCacheOperations</span><span class="params">(CacheOperationProvider provider)</span> </span>&#123;</span><br><span class="line">    Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (CacheAnnotationParser annotationParser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; annOps = provider.getCacheOperations(annotationParser);</span><br><span class="line">        <span class="keyword">if</span> (annOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ops == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ops = <span class="keyword">new</span> ArrayList&lt;CacheOperation&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            ops.addAll(annOps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 annotationParsers 只有一个 SpringCacheAnnotationParser，所以本质上就是执行了一行 <code>return springCacheAnnotationParser.parseCacheAnnotations(method);</code> 或 <code>return springCacheAnnotationParser.parseCacheAnnotations(clazz);</code>。</p>
<h5 id="AnnotationCacheOperationSource-小结"><a href="#AnnotationCacheOperationSource-小结" class="headerlink" title="AnnotationCacheOperationSource 小结"></a>AnnotationCacheOperationSource 小结</h5><p>我们可以看出，AnnotationCacheOperationSource 最终实现的就是取到方法或目标类上注解并将其解析为 CacheOperation 集合。</p>
<h5 id="CompositeCacheOperationSource"><a href="#CompositeCacheOperationSource" class="headerlink" title="CompositeCacheOperationSource"></a>CompositeCacheOperationSource</h5><p><code>CacheOperationSource</code> 还有一个实现 —— <code>CompositeCacheOperationSource</code> 表示 CacheOperationSource 的聚合，有一个私有的 CacheOperationSource 数组，其 getCacheOperations 方法会将这些 CacheOperationSource 的 getCacheOperations 的结果聚合到一个集合中返回。</p>
<h5 id="CacheOperation"><a href="#CacheOperation" class="headerlink" title="CacheOperation"></a>CacheOperation</h5><p>CacheOperation 有三个实现类：<code>CacheEvictOperation</code>、<code>CachePutOperation</code>、<code>CacheableOperation</code>，对应三种注解的操作。其本身具有以下的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; cacheNames;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String keyGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String cacheManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String cacheResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String condition;</span><br></pre></td></tr></table></figure>

<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p>CacheInterceptor 继承自 CacheAspectSupport，实现了 MethodInterceptor。</p>
<p>MethodInterceptor 的本质是一个增强 Advice。实现 MethodInterceptor 的目的是为了可以被 Advisor 调用。</p>
<p>关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line"></span><br><span class="line">        CacheOperationInvoker aopAllianceInvoker = <span class="keyword">new</span> CacheOperationInvoker() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ThrowableWrapper(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CacheOperationInvoker.ThrowableWrapper th) &#123;</span><br><span class="line">            <span class="keyword">throw</span> th.getOriginal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，其实就是调用了基类 <code>CacheAspectSupport</code> 的 <code>execute</code> 方法并拆包了一下基类抛出的异常。</p>
<p>因为此处过于复杂，我们放在下下一章详细讲 <code>CacheAspectSupport</code> 这个类。现在我们只需要知道，CacheInterceptor 提供了一个 Advice，在方法执行前后使用 cacheOperationSource 取到 CacheOperation 集合并执行对应的缓存操作。</p>
<h4 id="BeanFactoryCacheOperationSourceAdvisor"><a href="#BeanFactoryCacheOperationSourceAdvisor" class="headerlink" title="BeanFactoryCacheOperationSourceAdvisor"></a>BeanFactoryCacheOperationSourceAdvisor</h4><p>BeanFactoryCacheOperationSourceAdvisor 继承自 AbstractBeanFactoryPointcutAdvisor，其 pointcut 使用的是固定的 CacheOperationSourcePointcut。</p>
<h5 id="CacheOperationSourcePointcut"><a href="#CacheOperationSourcePointcut" class="headerlink" title="CacheOperationSourcePointcut"></a>CacheOperationSourcePointcut</h5><p>CacheOperationSourcePointcut 继承自 StaticMethodMatcherPointcut，被 set 了上文的 CacheOperationSource，其 match 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    CacheOperationSource cas = getCacheOperationSource();</span><br><span class="line">    <span class="keyword">return</span> (cas != <span class="keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(cas.getCacheOperations(method, targetClass)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，能取出 CacheOperation 的方法都会作为切入点。</p>
<h5 id="BeanFactoryCacheOperationSourceAdvisor-小结"><a href="#BeanFactoryCacheOperationSourceAdvisor-小结" class="headerlink" title="BeanFactoryCacheOperationSourceAdvisor 小结"></a>BeanFactoryCacheOperationSourceAdvisor 小结</h5><p>也就是说，<code>BeanFactoryCacheOperationSourceAdvisor</code> 会对所有能取出 <code>CacheOperation</code> 的方法执行 <code>CacheInterceptor</code> 这个 Advice。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cache (2) - 配置方式]]></title>
      <url>https://HaleLu.github.io/2020/06/spring-cache-2/</url>
      <content type="html"><![CDATA[<p>上一篇整体但粗略聊了聊 Spring Cache 的实现，这篇开始准备聊聊细节，就从 Spring Cache 的配置注入方式聊起吧。</p>
<blockquote>
<p>换句话说，虽然聊的是 Spring Cache 源码，但这块其实主要聊的是 Spring Framework 的 Configuration 配置和动态代理相关的内容。</p>
</blockquote>
<a id="more"></a>

<h1 id="Spring-Cache-的配置方式"><a href="#Spring-Cache-的配置方式" class="headerlink" title="Spring Cache 的配置方式"></a>Spring Cache 的配置方式</h1><h2 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a><code>@EnableCaching</code></h2><p>众所周知，Spring Cache 的启用方式是 <code>@EnableCaching</code> 注解，我们看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(CachingConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其 Import 了一个 <code>CachingConfigurationSelector</code>，同时定义了三个字段。其中 proxyTargetClass 和 mode 是用于动态代理的配置项，order 是用于启动顺序的配置项。</p>
<h2 id="CachingConfigurationSelector"><a href="#CachingConfigurationSelector" class="headerlink" title="CachingConfigurationSelector"></a><code>CachingConfigurationSelector</code></h2><p>CachingConfigurationSelector 实现于 <code>AdviceModeImportSelector&lt;EnableCaching&gt;</code>，根据注解中 mode 代表的 Advice 模式选择 import 不同的 bean。</p>
<p>已经了解 AdviceModeImportSelector 或不关心细节的读者可以跳过下面这个子模块。</p>
<h3 id="AdviceModeImportSelector-lt-T-gt"><a href="#AdviceModeImportSelector-lt-T-gt" class="headerlink" title="AdviceModeImportSelector&lt;T&gt;"></a><code>AdviceModeImportSelector&lt;T&gt;</code></h3><p>要聊 <code>AdviceModeImportSelector</code>，必须先聊聊他实现的接口 <code>ImportSelector</code>。</p>
<p>先看看其源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;String&gt; <span class="title">getExclusionFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>selectImports</code> 方法需要实现根据 <code>importingClassMetadata</code> 的元信息返回不同的类名数组。</p>
<p>不妨看看 <code>AdviceModeImportSelector</code> 是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">    Class&lt;?&gt; annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);</span><br><span class="line">    AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"@%s is not present on importing class '%s' as expected"</span>,</span><br><span class="line">                annType.getSimpleName(), importingClassMetadata.getClassName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AdviceMode adviceMode = attributes.getEnum(getAdviceModeAttributeName());</span><br><span class="line">    String[] imports = selectImports(adviceMode);</span><br><span class="line">    <span class="keyword">if</span> (imports == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown AdviceMode: "</span> + adviceMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一句句解析。</p>
<p>首先 <code>GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class)</code> 的作用是取到该类在 <code>AdviceModeImportSelector</code> 上的泛型类型，对于 CachingConfigurationSelector 而言，其继承的是 <code>AdviceModeImportSelector&lt;EnableCaching&gt;</code>，所以返回的 <code>annType</code> 就是 <code>EnableCaching.class</code>。</p>
<p>第二句 <code>AnnotationConfigUtils.attributesFor(importingClassMetadata, annType)</code>，<code>importingClassMetadata</code> 表示的是导入类的元信息（比如实际使用时我们可能将 <code>@EnableCaching</code> 注解在某个 Configuration 类或 Starter 类上，Spring Framework 中的 <code>ConfigurationClassParser</code> 会在处理这个 Configuration 类或 Starter 类的所有 <code>@Import</code> 注解时带入该配置类本身的元信息（可见于 <code>org.springframework.context.annotation.ConfigurationClassParser#processImports</code> 方法），并最终传递至 <code>selectImports</code> 方法的 <code>importingClassMetadata</code> 参数），该方法会返回配置类上 <code>@EnableCaching</code> 注解中的实际参数 Map（<code>AnnotationAttributes</code> 继承自 <code>LinkedHashMap&lt;String, Object&gt;</code>）。</p>
<p>后面是对结果判空，跳过。</p>
<p>第四句，<code>AdviceMode adviceMode = attributes.getEnum(getAdviceModeAttributeName())</code>，其中 <code>getAdviceModeAttributeName()</code> 返回一个常量字符串 <code>mode</code>，所以这句话会取到 <code>@EnableCaching</code> 注解中 mode 的值，保存在 <code>adviceMode</code> 中。</p>
<p>第五句，根据 <code>adviceMode</code> 选择不同的 bean 的类名数组，这个 <code>selectImports</code> 方法是 <code>AdviceModeImportSelector</code> 的抽象方法，交给子类实现。</p>
<p>第六和第七句，判空并返回。</p>
<h3 id="CachingConfigurationSelector-的-selectImports-实现"><a href="#CachingConfigurationSelector-的-selectImports-实现" class="headerlink" title="CachingConfigurationSelector 的 selectImports 实现"></a>CachingConfigurationSelector 的 selectImports 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> PROXY:</span><br><span class="line">            <span class="keyword">return</span> getProxyImports();</span><br><span class="line">        <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">            <span class="keyword">return</span> getAspectJImports();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法本身很简单，交给 <code>getProxyImports</code> 和 <code>getAspectJImports</code> 选择不同的动态代理模式的类名。</p>
<p>先看两个配置项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROXY_JCACHE_CONFIGURATION_CLASS =</span><br><span class="line">        <span class="string">"org.springframework.cache.jcache.config.ProxyJCacheConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsr107Present = ClassUtils.isPresent(</span><br><span class="line">        <span class="string">"javax.cache.Cache"</span>, CachingConfigurationSelector.class.getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jcacheImplPresent = ClassUtils.isPresent(</span><br><span class="line">        PROXY_JCACHE_CONFIGURATION_CLASS, CachingConfigurationSelector.class.getClassLoader());</span><br></pre></td></tr></table></figure>

<p>关于什么是 JSR 107 标准和 JCache 详细的此处不再赘述，更多资料可自行搜索。简单来说就是 JSR 107 规定了一套 JCache API 规范，如下图所示：</p>
<p><img src="./jsr107.png" alt></p>
<p>jsr107Present 和 jcacheImplPresent 都为 true 时表示需要启用 jcache 支持。</p>
<p>对于 Proxy 模式，注入的是 AutoProxyRegistrar 和 ProxyCachingConfiguration（如果启用 JCache 还注入 ProxyJCacheConfiguration）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROXY_JCACHE_CONFIGURATION_CLASS =</span><br><span class="line">        <span class="string">"org.springframework.cache.jcache.config.ProxyJCacheConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String[] getProxyImports() &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">    result.add(AutoProxyRegistrar.class.getName());</span><br><span class="line">    result.add(ProxyCachingConfiguration.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (jsr107Present &amp;&amp; jcacheImplPresent) &#123;</span><br><span class="line">        result.add(PROXY_JCACHE_CONFIGURATION_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 AspectJ 模式，注入的是 AspectJCachingConfiguration （如果启用 JCache 还注入 AspectJJCacheConfiguration）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">        <span class="string">"org.springframework.cache.aspectj.AspectJCachingConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JCACHE_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">        <span class="string">"org.springframework.cache.aspectj.AspectJJCacheConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String[] getAspectJImports() &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">    result.add(CACHE_ASPECT_CONFIGURATION_CLASS_NAME);</span><br><span class="line">    <span class="keyword">if</span> (jsr107Present &amp;&amp; jcacheImplPresent) &#123;</span><br><span class="line">        result.add(JCACHE_ASPECT_CONFIGURATION_CLASS_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常而言，我们使用的是默认的 Proxy 方式，且不会使用到 JCache。也就是说只注入了 AutoProxyRegistrar 和 ProxyCachingConfiguration。</p>
<p>再说一说这个 <code>AutoProxyRegistrar</code> 类，其实也是一个与 cache 功能无关的类，其功能源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</span><br><span class="line">    Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line">    <span class="keyword">for</span> (String annType : annTypes) &#123;</span><br><span class="line">        AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">        <span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object mode = candidate.get(<span class="string">"mode"</span>);</span><br><span class="line">        Object proxyTargetClass = candidate.get(<span class="string">"proxyTargetClass"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;</span><br><span class="line">                Boolean.class == proxyTargetClass.getClass()) &#123;</span><br><span class="line">            candidateFound = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</span><br><span class="line">                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">                <span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</span><br><span class="line">                    AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!candidateFound &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">        String name = getClass().getSimpleName();</span><br><span class="line">        logger.warn(String.format(<span class="string">"%s was imported but no annotations were found "</span> +</span><br><span class="line">                <span class="string">"having both 'mode' and 'proxyTargetClass' attributes of type "</span> +</span><br><span class="line">                <span class="string">"AdviceMode and boolean respectively. This means that auto proxy "</span> +</span><br><span class="line">                <span class="string">"creator registration and configuration may not have occurred as "</span> +</span><br><span class="line">                <span class="string">"intended, and components may not be proxied as expected. Check to "</span> +</span><br><span class="line">                <span class="string">"ensure that %s has been @Import'ed on the same class where these "</span> +</span><br><span class="line">                <span class="string">"annotations are declared; otherwise remove the import of %s "</span> +</span><br><span class="line">                <span class="string">"altogether."</span>, name, name, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档的注释直接翻译过来是这样：</p>
<blockquote>
<p>针对给定的注册表注册，升级和配置标准自动代理创建器（APC）。通过查找在 <code>@Configuration</code> 具有 mode 和 proxyTargetClass 属性的导入类上声明的最接近的注释来工作。如果 mode 设置为 PROXY，则注册 APC；如果 proxyTargetClass 设置为 true，则 APC 被强制使用子类（CGLIB）代理。</p>
<p>几个 <code>@Enable*</code> 注释同时公开 mode 和 proxyTargetClass 属性。重要的是要注意，大多数这些功能最终都共享一个 APC。因此，此实现并不“在乎”它找到的批注的确切含义——只要它公开了权限 mode 和 proxyTargetClass 属性，就可以对 APC 进行相同的注册和配置。</p>
</blockquote>
<p>看一下代码，头两行与 AdviceModeImportSelector 的 selectImports 实现类似，由 candidate 拿到注解里的参数。</p>
<p>接下来判断需要存在 mode 和 proxyTargetClass 参数且类型分别是 AdviceMode 和 Boolean，则置 candidateFound 标识位为 true，说明找到了对应的自动代理配置的注解。</p>
<p>如果 mode 是 PROXY 模式，则调用 <code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)</code> 方法，如果 proxyTargetClass （为 true 时强制全部使用 CGLIB，为 false 时对实现了接口的使用 JDK 动态代理，没有接口的使用 CGLIB），再调用 <code>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)</code> 方法。</p>
<p>这个 <code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)</code> 方法内部追踪下去就是调用了一句 <code>registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, null)</code>。内部功能代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTO_PROXY_CREATOR_BEAN_NAME =</span><br><span class="line">        <span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(source);</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这个 findPriorityForClass 就是取了 class 在数组里的下标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// Set up the escalation list...</span></span><br><span class="line">    APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">    APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">    APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>registerOrEscalateApcAsRequired</code> 方法会将 <code>cls</code> 注册为 <code>org.springframework.aop.config.internalAutoProxyCreator</code>，如果再次注册了 <code>AspectJAwareAdvisorAutoProxyCreator</code> 乃至 <code>AnnotationAwareAspectJAutoProxyCreator</code>，那么后者会顶替前者成为 internalAutoProxyCreator。同级别乃至更低级别则不会再顶替。</p>
<p><em>注：<code>AnnotationAwareAspectJAutoProxyCreator</code> 会在启用 <code>@EnableAspectJAutoProxy</code> 注解时注入。</em></p>
<p>而被注册的这个 <code>InfrastructureAdvisorAutoProxyCreator</code> 不再深挖，简单来说他会只注册所有定义上有 <code>role = BeanDefinition.ROLE_INFRASTRUCTURE</code> 的 advisor bean。</p>
<p>如果 <code>proxyTargetClass</code> 时执行的 <code>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry)</code> 定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToUseClassProxying</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"proxyTargetClass"</span>, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是在 bean 定义上添加了一条 <code>proxyTargetClass=true</code> 的属性。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cache 源码分析]]></title>
      <url>https://HaleLu.github.io/2020/06/spring-cache/</url>
      <content type="html"><![CDATA[<p>最近想写批量操作的缓存 AOP，于是研究了一下 Spring 原生的 Cache 源码，以便编些自己的 BatchCache AOP。</p>
<a id="more"></a>

<h1 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h1><h2 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h2><h3 id="基类：AbstractCachingConfiguration"><a href="#基类：AbstractCachingConfiguration" class="headerlink" title="基类：AbstractCachingConfiguration"></a>基类：AbstractCachingConfiguration</h3><p>包含几个关键配置对象可供配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AnnotationAttributes enableCaching;</span><br><span class="line"><span class="keyword">protected</span> CacheManager cacheManager;</span><br><span class="line"><span class="keyword">protected</span> CacheResolver cacheResolver;</span><br><span class="line"><span class="keyword">protected</span> KeyGenerator keyGenerator;</span><br><span class="line"><span class="keyword">protected</span> CacheErrorHandler errorHandler;</span><br></pre></td></tr></table></figure>

<h3 id="入口配置：ProxyCachingConfiguration"><a href="#入口配置：ProxyCachingConfiguration" class="headerlink" title="入口配置：ProxyCachingConfiguration"></a>入口配置：ProxyCachingConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">    advisor.setCacheOperationSource(cacheOperationSource());</span><br><span class="line">    advisor.setAdvice(cacheInterceptor());</span><br><span class="line">    advisor.setOrder(<span class="keyword">this</span>.enableCaching.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">    <span class="keyword">return</span> advisor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheOperationSource <span class="title">cacheOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationCacheOperationSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheInterceptor <span class="title">cacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheInterceptor interceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">    interceptor.setCacheOperationSources(cacheOperationSource());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cacheResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptor.setCacheResolver(<span class="keyword">this</span>.cacheResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.cacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptor.setCacheManager(<span class="keyword">this</span>.cacheManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.keyGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptor.setKeyGenerator(<span class="keyword">this</span>.keyGenerator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptor.setErrorHandler(<span class="keyword">this</span>.errorHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解解析器-Annotation-Parser"><a href="#注解解析器-Annotation-Parser" class="headerlink" title="注解解析器(Annotation Parser)"></a>注解解析器(Annotation Parser)</h2><h3 id="CacheAnnotationParser-接口"><a href="#CacheAnnotationParser-接口" class="headerlink" title="CacheAnnotationParser 接口"></a>CacheAnnotationParser 接口</h3><p>包含两个方法的声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheAnnotationParser</span> </span>&#123;</span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Class&lt;?&gt; type)</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够将 class 或 method 的 cache 注解解析为 <code>CacheOperation</code> 操作。</p>
<h3 id="SpringCacheAnnotationParser-类"><a href="#SpringCacheAnnotationParser-类" class="headerlink" title="SpringCacheAnnotationParser 类"></a>SpringCacheAnnotationParser 类</h3><p><code>SpringCacheAnnotationParser</code> 实现了 <code>CacheAnnotationParser</code>。同时还实现了 <code>Serializable</code>。</p>
<p>两个 <code>parseCacheAnnotations</code> 方法的内部实现，都是首先通过 <code>getDefaultCacheConfig(type)</code>（对于 <code>method</code>，参数取 <code>method.getDeclaringClass()</code>）取一个默认的 cache 配置，然后走同一套 <code>parseCacheAnnotations(defaultConfig, type)</code> 逻辑。</p>
<p>基本上调用方只有 <code>AnnotationCacheOperationSource</code>。</p>
<h4 id="parseCacheAnnotations"><a href="#parseCacheAnnotations" class="headerlink" title="parseCacheAnnotations"></a>parseCacheAnnotations</h4><p>通过 <code>getAllMergedAnnotations</code> 方法，将类型（<code>Class&lt;?&gt;</code> 或 <code>Method</code>）的 <code>Cacheable</code>、<code>CacheEvict</code>、<code>CachePut</code>、<code>Caching</code> 注解分别取出，分别通过 <code>parseCacheableAnnotation</code>、<code>parseEvictAnnotation</code>、<code>parsePutAnnotation</code>、<code>parseCachingAnnotation</code>方法解析为成 CacheOperation，最终合并为一个集合。</p>
<p>前三个 parseXXXAnnotation 的方法基本类似，取出注解中的参数（name、cacheName、key 等等，前三个注解略有不同），与 defaultConfig 合并，校验参数并返回。<code>parseCachingAnnotation</code> 是前三个注解的组合注解，所以将其内部的三种分别取出，再执行前三个 parseXXXAnnotation 方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheableOperation <span class="title">parseCacheableAnnotation</span><span class="params">(AnnotatedElement ae, DefaultCacheConfig defaultConfig, Cacheable cacheable)</span> </span>&#123;</span><br><span class="line">    CacheableOperation.Builder builder = <span class="keyword">new</span> CacheableOperation.Builder();</span><br><span class="line"></span><br><span class="line">    builder.setName(ae.toString());</span><br><span class="line">    builder.setCacheNames(cacheable.cacheNames());</span><br><span class="line">    builder.setCondition(cacheable.condition());</span><br><span class="line">    builder.setUnless(cacheable.unless());</span><br><span class="line">    builder.setKey(cacheable.key());</span><br><span class="line">    builder.setKeyGenerator(cacheable.keyGenerator());</span><br><span class="line">    builder.setCacheManager(cacheable.cacheManager());</span><br><span class="line">    builder.setCacheResolver(cacheable.cacheResolver());</span><br><span class="line">    builder.setSync(cacheable.sync());</span><br><span class="line"></span><br><span class="line">    defaultConfig.applyDefault(builder);</span><br><span class="line">    CacheableOperation op = builder.build();</span><br><span class="line">    validateCacheOperation(ae, op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CacheEvictOperation <span class="title">parseEvictAnnotation</span><span class="params">(AnnotatedElement ae, DefaultCacheConfig defaultConfig, CacheEvict cacheEvict)</span> </span>&#123;</span><br><span class="line">    CacheEvictOperation.Builder builder = <span class="keyword">new</span> CacheEvictOperation.Builder();</span><br><span class="line"></span><br><span class="line">    builder.setName(ae.toString());</span><br><span class="line">    builder.setCacheNames(cacheEvict.cacheNames());</span><br><span class="line">    builder.setCondition(cacheEvict.condition());</span><br><span class="line">    builder.setKey(cacheEvict.key());</span><br><span class="line">    builder.setKeyGenerator(cacheEvict.keyGenerator());</span><br><span class="line">    builder.setCacheManager(cacheEvict.cacheManager());</span><br><span class="line">    builder.setCacheResolver(cacheEvict.cacheResolver());</span><br><span class="line">    builder.setCacheWide(cacheEvict.allEntries());</span><br><span class="line">    builder.setBeforeInvocation(cacheEvict.beforeInvocation());</span><br><span class="line"></span><br><span class="line">    defaultConfig.applyDefault(builder);</span><br><span class="line">    CacheEvictOperation op = builder.build();</span><br><span class="line">    validateCacheOperation(ae, op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CacheOperation <span class="title">parsePutAnnotation</span><span class="params">(AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut)</span> </span>&#123;</span><br><span class="line">    CachePutOperation.Builder builder = <span class="keyword">new</span> CachePutOperation.Builder();</span><br><span class="line"></span><br><span class="line">    builder.setName(ae.toString());</span><br><span class="line">    builder.setCacheNames(cachePut.cacheNames());</span><br><span class="line">    builder.setCondition(cachePut.condition());</span><br><span class="line">    builder.setUnless(cachePut.unless());</span><br><span class="line">    builder.setKey(cachePut.key());</span><br><span class="line">    builder.setKeyGenerator(cachePut.keyGenerator());</span><br><span class="line">    builder.setCacheManager(cachePut.cacheManager());</span><br><span class="line">    builder.setCacheResolver(cachePut.cacheResolver());</span><br><span class="line"></span><br><span class="line">    defaultConfig.applyDefault(builder);</span><br><span class="line">    CachePutOperation op = builder.build();</span><br><span class="line">    validateCacheOperation(ae, op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCachingAnnotation</span><span class="params">(AnnotatedElement ae, DefaultCacheConfig defaultConfig, Caching caching)</span> </span>&#123;</span><br><span class="line">    Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Cacheable[] cacheables = caching.cacheable();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(cacheables)) &#123;</span><br><span class="line">        ops = lazyInit(ops);</span><br><span class="line">        <span class="keyword">for</span> (Cacheable cacheable : cacheables) &#123;</span><br><span class="line">            ops.add(parseCacheableAnnotation(ae, defaultConfig, cacheable));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CacheEvict[] cacheEvicts = caching.evict();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(cacheEvicts)) &#123;</span><br><span class="line">        ops = lazyInit(ops);</span><br><span class="line">        <span class="keyword">for</span> (CacheEvict cacheEvict : cacheEvicts) &#123;</span><br><span class="line">            ops.add(parseEvictAnnotation(ae, defaultConfig, cacheEvict));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CachePut[] cachePuts = caching.put();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(cachePuts)) &#123;</span><br><span class="line">        ops = lazyInit(ops);</span><br><span class="line">        <span class="keyword">for</span> (CachePut cachePut : cachePuts) &#123;</span><br><span class="line">            ops.add(parsePutAnnotation(ae, defaultConfig, cachePut));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最终校验 <code>CacheableOperation</code> 时，key 和 keyGenerator 至少需要有一个定义，cacheManager 和 cacheResolver 至少需要有一个定义。</p>
</blockquote>
<h2 id="缓存操作源"><a href="#缓存操作源" class="headerlink" title="缓存操作源"></a>缓存操作源</h2><h3 id="CacheOperationSource-接口"><a href="#CacheOperationSource-接口" class="headerlink" title="CacheOperationSource 接口"></a>CacheOperationSource 接口</h3><p>只定义了一个方法，用于获取 CacheOperation 集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractFallbackCacheOperationSource"><a href="#AbstractFallbackCacheOperationSource" class="headerlink" title="AbstractFallbackCacheOperationSource"></a>AbstractFallbackCacheOperationSource</h3><p>做了一层缓存。</p>
<p>由 <code>computeCacheOperations(Method method, Class&lt;?&gt; targetClass)</code> 计算 CacheOperation 集合。</p>
<p>取 class 的 CacheConfig 注解作为 <code>DefaultCacheConfig</code>，没有则全为 null。</p>
<blockquote>
<p>也就是说，Method 的 CacheConfig 定义需要在声明它的 class 上。</p>
</blockquote>
<h4 id="computeCacheOperations-方法"><a href="#computeCacheOperations-方法" class="headerlink" title="computeCacheOperations 方法"></a>computeCacheOperations 方法</h4><p>方法声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">computeCacheOperations</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span></span><br></pre></td></tr></table></figure>

<p>首先，如果需要的话，过滤只考虑 public 方法。（默认需要过滤）</p>
<p>其次，通过 <code>ClassUtils.getMostSpecificMethod</code> 和 <code>BridgeMethodResolver.findBridgedMethod</code> 找到最合适的 method 定义。</p>
<blockquote>
<p>桥接方法是为了兼容 Java 1.5 没有泛型语义时允许传递 Object 的问题而由编译器自动生成的方法。</p>
</blockquote>
<p>先使用 <code>findCacheOperations(Class&lt;?&gt; clazz)</code> 尝试从方法上解析 cache 操作，有则直接返回。没有则尝试使用 <code>findCacheOperations(Method method)</code> 从定义方法的类上解析，有则直接返回。</p>
<p>都取不到则尝试从原方法上用相同的流程解析。</p>
<p>都解析不到则返回 null。</p>
<h3 id="AnnotationCacheOperationSource-类"><a href="#AnnotationCacheOperationSource-类" class="headerlink" title="AnnotationCacheOperationSource 类"></a>AnnotationCacheOperationSource 类</h3><p><code>AnnotationCacheOperationSource</code> 继承了 <code>AbstractFallbackCacheOperationSource</code> 并实现了 <code>Serializable</code>。</p>
<p>AnnotationCacheOperationSource 会读取 Spring 的 <code>Cacheable</code>、 <code>CachePut</code> 和 <code>CacheEvict</code> 批注，并将相应的 cache operation 定义公开给 Spring 的缓存基础结构。此类也可以用作自定义 CacheOperationSource 的基类。</p>
<p>内部定义了一个 <code>Set&lt;CacheAnnotationParser&gt; annotationParsers</code> 保存用到的注解分析器。</p>
<p>提供了自定义是否只使用 public 方法和自定义缓存注解解析器（<code>CacheAnnotationParser</code>）的构造方法。默认只解析 public 方法，且解析器集合只有上文提到的 <code>SpringCacheAnnotationParser</code>。</p>
<p><code>determineCacheOperations(provider)</code> 确定给定 <code>CacheOperationProvider</code> 的 <code>CacheOperation</code>。该实现委托配置的 <code>CacheAnnotationParser</code>（默认为 SpringCacheAnnotationParser）来将已知的注解解析为 Spring 的元 attribute 类。可以重写以支持带有 caching metadata 的自定义注解。参数 <code>provider</code> 是要使用的 cache operation 提供者，类型为 <code>CacheOperationProvider</code>。</p>
<p>定义了基类使用的 <code>findCacheOperations</code> 方法，实现是遍历所有 <code>annotationParsers</code>，调用其 <code>parseCacheAnnotations</code>，然后将 cache 操作合并为一个 set。</p>
<h3 id="CacheOperationSource-用法小结"><a href="#CacheOperationSource-用法小结" class="headerlink" title="CacheOperationSource 用法小结"></a>CacheOperationSource 用法小结</h3><p>这个类，最终对外提供的是定义在 <code>AbstractFallbackCacheOperationSource</code> 下的 <code>getCacheOperations(Method method, Class&lt;?&gt; targetClass)</code> 方法。用于 <code>CacheAspectSupport</code> 和 <code>CacheOperationSourcePointcut</code>。</p>
<h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h2><h3 id="与-Cache-无关的-AOP-基类"><a href="#与-Cache-无关的-AOP-基类" class="headerlink" title="与 Cache 无关的 AOP 基类"></a>与 Cache 无关的 AOP 基类</h3><p>StaticMethodMatcherPointcut -&gt; Pointcut<br>StaticMethodMatcherPointcut -&gt; StaticMethodMatcher -&gt; MethodMatcher</p>
<h3 id="CacheOperationSourcePointcut"><a href="#CacheOperationSourcePointcut" class="headerlink" title="CacheOperationSourcePointcut"></a>CacheOperationSourcePointcut</h3><p>是一个抽象类，继承自 StaticMethodMatcherPointcut，实现了 Serializable。</p>
<p>有一个待实现的 <code>getCacheOperationSource</code> 方法，以返回缓存操作源。</p>
<p>实现了基类的 match 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    CacheOperationSource cas = getCacheOperationSource();</span><br><span class="line">    <span class="keyword">return</span> (cas != <span class="keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(cas.getCacheOperations(method, targetClass)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果 <code>cacheOperationSource</code> 非空且 <code>cacheOperationSource.getCacheOperations(method, targetClass)</code> 取到了一个或多个 cache 操作则可以匹配上。</p>
<h2 id="缓存操作的调用上下文-CacheOperationInvocationContext"><a href="#缓存操作的调用上下文-CacheOperationInvocationContext" class="headerlink" title="缓存操作的调用上下文 CacheOperationInvocationContext"></a>缓存操作的调用上下文 CacheOperationInvocationContext</h2><p>缓存操作的调用上下文类，提供四个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheOperationInvocationContext</span>&lt;<span class="title">O</span> <span class="keyword">extends</span> <span class="title">BasicOperation</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">O <span class="title">getOperation</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getTarget</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Method <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] getArgs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型的基类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasicOperation</span> </span>&#123;</span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getCacheNames</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存解析器-cache-resolver"><a href="#缓存解析器-cache-resolver" class="headerlink" title="缓存解析器(cache resolver)"></a>缓存解析器(cache resolver)</h2><h3 id="CacheResolver"><a href="#CacheResolver" class="headerlink" title="CacheResolver"></a>CacheResolver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheResolver</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractCacheResolver、SimpleCacheResolver-和-NamedCacheResolver"><a href="#AbstractCacheResolver、SimpleCacheResolver-和-NamedCacheResolver" class="headerlink" title="AbstractCacheResolver、SimpleCacheResolver 和 NamedCacheResolver"></a>AbstractCacheResolver、SimpleCacheResolver 和 NamedCacheResolver</h3><p>抽象类，实现了 CacheResolver 接口，框架提供了两个默认实现 SimpleCacheResolver 和 NamedCacheResolver。</p>
<p>区别在于 SimpleCacheResolver 取 Operation 上的 cacheNames，NamedCacheResolver 手动指定 cacheNames。</p>
<p>而后都遍历 cacheNames 执行 CacheManager.getCache(cacheName) 并整合至同一集合并返回。</p>
<h3 id="CacheResolver-用法小结"><a href="#CacheResolver-用法小结" class="headerlink" title="CacheResolver 用法小结"></a>CacheResolver 用法小结</h3><p>对外提供了 resolveCaches 方法，主要用在 <code>CacheAspectSupport</code>。</p>
<h2 id="Interceptor-拦截器"><a href="#Interceptor-拦截器" class="headerlink" title="Interceptor 拦截器"></a>Interceptor 拦截器</h2><h3 id="AbstractCacheInvoker"><a href="#AbstractCacheInvoker" class="headerlink" title="AbstractCacheInvoker"></a>AbstractCacheInvoker</h3><p>在基本的 <code>Cache</code> 类的 doGet、doPut、doEvict 方法外包了一层 try-catch 并定义了异常日志的打印方式。默认直接抛出异常。</p>
<h3 id="CacheAspectSupport"><a href="#CacheAspectSupport" class="headerlink" title="CacheAspectSupport"></a>CacheAspectSupport</h3><p>抽象类，CacheAspectSupport 继承自 AbstractCacheInvoker，还实现了 BeanFactoryAware, InitializingBean, SmartInitializingSingleton。</p>
<p>涉及到众多需要 set 的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;CacheOperationCacheKey, CacheOperationMetadata&gt; metadataCache =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;CacheOperationCacheKey, CacheOperationMetadata&gt;(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CacheOperationExpressionEvaluator evaluator = <span class="keyword">new</span> CacheOperationExpressionEvaluator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CacheOperationSource cacheOperationSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> KeyGenerator keyGenerator = <span class="keyword">new</span> SimpleKeyGenerator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CacheResolver cacheResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br></pre></td></tr></table></figure>

<p>定义了一些对 Optional 的解包逻辑。</p>
<p>关键是 execute 方法。真正在方法执行前后对缓存执行对应操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">execute</span><span class="params">(<span class="keyword">final</span> CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Special handling of synchronized invocation</span></span><br><span class="line">    <span class="keyword">if</span> (contexts.isSynchronized()) &#123;</span><br><span class="line">        CacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next();</span><br><span class="line">        <span class="keyword">if</span> (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123;</span><br><span class="line">            Object key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">            Cache cache = context.getCaches().iterator().next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> wrapCacheValue(method, cache.get(key, <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> unwrapReturnValue(invokeOperation(invoker));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Cache.ValueRetrievalException ex) &#123;</span><br><span class="line">                <span class="comment">// The invoker wraps any Throwable in a ThrowableWrapper instance so we</span></span><br><span class="line">                <span class="comment">// can just make sure that one bubbles up the stack.</span></span><br><span class="line">                <span class="keyword">throw</span> (CacheOperationInvoker.ThrowableWrapper) ex.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No caching required, only call the underlying method</span></span><br><span class="line">            <span class="keyword">return</span> invokeOperation(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any early evictions</span></span><br><span class="line">    processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">true</span>,</span><br><span class="line">            CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we have a cached item matching the conditions</span></span><br><span class="line">    Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect puts from any @Cacheable miss, if no cached item is found</span></span><br><span class="line">    List&lt;CachePutRequest&gt; cachePutRequests = <span class="keyword">new</span> LinkedList&lt;CachePutRequest&gt;();</span><br><span class="line">    <span class="keyword">if</span> (cacheHit == <span class="keyword">null</span>) &#123;</span><br><span class="line">        collectPutRequests(contexts.get(CacheableOperation.class),</span><br><span class="line">                CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object cacheValue;</span><br><span class="line">    Object returnValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheHit != <span class="keyword">null</span> &amp;&amp; cachePutRequests.isEmpty() &amp;&amp; !hasCachePut(contexts)) &#123;</span><br><span class="line">        <span class="comment">// If there are no put requests, just use the cache hit</span></span><br><span class="line">        cacheValue = cacheHit.get();</span><br><span class="line">        returnValue = wrapCacheValue(method, cacheValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invoke the method if we don't have a cache hit</span></span><br><span class="line">        returnValue = invokeOperation(invoker);</span><br><span class="line">        cacheValue = unwrapReturnValue(returnValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect any explicit @CachePuts</span></span><br><span class="line">    collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any collected put requests, either from @CachePut or a @Cacheable miss</span></span><br><span class="line">    <span class="keyword">for</span> (CachePutRequest cachePutRequest : cachePutRequests) &#123;</span><br><span class="line">        cachePutRequest.apply(cacheValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any late evictions</span></span><br><span class="line">    processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">false</span>, cacheValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>继承自 CacheAspectSupport，实现了 MethodInterceptor 和 Serializable</p>
<p>将 CacheAspectSupport 父类的 execute 方法包装为接口的 invoke 方法的实现。</p>
<!-- ## Cache 和 CacheManager

TODO -->

<h2 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h2><h3 id="与-Cache-无关的-AOP-advisor-基类"><a href="#与-Cache-无关的-AOP-advisor-基类" class="headerlink" title="与 Cache 无关的 AOP advisor 基类"></a>与 Cache 无关的 AOP advisor 基类</h3><p>AbstractBeanFactoryPointcutAdvisor -&gt; AbstractPointcutAdvisor -&gt; PointcutAdvisor -&gt; Advisor</p>
<h3 id="BeanFactoryCacheOperationSourceAdvisor"><a href="#BeanFactoryCacheOperationSourceAdvisor" class="headerlink" title="BeanFactoryCacheOperationSourceAdvisor"></a>BeanFactoryCacheOperationSourceAdvisor</h3><p>继承自 AbstractBeanFactoryPointcutAdvisor。</p>
<p>getPointcut 方法返回一个 CacheOperationSourcePointcut 的实现，getCacheOperationSource 返回用户自定义的 CacheOperationSource。</p>
<p>注册时代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">    advisor.setCacheOperationSource(cacheOperationSource());</span><br><span class="line">    advisor.setAdvice(cacheInterceptor());</span><br><span class="line">    advisor.setOrder(<span class="keyword">this</span>.enableCaching.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">    <span class="keyword">return</span> advisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式事务 - 两阶段提交和三阶段提交]]></title>
      <url>https://HaleLu.github.io/2020/06/tcc-1/</url>
      <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>想聊聊分布式事务。</p>
<p>看了网上的一些说法，仔细思考之后感觉都不大统一，有些就是不对。本文加入了一些自己的思考，讨论了一些实现中的细节，如果不对欢迎指正。</p>
<a id="more"></a>

<p>先说说两阶段和三阶段提交吧。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>我这里说的两阶段提交，区别于网络上某些文章里提到的显然不实用的两阶段实现，是考虑到超时、异常恢复的两阶段提交。</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>各系统的所有操作应当保证幂等。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>具体的流程图不再画（网上随便搜搜就有），简单描述一下就是两步：</p>
<ol>
<li><p>发起事务：事务的发起者提出一个请求（比如用户下单购买某个商品），要求其依赖服务（也就是事务的执行者）响应请求（比如通知优惠券业务锁定使用的优惠券、通知支付业务冻结付款金额、通知仓储服务冻结库存等等）<br>当所有依赖方都回复确认之后，事务的准备阶段完毕。</p>
</li>
<li><p>确认/取消事务：当请求得到<strong>所有</strong>依赖服务的成功确认后，事务的发起者通知所有执行者确认（confirm）事务；如果第一步中只要有一个执行者返回失败，则取消（cancel）事务。</p>
</li>
</ol>
<blockquote>
<p>对于第二步，有些文章中的简单的二阶段提交是不需要执行者回复的，个人认为这意味着发起者无法确认第二步事务（无论是 confirm 还是 cancel 操作）有没有成功执行，所以个人认为需要确认。下文按有确认进行讨论。</p>
<p>更进一步，对于执行者而言，因为第一步的锁定返回了成功，所以第二步的确认只能是成功，不允许失败。执行者应想办法重试并保证成功。如果失败则意味着出现了系统的数据不一致。</p>
</blockquote>
<h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3><p>以上的流程在是理想情况下。</p>
<p>当考虑到网络异常等情况，会存在三个问题：</p>
<ol>
<li><p>对执行者而言：如果没有收到第二步事务，该如何处理？此时的执行者会一直锁定资源等待第二步事务。</p>
</li>
<li><p>对发起者而言：如果第一步中没有收到回复，该如果处理？此时的发起者无法得知是否所有执行者都成功锁定了资源。</p>
</li>
<li><p>对发起者而言：如果第二步中没有收到回复，该如果处理？此时的发起者无法得知是否所有执行者都成功确认了事务。</p>
</li>
</ol>
<blockquote>
<p>执行者没有收到第一步事务，对执行者而言是无感知的。所以没有这个问题。</p>
</blockquote>
<p>依次回答这三个问题：</p>
<ol>
<li><p>执行者没有收到第二步事务，有三种处理方案：第一种是一直锁定资源等待，第二种是超时 confirm 事务，第三种是超时 cancel 事务。对于两阶段提交而言，其他执行者在第一步是有可能返回失败的，所以显然强行 confirm 会有风险，第三种更为合理。此处有“应当 confirm 但因为网络或其他问题而没有收到，最终执行了超时 cancel”的风险，会导致数据不一致。</p>
</li>
<li><p>发起者第一步中没有收到回复，也存在两种策略：要么超时重试（再次提出事务），要么超时后当做返回失败处理。这两种可以组合使用，即多次超时重试后仍无回复则当做返回失败处理。</p>
</li>
<li><p>发起者第二步中没有收到回复，和问题 2 的处理策略类似，多次超时重试后仍无返回说明出现了异常，但不同的是这个异常是一个无法回滚的异常，意味着系统中可能出现了数据不一致，可能需要其他（很可能是人工）方式修复数据。</p>
</li>
</ol>
<blockquote>
<p>对于问题 3 ，因为在问题 1 的回答中我们默认执行者超时会 cancel 事务，所以当发起者第二步提出的是 cancel 时不会有什么问题。换句话说，当发起者在第二步提出 confirm 而没有收到回复时可能会出现数据不一致。</p>
</blockquote>
<h3 id="异常重试"><a href="#异常重试" class="headerlink" title="异常重试"></a>异常重试</h3><p>当执行过程中发生异常（比如宕机），事务应当可以重试。</p>
<ol>
<li><p>对发起者而言：如果在第一步发生异常：部分执行者锁定了资源，而另一部分从未收到过事务请求。由于执行者会默认超时 cancel，所以发起者发起 cancel 后（或不处理，直接等待超时）重新发起新事务即可。</p>
</li>
<li><p>对发起者而言：如果在第二步发生异常：如果执行的是 cancel，则无需重试，当做成功即可（当然也可以重试）。如果执行的是 confirm，则可能发生部分机器成功 confirm，部分机器由于没有收到 confirm，默认超时 cancel 请求，从而数据不一致的风险。</p>
</li>
<li><p>对执行者而言：如果在第一步发生异常：尽量返回失败即可，超时发起者会重试/cancel 请求。不会有什么风险。</p>
</li>
<li><p>对执行者而言：如果在第二步发生异常：尽量重试并保证成功。如果执行的是 confirm，说明第一步的锁定返回了成功，所以第二步的确认只能是成功。如果是 cancel，则更应当自行重试保证资源释放。</p>
</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在思考前两章问题的过程中，我们意识到了这个流程所存在的问题：</p>
<ol>
<li><p>最严重的风险，如果发起者在第二步 confirm 的过程中出现了异常、或由于网络问题部分执行者没有收到 confirm，那么会出现数据不一致的问题。</p>
</li>
<li><p>第一步操作会锁定资源，然而有可能操作不成功，需要释放资源。这种反复的“锁定-释放”降低了并发。</p>
</li>
</ol>
<h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><h3 id="相对两阶段提交的改进"><a href="#相对两阶段提交的改进" class="headerlink" title="相对两阶段提交的改进"></a>相对两阶段提交的改进</h3><p>名词上的修改没太多意义（cancel -&gt; rollback，confirm -&gt; doCommit）</p>
<p>三阶段提交在两阶段提交上的改进就是在之前多了一步：</p>
<p>在锁定资源之前先进行查询，确认是否可提交。我们姑且将其称之为第 0 步。</p>
<p>好处是什么？</p>
<p>还是以之前“用户下单购买某个商品”为例。对于这个场景，第 0 步会检查向优惠券服务检查优惠券是否可用、向支付业务检查账户余额是否足够、向仓储服务检查库存是否足够等。</p>
<p>只有当第 0 步全部返回成功时，才会执行第一步的锁定资源。这时的第一步也几乎可以全部返回成功（只有并发情况下会失败）。</p>
<p>因此，对于执行者而言，如果一直没有收到第二步（实际上的第三步）的事务，超时可以默认执行 confirm 操作。大多数情况下都会成功避免数据不一致。（只有并发竞争情况下有可能失败）</p>
<p>简而言之，三阶段提交相比两阶段提交多了第 0 步检查是否可提交。执行者的默认超时行为从 cancel 改为 confirm。</p>
<h3 id="总结三阶段提交"><a href="#总结三阶段提交" class="headerlink" title="总结三阶段提交"></a>总结三阶段提交</h3><p>我们可以看到，三阶段提交的确成功提高了并发，降低了反复的“锁定-释放”的可能。</p>
<p>然而他并没有完全解决二阶段提交数据不一致的问题，只是极大概率避免了数据不一致的可能性。在极端情况下：由于高并发，多个请求同时通过了第 0 步检查，部分却在第 1 步锁定失败，本应 cancel 却因为网络或其他问题导致部分（或全部）执行者没有收到 cancel 命令默认 confirm 了事务，导致了数据不一致。</p>
<p>下一章聊聊 TCC。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring进阶 - 空指针安全、数据缓冲区和编解码器]]></title>
      <url>https://HaleLu.github.io/2020/06/spring-7/</url>
      <content type="html"><![CDATA[<p>书接<a href="https://halelu.github.io/2020/06/spring-6/">上文</a></p>
<p>接下来到 Spring framework core 的剩余部分 —— 空指针安全、数据缓冲区和编解码器</p>
<a id="more"></a>

<h1 id="空指针安全"><a href="#空指针安全" class="headerlink" title="空指针安全"></a>空指针安全</h1><p>尽管 Java 不允许您使用其类型系统来表示空指针安全性，但 Spring 框架现在在 <code>org.springframework.lang</code> 包中提供了以下注释，以使您声明 API 和字段的空性：</p>
<p><code>@Nullable</code>：表示特定参数，返回值或字段可以为 <code>null</code> 的注释。</p>
<p><code>@NonNull</code>：表示特定参数，返回值或字段不能为 <code>null</code> 的注释（<code>@NonNullApi</code> 和 <code>@NonNullFields</code> 的参数/返回值和字段不需要）。</p>
<p><code>@NonNullApi</code>：程序包级别的注释，它声明非 <code>null</code> 为参数和返回值的默认语义。</p>
<p><code>@NonNullFields</code>：程序包级别的注释，它声明非 null 为字段的默认语义。</p>
<p>Spring 框架本身利用了这些注释，但是它们也可以在任何基于 Spring 的 Java 项目中使用，以声明 null 安全的 API 和可选的 null 安全的字段。尚不支持泛型类型参数，varargs 和数组元素的可空性，但应在即将发布的版本中使用它们，有关最新信息，请参见 <a href="https://jira.spring.io/browse/SPR-15942" target="_blank" rel="noopener">SPR-15942</a>。可空性声明预计将在 Spring Framework 版本之间进行微调，包括次要版本。在方法主体内部使用的类型的可空性超出了此功能的范围。</p>
<blockquote>
<p>其他常见的库（如 Reactor 和 Spring Data）提供了使用类似可空性设置的空安全 API，从而为 Spring 应用程序开发人员提供了一致的总体体验。</p>
</blockquote>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>除了为 Spring Framework API 可空性提供显式声明外，IDE（例如 IDEA 或 Eclipse）还可以使用这些批注提供与空安全有关的有用警告，以避免在运行时出现 <code>NullPointerException</code>。</p>
<p>由于 Kotlin 原生支持 null 安全，因此它们还用于在 Kotlin 项目中使 Spring API 为 null 安全。 Kotlin 支持文档中提供了更多详细信息。</p>
<h2 id="JSR-305-元注释"><a href="#JSR-305-元注释" class="headerlink" title="JSR-305 元注释"></a>JSR-305 元注释</h2><p>Spring 注释使用 JSR 305 注释（静止但广泛使用的 JSR）进行元注释。 JSR-305 元注释使工具供应商（如 IDEA 或 Kotlin）以通用方式提供了空安全支持，而无需对 Spring 注释进行硬编码支持。</p>
<p>既不需要也不建议向项目类路径添加 JSR-305 依赖项以利用 Spring 空安全 API。只有诸如在其代码库中使用空安全注释的基于 Spring 的库之类的项目，才应添加 <code>com.google.code.findbugs:jsr305:3.0.2</code>（具有 <code>compileOnly</code> Gradle 配置或 Maven <code>provided</code> 的范围），以避免编译警告。</p>
<h1 id="数据缓冲区和编解码器"><a href="#数据缓冲区和编解码器" class="headerlink" title="数据缓冲区和编解码器"></a>数据缓冲区和编解码器</h1><p>Java NIO 提供了 <code>ByteBuffer</code>，但是许多库在上层构建了自己的字节缓冲区 API，特别是对于网络操作，其中重用缓冲区和/或使用直接缓冲区对性能有利。例如，Netty 具有 <code>ByteBuf</code> 层次结构，Undertow 使用 XNIO，Jetty 使用具有要释放的回调的池化字节缓冲区，等等。<code>spring-core</code> 模块提供了一组抽象，可以与各种字节缓冲区 API 配合使用，如下所示：</p>
<ul>
<li><code>DataBufferFactory</code> 抽象数据缓冲区的创建。</li>
<li><code>DataBuffer</code> 表示一个字节缓冲区，可以将其合并。</li>
<li><code>DataBufferUtils</code> 提供了用于数据缓冲区的实用程序方法。</li>
<li>编解码器将流数据缓冲区流解码或编码为更高级别的对象。</li>
</ul>
<h2 id="DataBufferFactory"><a href="#DataBufferFactory" class="headerlink" title="DataBufferFactory"></a><code>DataBufferFactory</code></h2><p><code>DataBufferFactory</code> 用于通过以下两种方式之一创建数据缓冲区：</p>
<ol>
<li>分配一个新的数据缓冲区，可以选择预先指定容量（如果已知），即使 <code>DataBuffer</code> 的实现可以按需增长和缩小，该容量也会更有效。</li>
<li>包装一个现有的 <code>byte[]</code> 或 <code>java.nio.ByteBuffer</code>，它们用 <code>DataBuffer</code> 实现装饰给定的数据，并且不涉及分配。</li>
</ol>
<p>请注意，WebFlux 应用程序不会直接创建 <code>DataBufferFactory</code>，而是通过客户端的 <code>ServerHttpResponse</code> 或 <code>ClientHttpRequest</code> 访问它。工厂的类型取决于基础客户端或服务器，例如 <code>NettyDataBufferFactory</code> 用于 Reactor Netty，<code>DefaultDataBufferFactory</code> 用于其他。</p>
<h2 id="DataBuffer"><a href="#DataBuffer" class="headerlink" title="DataBuffer"></a><code>DataBuffer</code></h2><p><code>DataBuffer</code> 接口提供与 <code>java.nio.ByteBuffer</code> 类似的操作，但还带来了一些其他好处，其中一些是受 Netty <code>ByteBuf</code> 启发的。以下是部分好处：</p>
<ul>
<li>具有独立位置的读取和写入，即不需要调用 <code>flip()</code> 在读取和写入之间交替。</li>
<li>与 <code>java.lang.StringBuilder</code> 一样，容量可以按需扩展。</li>
<li>通过 <code>PooledDataBuffer</code> 进行缓冲池和引用计数。</li>
<li>将缓冲区作为 <code>java.nio.ByteBuffer</code>，<code>InputStream</code> 或 <code>OutputStream</code> 查看。</li>
<li>确定给定字节的索引或最后一个索引。</li>
</ul>
<h2 id="PooledDataBuffer"><a href="#PooledDataBuffer" class="headerlink" title="PooledDataBuffer"></a><code>PooledDataBuffer</code></h2><p>如 Javadoc 中针对 <code>ByteBuffer</code> 所述，字节缓冲区可以是直接的也可以是非直接的。直接缓冲区可以驻留在 Java 堆之外，从而无需复制本机 I/O 操作。这使得直接缓冲区对于通过套接字接收和发送数据特别有用，但直接创建和释放它们的成本也更高，这导致了缓冲池的想法。</p>
<p><code>PooledDataBuffer</code> 是 <code>DataBuffer</code> 的扩展，可帮助进行引用计数，这对于字节缓冲区池至关重要。它是如何工作的？分配 <code>PooledDataBuffer</code> 时，引用计数为 1。调用 <code>keep()</code> 会增加计数，而调用 <code>release()</code> 会减少计数。只要计数大于 0，就保证不会释放缓冲区。当计数减少到 0 时，可以释放池中的缓冲区，这实际上意味着将为缓冲区保留的内存返回到内存池。</p>
<p>请注意，在大多数情况下，与其直接在 <code>PooledDataBuffer</code> 上进行操作，不如在 <code>DataBufferUtils</code> 中使用方便的方法，该方法仅在为 <code>PooledDataBuffer</code> 的实例时才将释放或保留应用于 <code>DataBuffer</code>。</p>
<p>8.4。 <code>DataBufferUtils</code><br><code>DataBufferUtils</code> 提供了许多实用程序方法来对数据缓冲区进行操作：</p>
<ul>
<li>将数据缓冲区流连接到单个缓冲区中，可能具有零个副本，例如通过复合缓冲区（如果基础字节缓冲区 API 支持的话）。</li>
<li>将 <code>InputStream</code> 或 NIO <code>channel</code> 转换为 <code>Flux&lt;DataBuffer&gt;</code>，反之亦然，将 <code>Publisher&lt;DataBuffer&gt;</code> 转换为 <code>OutputStream</code> 或 NIO <code>channel</code>。</li>
<li>如果缓冲区是 <code>PooledDataBuffer</code> 的实例，则释放或保留 <code>DataBuffer</code> 的方法。</li>
<li>从字节流中跳过或获取，直到特定的字节数为止。</li>
</ul>
<h2 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h2><p>org.springframework.core.codec 包提供以下策略接口：</p>
<ul>
<li>Encoder，用于将 <code>Publisher&lt;T&gt;</code> 编码为数据缓冲区流。</li>
<li>Decoder，用于将 <code>Publisher&lt;DataBuffer&gt;</code> 解码为更高级别的对象流。</li>
</ul>
<p><code>spring-core</code> 模块提供 <code>byte[]</code>，<code>ByteBuffer</code>，<code>DataBuffer</code>，<code>Resource</code> 和 <code>String</code> 编码器和解码器实现。<code>spring-web</code> 模块添加了 Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers 和其他编码器和解码器。请参阅 WebFlux 部分中的编解码器。</p>
<h2 id="使用-DataBuffer"><a href="#使用-DataBuffer" class="headerlink" title="使用 DataBuffer"></a>使用 <code>DataBuffer</code></h2><p>使用数据缓冲区时，必须特别小心以确保释放缓冲区，因为它们可能会被合并。我们将使用编解码器来说明其工作原理，但是这些概念会更普遍地应用。让我们看看编解码器在内部必须执行哪些操作来管理数据缓冲区。</p>
<p>在创建更高级别的对象之前，<code>Decoder</code> 是最后一个读取输入数据缓冲区的对象，因此，它必须按以下方式释放它们：</p>
<ol>
<li>如果 Decoder 只是读取每个输入缓冲区并准备立即释放它，则可以通过 DataBufferUtils.release（dataBuffer）这样做。</li>
<li>如果 Decoder 使用的是 Flux 或 Mono 运算符（例如 flatMap，reduce 和其他在内部预取和缓存数据项的运算符），或者正在使用诸如 filter，skip 的运算符以及其他遗漏项的运算符，则 doOnDiscard（PooledDataBuffer.class，DataBufferUtils 必须将::: release）添加到组合链中，以确保在丢弃此类缓冲区之前将其释放，这也可能是错误或取消信号的结果。</li>
<li>如果解码器以任何其他方式保留一个或多个数据缓冲区，则它必须确保在完全读取时释放它们，或者在读取和释放缓存的数据缓冲区之前发生错误或取消信号的情况下。</li>
</ol>
<p>请注意，<code>DataBufferUtils#join</code> 提供了一种安全有效的方法来将数据缓冲区流聚合到单个数据缓冲区中。同样，<code>skipUntilByteCount</code> 和 <code>takeUntilByteCount</code> 是供解码器使用的其他安全方法。</p>
<p><code>Encoder</code> 分配其他人必须读取（和释放）的数据缓冲区。因此，<code>Encoder</code> 无事可做。但是，如果在使用数据填充缓冲区时发生序列化错误，则 <code>Encoder</code> 必须小心释放数据缓冲区。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DataBuffer buffer = factory.allocateBuffer();</span><br><span class="line"><span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// serialize and populate buffer..</span></span><br><span class="line">    release = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (release) &#123;</span><br><span class="line">        DataBufferUtils.release(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br></pre></td></tr></table></figure>

<p><code>Encoder</code> 的使用者负责释放其接收的数据缓冲区。在 WebFlux 应用程序中，<code>Encoder</code> 的输出用于写入 HTTP 服务器响应或客户端 HTTP 请求，在这种情况下，释放数据缓冲区是写入服务器响应或客户端请求的代码的责任。</p>
<p>请注意，在 Netty 上运行时，有用于<a href="https://github.com/netty/netty/wiki/Reference-counted-objects#troubleshooting-buffer-leaks" target="_blank" rel="noopener">调试缓冲区泄漏</a>的调试选项。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring进阶 - Spring面向切面的编程（AOP）]]></title>
      <url>https://HaleLu.github.io/2020/06/spring-6/</url>
      <content type="html"><![CDATA[<p>书接<a href="https://halelu.github.io/2020/06/spring-5/">上文</a></p>
<p>接下来到 Spring framework core 的第五大块 —— AOP</p>
<a id="more"></a>

<h1 id="Spring-面向切面的编程"><a href="#Spring-面向切面的编程" class="headerlink" title="Spring 面向切面的编程"></a>Spring 面向切面的编程</h1><p>面向切面的编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象的编程（OOP）。OOP 中模块化的关键单元是类，而在 AOP 中模块化是切面。切面使关注点（例如事务管理）的模块化可以跨越多种类型和对象。（这种关注在 AOP 文献中通常被称为“跨领域”关注。）</p>
<p>Spring 的关键组件之一是 AOP 框架。 尽管 Spring IoC 容器不依赖于 AOP（这意味着您不需要的话就不需要使用 AOP），但 AOP 是对 Spring IoC 的补充，以提供功能非常强大的中间件解决方案。</p>
<blockquote>
<p>具有 AspectJ 切入点的 Spring AOP</p>
<p>Spring 提供了使用基于模式的方法或 <code>@AspectJ</code> 批注样式来编写自定义切面的简单而强大的方法。这两种样式都提供了完全类型化的 advice ，并使用了 AspectJ 切入点语言，同时仍使用 Spring AOP 进行编织。</p>
<p>本章讨论基于架构和基于 <code>@AspectJ</code> 的 AOP 支持。 下一章将讨论较低级别的 AOP 支持。</p>
</blockquote>
<p>AOP 在 Spring 框架中用于：</p>
<p>提供声明式企业服务。此类服务中最重要的是声明式事务管理。</p>
<p>让用户实现自定义切面，并用 AOP 补充其对 OOP 的使用。</p>
<blockquote>
<p>如果您只对通用声明性服务或其他预包装的声明性中间件服务（例如池）感兴趣，则无需直接使用 Spring AOP，并且可以跳过本章的大部分内容。</p>
</blockquote>
<h2 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP 概念"></a>AOP 概念</h2><p>让我们首先定义一些主要的 AOP 概念和术语。这些术语不是特定于 Spring 的。不幸的是，AOP 术语并不是特别直观。但是，如果使用 Spring 自己的术语，将会更加令人困惑。</p>
<ul>
<li>Aspect 切面：涉及多个类别的关注点的模块化。事务管理是企业 Java 应用程序中横切关注的一个很好的例子。在 Spring AOP 中，切面是通过使用常规类（基于模式的方法）或使用@Aspect 注释（@AspectJ 样式）注释的常规类来实现的。</li>
<li>join point 连接点：在程序执行过程中的一点，例如方法的执行或异常的处理。在 Spring AOP 中，连接点始终代表方法的执行。</li>
<li>Advice：切面在特定的连接点处采取的操作。不同类型的 advice 包括“周围”，“之前”和“之后” advice 。（advice 类型将在后面讨论。）包括 Spring 在内的许多 AOP 框架都将 advice 建模为拦截器，并在连接点周围维护一系列拦截器。</li>
<li>Pointcut 切入点：与连接点匹配的谓词。advice 与切入点表达式关联，并在与该切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。切入点表达式匹配的连接点的概念是 AOP 的核心，默认情况下，Spring 使用 AspectJ 切入点表达语言。</li>
<li>Introduction 简介：代表类型声明其他方法或字段。 Spring AOP 允许您向任何 advice 对象引入新的接口（和相应的实现）。例如，您可以使用简介使 Bean 实现 IsModified 接口，以简化缓存。 （在 AspectJ 社区中，介绍被称为类型间声明。）</li>
<li>Target object 目标对象：一个或多个切面 advice 的对象。也称为“ advice 对象”。由于 Spring AOP 是使用运行时代理实现的，因此该对象始终是代理对象。</li>
<li>AOP 代理：由 AOP 框架创建的一个对象，用于实现切面合同（ advice 方法执行等）。在 Spring Framework 中，AOP 代理是 JDK 动态代理或 CGLIB 代理。</li>
<li>Weaving 编织：将切面与其他应用程序类型或对象链接以创建 advice 的对象。这可以在编译时（例如，使用 AspectJ 编译器），加载时或在运行时完成。像其他纯 Java AOP 框架一样，Spring AOP 在运行时执行编织。</li>
</ul>
<p>Spring AOP 包括以下类型的 advice ：</p>
<ul>
<li>Before advice：在连接点之前运行的 advice ，但是它不能阻止执行流程继续进行到连接点（除非它引发异常）。</li>
<li>After returning advice：在连接点正常完成后要运行的 advice （例如，如果方法返回而没有引发异常）。</li>
<li>After throwing advice：如果方法因抛出异常而退出，则执行 advice 。</li>
<li>After (finally) advice：无论连接点退出的方式如何（正常或特殊返回），均应执行 advice 。</li>
<li>Around advice：around 连接点的 advice ，例如方法调用。这是最有力的 advice 。周围 advice 可以在方法调用之前和之后执行自定义行为。它还负责选择是返回连接点还是通过返回其自身的返回值或引发异常来捷径 advice 的方法执行。</li>
</ul>
<p>Around advice 是最通用的 advice 。由于 Spring AOP 与 AspectJ 一样，提供了各种 advice 类型，因此我们 advice 您使用功能最弱的 advice 类型，以实现所需的行为。例如，如果您只需要使用方法的返回值更新缓存，则最好使用 after returning advice 而不是 around advice ，尽管 around advice 可以完成相同的事情。使用最具体的 advice 类型可提供更简单的编程模型，并减少出错的可能性。例如，您不需要在用于 around advice 的 <code>JoinPoint</code> 上调用 <code>proceed()</code> 方法，因此，您不会失败。</p>
<p>所有 advice 参数都是静态类型的，因此您可以使用适当类型（例如，从方法执行返回的值的类型）而不是 <code>Object</code> 数组的 advice 参数。</p>
<p>切入点匹配的连接点的概念是 AOP 的关键，它与仅提供拦截功能的旧技术有所不同。切入点使 advice 的目标独立于面向对象的层次结构。例如，您可以将提供声明性事务管理的 around advice 应用于跨越多个对象（例如服务层中的所有业务操作）的一组方法。</p>
<h2 id="Spring-AOP-能力和目标"><a href="#Spring-AOP-能力和目标" class="headerlink" title="Spring AOP 能力和目标"></a>Spring AOP 能力和目标</h2><p>Spring AOP 是用纯 Java 实现的。不需要特殊的编译过程。 Spring AOP 不需要控制类加载器的层次结构，因此适合在 Servlet 容器或应用程序服务器中使用。</p>
<p>Spring AOP 当前仅支持方法执行连接点（ advice 在 Spring Bean 执行方法上）。尽管可以在不破坏核心 Spring AOP API 的情况下添加对字段拦截的支持，但并未实现字段拦截。如果需要 advice 字段访问和更新连接点，请考虑使用诸如 AspectJ 之类的语言。</p>
<p>Spring AOP 的 AOP 方法不同于大多数其他 AOP 框架。目的不是提供最完整的 AOP 实现（尽管 Spring AOP 相当强大）。相反，其目的是在 AOP 实现和 Spring IoC 之间提供紧密的集成，以帮助解决企业应用程序中的常见问题。</p>
<p>因此，例如，通常将 Spring Framework 的 AOP 功能与 Spring IoC 容器结合使用。通过使用常规 bean 定义语法来配置切面（尽管这允许强大的“自动代理”功能）。这是与其他 AOP 实现的关键区别。使用 Spring AOP 不能轻松或高效地完成某些事情，例如 advice 非常细粒度的对象（通常是域对象）。在这种情况下，AspectJ 是最佳选择。但是，我们的经验是，Spring AOP 为 AOP 可以解决的企业 Java 应用程序中的大多数问题提供了出色的解决方案。</p>
<p>Spring AOP 从未努力与 AspectJ 竞争以提供全面的 AOP 解决方案。我们认为，基于代理的框架（如 Spring AOP）和成熟的框架（如 AspectJ）都是有价值的，它们是互补的，而不是竞争。 Spring 无缝地将 Spring AOP 和 IoC 与 AspectJ 集成在一起，以在基于 Spring 的一致应用程序架构中支持 AOP 的所有使用。这种集成不会影响 Spring AOP API 或 AOP Alliance API。 Spring AOP 仍然向后兼容。请参阅下一章，以讨论 Spring AOP API。</p>
<blockquote>
<p>Spring 框架的中心宗旨之一是非侵入性。这是一个想法，您不应被迫将特定于框架的类和接口引入业务或域模型。但是，在某些地方，Spring Framework 确实为您提供了将特定于 Spring Framework 的依赖项引入代码库的选项。提供此类选项的理由是，在某些情况下，以这种方式阅读或编码某些特定功能可能会变得更加容易。但是，Spring 框架（几乎）总是为您提供选择：您可以自由地就哪个选项最适合您的特定用例或场景做出明智的决定。</p>
<p>与本章相关的一种选择是选择哪种 AOP 框架（以及哪种 AOP 样式）。您可以选择 AspectJ 和/或 Spring AOP。您也可以选择 @AspectJ 注释样式方法或 Spring XML 配置样式方法。本章选择首先介绍 @AspectJ 风格的方法这一事实不应被视为表明 Spring 团队比 Spring XML 配置风格更喜欢 @AspectJ 注释风格的方法。</p>
<p>有关每种样式的“whys and wherefores”的更完整讨论，请参见[选择要使用的 AOP 声明样式](<a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-choosing]。" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-choosing]。</a></p>
</blockquote>
<h2 id="AOP-代理"><a href="#AOP-代理" class="headerlink" title="AOP 代理"></a>AOP 代理</h2><p>Spring AOP 默认将标准 JDK 动态代理用于 AOP 代理。这使得可以代理任何接口（或一组接口）。</p>
<p>Spring AOP 也可以使用 CGLIB 代理。 这对于代理类而不是接口是必需的。默认情况下，如果业务对象未实现接口，则使用 CGLIB。由于对接口而不是对类进行编程是一种好习惯，因此业务类通常实现一个或多个业务接口。在那些需要 advice 在接口上未声明的方法或需要将代理对象作为具体类型传递给方法的情况下（在极少数情况下），可以强制使用 CGLIB。</p>
<p>掌握 Spring AOP 是基于代理的这一事实很重要。 请参阅了解 AOP 代理以全面了解此实现细节的实际含义。</p>
<h2 id="AspectJ-支持"><a href="#AspectJ-支持" class="headerlink" title="@AspectJ 支持"></a>@AspectJ 支持</h2><p>@AspectJ 是一种将切面声明为带有注释的常规 Java 类的样式。@AspectJ 样式是 <a href="https://www.eclipse.org/aspectj" target="_blank" rel="noopener">AspectJ 项目</a>在 AspectJ 5 版本中引入的。 Spring 使用 AspectJ 提供的用于切入点解析和匹配的库来解释与 AspectJ 5 相同的注释。 但是，AOP 运行时仍然是纯 Spring AOP，并且不依赖于 AspectJ 编译器或编织器。</p>
<blockquote>
<p>使用 AspectJ 编译器和 weaver 可以使用完整的 AspectJ 语言，有关内容在 <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-using-aspectj" target="_blank" rel="noopener">在 Spring Applications 中使用 AspectJ</a> 进行了讨论。</p>
</blockquote>
<h3 id="启用-AspectJ-支持"><a href="#启用-AspectJ-支持" class="headerlink" title="启用 @AspectJ 支持"></a>启用 @AspectJ 支持</h3><p>要在 Spring 配置中使用 @AspectJ 切面，您需要启用 Spring 支持以基于 <code>@AspectJ</code> 切面配置 Spring AOP，并基于这些切面是否 advice 对 Bean 进行自动代理。 通过自动代理，我们的意思是，如果 Spring 确定一个或多个切面 advice 一个 bean，它会自动为该 bean 生成一个代理来拦截方法调用并确保按需执行 advice 。</p>
<p>可以使用 XML 或 Java 样式的配置来启用 @AspectJ 支持。 无论哪种情况，您都需要确保 AspectJ 的 <code>Aspectjweaver.jar</code> 库位于应用程序的类路径（版本 1.8 或更高版本）上。 该库在 AspectJ 发行版的 lib 目录中或从 Maven Central 存储库中可用。</p>
<h4 id="通过-Java-配置启用-AspectJ-支持"><a href="#通过-Java-配置启用-AspectJ-支持" class="headerlink" title="通过 Java 配置启用 @AspectJ 支持"></a>通过 Java 配置启用 @AspectJ 支持</h4><p>要通过 Java <code>@Configuration</code> 启用 <code>@AspectJ</code> 支持，请添加 <code>@EnableAspectJAutoProxy</code> 批注，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-XML-配置启用-AspectJ-支持"><a href="#通过-XML-配置启用-AspectJ-支持" class="headerlink" title="通过 XML 配置启用 @AspectJ 支持"></a>通过 XML 配置启用 @AspectJ 支持</h4><p>要通过基于 XML 的配置启用 @AspectJ 支持，请使用 <code>aop:aspectj-autoproxy</code> 元素，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>假定您使用基于 XML Schema 的配置中所述的架构支持。 有关如何在 aop 名称空间中导入标签的信息，请参见 AOP 模式。</p>
<h4 id="声明一个切面"><a href="#声明一个切面" class="headerlink" title="声明一个切面"></a>声明一个切面</h4><p>启用 @AspectJ 支持后，Spring 会自动检测在应用程序上下文中使用 @AspectJ 切面（具有 @Aspect 批注）的类定义的任何 bean，并用于配置 Spring AOP。 接下来的两个示例显示了一个不太有用的切面所需的最小定义。</p>
<p>两个示例中的第一个示例显示了应用程序上下文中的常规 bean 定义，该定义指向具有 @Aspect 批注的 bean 类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"org.xyz.NotVeryUsefulAspect"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configure properties of the aspect here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个示例中的第二个示例显示了 <code>NotVeryUsefulAspect</code> 类定义，该类定义使用 <code>org.aspectj.lang.annotation.Aspect</code> 注释进行注释；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切面（使用 @Aspect 注释的类）可以具有方法和字段，与任何其他类相同。它们还可以包含切入点， advice 和介绍（类型间）声明。</p>
<blockquote>
<p>通过组件扫描自动检测切面</p>
<p>您可以将切面类注册为 Spring XML 配置中的常规 bean，也可以通过类路径扫描自动检测它们——与其他任何 Spring 管理的 bean 一样。 但是，请注意，@Aspect 注释不足以在类路径中进行自动检测。为此，您需要添加一个单独的 @Component 批注（或者，或者，按照 Spring 的组件扫描程序的规则，有条件的自定义构造型批注）。</p>
</blockquote>
<blockquote>
<p>向其他切面提供 advice ？</p>
<p>在 Spring AOP 中，切面本身不能成为其他切面的 advice 目标。 类上的 @Aspect 注释将其标记为一个切面，因此将其从自动代理中排除。</p>
</blockquote>
<h3 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h3><p>切入点确定了感兴趣的连接点，从而使我们能够控制何时执行 advice 。 Spring AOP 仅支持 Spring Bean 的方法执行连接点，因此您可以将切入点视为与 Spring Bean 上的方法执行匹配。 切入点声明由两部分组成：一个包含名称和任何参数的签名，以及一个切入点表达式，该切入点表达式精确确定我们感兴趣的方法执行。在 AOP 的@AspectJ 批注样式中，常规方法定义提供了切入点签名。 ，并使用 <code>@Pointcut</code> 批注指示切入点表达式（用作切入点签名的方法必须具有 <code>void</code> 返回类型）。</p>
<p>一个示例可能有助于使切入点签名和切入点表达式之间的区别变得清晰。 下面的示例定义一个名为 <code>anyOldTransfer</code> 的切入点，该切入点与任何名为 <code>transfer</code> 的方法的执行相匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* transfer(..))"</span>) <span class="comment">// the pointcut expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// the pointcut signature</span></span><br></pre></td></tr></table></figure>

<p>形成 <code>@Pointcut</code> 批注的值的切入点表达式是一个常规的 AspectJ 5 切入点表达式。 有关 AspectJ 的切入点语言的完整讨论，请参见 <a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">AspectJ 编程指南</a>（以及扩展，请参见 <a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html" target="_blank" rel="noopener">AspectJ 5 开发者手册</a>）或有关 AspectJ 的书籍之一（例如 Colyer 等人的 Eclipse AspectJ，或《AspectJ in Action》 ，由 Ramnivas Laddad 撰写）。</p>
<h4 id="支持的切入点指示符"><a href="#支持的切入点指示符" class="headerlink" title="支持的切入点指示符"></a>支持的切入点指示符</h4><p>Spring AOP 支持以下在切入点表达式中使用的 AspectJ 切入点指示符（PCD）：</p>
<ul>
<li><code>execution</code>：用于匹配方法执行的连接点。这是使用 Spring AOP 时要使用的主要切入点指示符。</li>
<li><code>within</code>：将匹配限制为某些类型内的连接点（使用 Spring AOP 时，在匹配类型内声明的方法的执行）。</li>
<li><code>this</code>：限制匹配到连接点（使用 Spring AOP 时方法的执行），其中 bean 引用（Spring AOP 代理）是给定类型的实例。</li>
<li><code>target</code>：限制匹配到连接点（使用 Spring AOP 时方法的执行），其中目标对象（代理的应用程序对象）是给定类型的实例。</li>
<li><code>args</code>：将匹配限制为连接点（使用 Spring AOP 时方法的执行），其中参数是给定类型的实例。</li>
<li><code>@target</code>：限制匹配到连接点（使用 Spring AOP 时方法的执行）的匹配，其中执行对象的类具有给定类型的注释。</li>
<li><code>@args</code>：限制匹配的连接点（使用 Spring AOP 时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。</li>
<li><code>@within</code>：限制匹配到具有给定注释的类型内的连接点（使用 Spring AOP 时，使用给定注释的类型中声明的方法的执行）。</li>
<li><code>@annotation</code>：将匹配限制为连接点的主题（在 Spring AOP 中正在执行的方法）具有给定注释的连接点。</li>
</ul>
<blockquote>
<p>其他切入点类型</p>
<p>完整的 AspectJ 切入点语言支持 Spring 不支持的其他切入点指示符：<code>call</code>, <code>get</code>, <code>set</code>, <code>preinitialization</code>, <code>staticinitialization</code>, <code>initialization</code>, <code>handler</code>, <code>adviceexecution</code>, <code>withincode</code>, <code>cflow</code>, <code>cflowbelow</code>, <code>if</code>, <code>@this</code>, 和 <code>@withincode</code>。在 Spring AOP 解释的切入点表达式中使用这些切入点指示符会导致抛出 <code>IllegalArgumentException</code>。</p>
<p>Spring AOP 支持的切入点指示符集合可能会在将来的版本中扩展，以支持更多的 AspectJ 切入点指示符。</p>
</blockquote>
<p>由于 Spring AOP 仅将匹配限制为仅方法执行连接点，因此前面对切入点指示符的讨论所给出的定义比在 AspectJ 编程指南中所能找到的要窄。此外，AspectJ 本身具有基于类型的语义，并且在执行连接点处，此对象和目标都引用同一个对象：执行该方法的对象。 Spring AOP 是基于代理的系统，可区分代理对象本身（绑定到此对象）和代理后面的目标对象（绑定到目标）。</p>
<blockquote>
<p>由于 Spring 的 AOP 框架基于代理的性质，因此根据定义，不会拦截目标对象内的调用。对于 JDK 代理，只能拦截代理上的公共接口方法调用。使用 CGLIB，将拦截代理上的公共方法和受保护的方法调用（必要时甚至包可见的方法）。但是，通常应通过公共签名设计通过代理进行的常见交互。</p>
<p>请注意，切入点定义通常与任何拦截方法匹配。如果严格地将切入点设置为仅公开使用，即使在 CGLIB 代理方案中通过代理可能存在非公开交互，也需要相应地进行定义。</p>
<p>如果您的拦截需要在目标类中包括方法调用甚至构造函数，请考虑使用 Spring 驱动的本机 AspectJ 编织，而不是 Spring 的基于代理的 AOP 框架。这构成了具有不同特征的 AOP 使用模式，因此请确保在做出决定之前先熟悉编织。</p>
</blockquote>
<p>Spring AOP 还支持其他名为 <code>bean</code> 的 PCD。使用 PCD，可以将连接点的匹配限制为特定的命名 Spring Bean 或一组命名 Spring Bean（使用通配符时）。<code>bean</code> PCD 具有以下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean(idOrNameOfBean)</span><br></pre></td></tr></table></figure>

<p><code>idOrNameOfBean</code> 令牌可以是任何 Spring bean 的名称。提供了使用 <code>*</code> 字符的有限通配符支持，因此，如果为 Spring bean 建立了一些命名约定，则可以编写 bean PCD 表达式来选择它们。与其他切入点指示符一样，bean PCD 可以和与或非运算符一起使用。</p>
<blockquote>
<p><code>bean</code> PCD 仅在 Spring AOP 中受支持，而在本机 AspectJ 编织中不受支持。它是 AspectJ 定义的标准 PCD 的特定于 Spring 的扩展，因此不适用于 <code>@Aspect</code> 模型中声明的切面。</p>
<p><code>bean</code> PCD 在实例级别（基于 Spring bean 名称概念构建）上运行，而不是仅在类型级别（基于编织的 AOP 受其限制）上运行。基于实例的切入点指示符是 Spring 基于代理的 AOP 框架及其与 Spring bean 工厂的紧密集成的一种特殊功能，可以自然而直接地识别特定对象。</p>
</blockquote>
<h3 id="组合切入点表达式"><a href="#组合切入点表达式" class="headerlink" title="组合切入点表达式"></a>组合切入点表达式</h3><p>您可以使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>组合切入点表达式，您也可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * *(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.xyz.someapp.trading..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"anyPublicOperation() &amp;&amp; inTrading()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果方法执行连接点表示任何公共方法的执行，则 anyPublicOperation 匹配。</p>
<p>如果交易模块中有方法执行，则 inTrading 匹配。</p>
<p>如果方法执行代表交易模块中的任何公共方法，则 tradingOperation 匹配。</p>
<p>最佳实践是从较小的命名组件中构建更复杂的切入点表达式，如先前所示。按名称引用切入点时，将应用常规的 Java 可见性规则（您可以看到相同类型的私有切入点，层次结构中受保护的切入点，任何位置的公共切入点，等等）。可见性不影响切入点匹配。</p>
<h4 id="共享通用切入点定义"><a href="#共享通用切入点定义" class="headerlink" title="共享通用切入点定义"></a>共享通用切入点定义</h4><p>在使用企业应用程序时，开发人员通常希望从多个切面引用应用程序的模块和特定的操作集。我们推荐为此定义一个 “SystemArchitecture” 切面，以捕获常见的切入点表达式。这样的切面通常类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.someapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the web layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.web package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.xyz.someapp.web..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inWebLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the service layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.service package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.xyz.someapp.service..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inServiceLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the data access layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.dao package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.xyz.someapp.dao..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDataAccessLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A business service is the execution of any method defined on a service</span></span><br><span class="line"><span class="comment">     * interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * "service" package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you group service interfaces by functional area (for example,</span></span><br><span class="line"><span class="comment">     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then</span></span><br><span class="line"><span class="comment">     * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"</span></span><br><span class="line"><span class="comment">     * could be used instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Alternatively, you can write the expression using the 'bean'</span></span><br><span class="line"><span class="comment">     * PCD, like so "bean(*Service)". (This assumes that you have</span></span><br><span class="line"><span class="comment">     * named your Spring service beans in a consistent fashion.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xyz.someapp..service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A data access operation is the execution of any method defined on a</span></span><br><span class="line"><span class="comment">     * dao interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * "dao" package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xyz.someapp.dao.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在需要切入点表达式的任何地方引用在此切面定义的切入点。 例如，要使服务层具有事务性，您可以编写以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span>=<span class="string">"com.xyz.someapp.SystemArchitecture.businessService()"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">advice-ref</span>=<span class="string">"tx-advice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"tx-advice"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-schema" target="_blank" rel="noopener">基于模式的 AOP 支持</a>中讨论了 <code>&lt;aop:config&gt;</code> 和 <code>&lt;aop:advisor&gt;</code> 元素。<a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/data-access.html#transaction" target="_blank" rel="noopener">事务管理</a>中讨论了事务元素。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Spring AOP 用户可能最常使用执行切入点指示符。执行表达式的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</span><br></pre></td></tr></table></figure>

<p>除了返回类型模式（前面的代码片段中的 <code>ret-type-pattern</code>），名称模式和参数模式以外的所有部分都是可选的。返回类型模式确定该方法的返回类型必须是什么才能使连接点匹配。 <code>*</code> 最常用作返回类型模式。它匹配任何返回类型。仅当方法返回给定类型时，标准类型名称才匹配。名称模式与方法名称匹配。您可以将 <code>*</code> 通配符用作名称模式的全部或一部分。如果指定了声明类型模式，请在其后加上 <code>.</code> 将其连接到名称模式组件。参数模式稍微复杂一些：<code>()</code> 匹配不带参数的方法，而 <code>(..)</code> 匹配任意数量（零个或多个）的参数。 <code>(*)</code> 模式与采用任何类型的一个参数的方法匹配。<code>(*，String)</code>与采用两个参数的方法匹配。第一个可以是任何类型，而第二个必须是 <code>String</code>。有关更多信息，请查阅 AspectJ 编程指南的<a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html" target="_blank" rel="noopener">语言语义</a>部分。</p>
<p>以下示例显示了一些常用的切入点表达式：</p>
<ul>
<li>任何公共方法的执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(public * *(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>名称以 set 开头的任何方法的执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* set*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>AccountService 接口定义的任何方法的执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service.AccountService.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包中定义的任何方法的执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service.*.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包或其子包之一中定义的任何方法的执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service..*.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包中的任何连接点（仅在 Spring AOP 中执行方法）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(com.xyz.service.*)</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包或其子包之一中的任何连接点（仅在 Spring AOP 中执行方法）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(com.xyz.service..*)</span><br></pre></td></tr></table></figure>

<ul>
<li>代理实现 <code>AccountService</code> 接口的任何连接点（仅在 Spring AOP 中执行方法）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>this</code> 通常以绑定形式使用。 有关如何在 advice 正文中使代理对象可用的信息，请参阅<a href="#声明-advice">声明 advice</a>部分。</p>
</blockquote>
<ul>
<li>目标对象实现 AccountService 接口的任何连接点（仅在 Spring AOP 中执行方法）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>target</code> 通常以绑定形式使用。有关如何使目标对象在 advice 正文中可用的信息，请参见<a href="#声明-advice">声明 advice</a>部分。</p>
</blockquote>
<ul>
<li>任何采用单个参数并且在运行时传递的参数为 <code>Serializable</code> 的连接点（仅在 Spring AOP 中执行方法）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args(java.io.Serializable)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>args</code> 通常以绑定形式使用。 有关如何使方法参数在 advice 正文中可用的信息，请参见<a href="#声明-advice">声明 advice</a>部分。</p>
</blockquote>
<p>请注意，此示例中给出的切入点与 <code>execution(* *(java.io.Serializable))</code> 不同。如果在运行时传递的参数为 <code>Serializable</code>，则 <code>args</code> 版本匹配；如果方法签名声明单个类型为 <code>Serializable</code> 的参数，则 <code>execution</code> 版本匹配。</p>
<ul>
<li>目标对象具有 <code>@Transactional</code> 批注的任何连接点（仅在 Spring AOP 中是方法执行）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@target(org.springframework.transaction.annotation.Transactional)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您也可以在绑定形式中使用 <code>@target</code>。有关如何使注释对象在 advice 正文中可用的信息，请参见<a href="#声明-advice">声明 advice</a>部分。</p>
</blockquote>
<ul>
<li>目标对象的声明类型具有 <code>@Transactional</code> 批注的任何连接点（仅在 Spring AOP 中是方法执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@within(org.springframework.transaction.annotation.Transactional)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您也可以在绑定形式中使用 <code>@within</code>。有关如何使注释对象在 advice 正文中可用的信息，请参见<a href="#声明-advice">声明 advice</a>部分。</p>
</blockquote>
<ul>
<li>任何执行方法带有 <code>@Transactional</code> 批注的联接点（仅在 Spring AOP 中是方法执行）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@annotation(org.springframework.transaction.annotation.Transactional)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您也可以在绑定形式中使用 <code>@annotation</code>。有关如何使注释对象在 advice 正文中可用的信息，请参见<a href="#声明-advice">声明 advice</a>部分。</p>
</blockquote>
<ul>
<li>任何采用单个参数的联接点（仅在 Spring AOP 中是方法执行），并且传递的参数的运行时类型具有@Classified 批注：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@args(com.xyz.security.Classified)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您也可以在绑定形式中使用“ @args”。 请参阅“声明 advice”部分，如何使 advice 对象中的注释对象可用。</p>
</blockquote>
<ul>
<li>名为 <code>tradeService</code> 的 Spring bean 上的任何连接点（仅在 Spring AOP 中执行方法）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean(tradeService)</span><br></pre></td></tr></table></figure>

<p>Spring Bean 上具有与通配符表达式 <code>*Service</code> 匹配的名称的任何连接点（仅在 Spring AOP 中才执行方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean(*Service)</span><br></pre></td></tr></table></figure>

<h4 id="写好切入点"><a href="#写好切入点" class="headerlink" title="写好切入点"></a>写好切入点</h4><p>在编译期间，AspectJ 处理切入点以优化匹配性能。检查代码并确定每个连接点是否（静态或动态）匹配给定的切入点是一个昂贵的过程。 （动态匹配意味着无法从静态分析中完全确定匹配，并且在代码中进行了测试以确定在运行代码时是否存在实际匹配）。首次遇到切入点声明时，AspectJ 将其重写为匹配过程的最佳形式。这是什么意思？基本上，切入点以 DNF（析取范式）重写，并且对切入点的组件进行排序，以便首先检查那些较便宜的组件。这意味着您不必担心理解各种切入点指示符的性能，并且可以在切入点声明中以任何顺序提供它们。</p>
<p>但是，AspectJ 只能使用所告诉的内容。为了获得最佳的匹配性能，您应该考虑他们试图达到的目标，并在定义中尽可能缩小匹配的搜索空间。现有的指示符自然分为三类之一：同类，作用域和上下文：</p>
<p>友好的指示者选择一种特殊的连接点：<code>execution</code>, <code>get</code>, <code>set</code>, <code>call</code>, 和 <code>handler</code></p>
<p>作用域指定者选择一组感兴趣的连接点（可能是多种）：<code>within</code> 和 <code>withincode</code></p>
<p>上下文指示符根据上下文匹配（并可选地绑定）：<code>this</code>, <code>target</code>, 和 <code>@annotation</code></p>
<p>编写正确的切入点至少应包括前两种类型（种类和作用域）。您可以包括上下文指示符以根据连接点上下文进行匹配，也可以绑定该上下文以在 advice 中使用。仅提供同类的标识符或仅提供上下文的标识符是可行的，但是由于额外的处理和分析，可能会影响编织性能（使用的时间和内存）。范围指定符的匹配非常快，使用它们的使用意味着 AspectJ 可以非常迅速地消除不应进一步处理的连接点组。一个好的切入点应尽可能包括一个切入点。</p>
<h3 id="声明-advice"><a href="#声明-advice" class="headerlink" title="声明 advice"></a>声明 advice</h3><p>advice 与切入点表达式关联，并且在切入点匹配的方法执行之前，之后或周围运行。 切入点表达式可以是对命名切入点的简单引用，也可以是就地声明的切入点表达式。</p>
<h4 id="Before-advice"><a href="#Before-advice" class="headerlink" title="Before advice"></a>Before advice</h4><p>您可以使用 <code>@Before</code> 批注在一个切面中声明先 advice ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用就地切入点表达式，则可以将前面的示例重写为以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.xyz.myapp.dao.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="After-Returning-advice"><a href="#After-Returning-advice" class="headerlink" title="After Returning advice"></a>After Returning advice</h4><p>当匹配的方法执行正常返回时，After returning advice 运行。 您可以使用 <code>@AfterReturning</code> 批注进行声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您可以在同一切面内拥有多个 advice 声明（以及其他成员）。在这些示例中，我们仅显示单个 advice 声明，以集中每个 advice 的效果。</p>
</blockquote>
<p>有时，您需要在 advice 正文中访问返回的实际值。 您可以使用 <code>@AfterReturning</code> 的形式绑定返回值以获取该访问，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(</span><br><span class="line">        pointcut=<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>,</span><br><span class="line">        returning=<span class="string">"retVal"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">(Object retVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>returning</code> 属性中使用的名称必须与 advice 方法中的参数名称相对应。当方法执行返回时，返回值将作为相应的参数值传递到 advice 方法。返回子句也将匹配限制为仅返回指定类型值的方法执行（在这种情况下为 <code>Object</code>，它匹配任何返回值）。</p>
<p>请注意，使用 after returning advice 时，不可能返回完全不同的引用。</p>
<h4 id="After-Throwing-Advice"><a href="#After-Throwing-Advice" class="headerlink" title="After Throwing Advice"></a>After Throwing Advice</h4><p>当匹配的方法执行通过抛出异常退出时 after throwing advice 运行。 您可以使用 <code>@AfterThrowing</code> 批注进行声明，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，您希望 advice 仅在引发给定类型的异常时才运行，并且您通常还需要访问 advice 正文中的引发异常。 您可以使用 <code>throwing</code> 属性来限制匹配（如果需要）（否则，请使用 <code>Throwable</code> 作为异常类型），并将抛出的异常绑定到 advice 参数。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(</span><br><span class="line">        pointcut=<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>,</span><br><span class="line">        throwing=<span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">(DataAccessException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>throwing</code> 属性中使用的名称必须与 advice 方法中的参数名称相对应。 当通过抛出异常退出方法执行时，该异常将作为相应的参数值传递给 advice 方法。 throwing 子句还将匹配仅限制为抛出指定类型的异常（在这种情况下为 <code>DataAccessException</code>）的方法执行。</p>
<h4 id="After-Finally-Advice"><a href="#After-Finally-Advice" class="headerlink" title="After (Finally) Advice"></a>After (Finally) Advice</h4><p>当匹配的方法执行退出时，After (Finally) Advice 运行。 通过使用 <code>@After</code> 注释声明它。 之后必须准备处理正常和异常返回条件的 advice。它通常用于释放资源和类似目的。 以下示例显示了最终 advice 后的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterFinallyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Around-Advice"><a href="#Around-Advice" class="headerlink" title="Around Advice"></a>Around Advice</h4><p>最后一种 advice 是 around advice。around advice 在匹配方法的执行过程中“around”运行。它有机会在方法执行之前和之后进行工作，并确定何时，如何以及什至根本不执行该方法。如果需要以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态，则通常使用绕行 advice。始终使用最不可行的 advice 形式来满足您的要求（也就是说，在 advice 可以使用之前，请勿在 advice 周围使用）。</p>
<p>通过使用 <code>@Around</code> 批注来声明周围 advice。咨询方法的第一个参数必须是 <code>ProceedingJoinPoint</code> 类型。在 advice 的正文中，在 <code>ProceedingJoinPoint</code> 上调用 <code>proceed()</code> 会使基础方法执行。<code>proceed</code> 方法也可以传入 <code>Object[]</code>。数组中的值用作方法执行时的参数。</p>
<blockquote>
<p>当用 <code>Object[]</code> 调用 <code>proceed</code> 时， 行为与 AspectJ 编译器所编译的 around advice 的行为略有不同。对于使用传统 AspectJ 语言编写的 around advice，传递给 <code>proceed</code> 的参数数量必须与传递给 around advice 的参数数量（而不是基础连接点采用的参数数量）相匹配，并且传递给给定的参数位置会取代该值绑定到的实体的连接点处的原始值（不要担心，如果这现在没有意义）。 Spring 采取的方法更简单，并且更适合其基于代理的，仅执行的语义。如果您编译为 Spring 编写的@AspectJ 切面，并在 AspectJ 编译器和 weaver 中使用参数进行处理，则只需要意识到这种区别。有一种方法可以在 Spring AOP 和 AspectJ 之间 100％兼容，并且在下面有关 advice 参数的部分中对此进行了讨论。</p>
</blockquote>
<p>以下示例显示了如何使用周围 advice：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>around advice 返回的值是该方法的调用者看到的返回值。例如，如果一个简单的缓存切面有一个值，则它可以从缓存中返回一个值，如果没有，则调用 <code>proceed()</code>。请注意，在 around advice 的正文中，<code>proceed</code> 可能被调用一次，多次或完全不被调用。所有这些都是合法的。</p>
<h4 id="Advice-参数"><a href="#Advice-参数" class="headerlink" title="Advice 参数"></a>Advice 参数</h4><p>Spring 提供了完全类型化的 advice，这意味着您可以在 advice 签名中声明所需的参数（如我们先前在返回和抛出示例中所看到的），而不是一直使用 <code>Object[]</code> 数组。 我们将在本节的后面部分介绍如何使参数和其他上下文值可用于 advice 主体。首先，我们看一下如何编写通用 advice，以了解该 advice 当前 advice 的方法。</p>
<h5 id="访问当前的-JoinPoint"><a href="#访问当前的-JoinPoint" class="headerlink" title="访问当前的 JoinPoint"></a>访问当前的 JoinPoint</h5><p>任何 advice 方法都可以将 <code>org.aspectj.lang.JoinPoint</code> 类型的参数声明为它的第一个参数（请注意，需要 around advice 以声明 <code>ProceedingJoinPoint</code> 类型的第一个参数，该类型是 JoinPoint 的子类。JoinPoint 接口提供了一个 几种有用的方法：</p>
<p><code>getArgs()</code>：返回方法参数。</p>
<p><code>getThis()</code>：返回代理对象。</p>
<p><code>getTarget()</code>：返回目标对象。</p>
<p><code>getSignature()</code>：返回所 advice 方法的描述。</p>
<p><code>toString()</code>：打印有关所 advice 方法的有用描述。</p>
<p>有关更多详细信息，请参见 <a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html" target="_blank" rel="noopener">javadoc</a>。</p>
<h5 id="将参数传递给-advice"><a href="#将参数传递给-advice" class="headerlink" title="将参数传递给 advice"></a>将参数传递给 advice</h5><p>我们已经看到了如何绑定返回的值或异常值（在返回之后和引发 advice 之后使用）。要使参数值可用于 advice 正文，可以使用 <code>args</code> 的绑定形式。如果在 <code>args</code> 表达式中使用参数名称代替类型名称，则在调用 advice 时会将相应参数的值作为参数值传递。一个例子应该使这一点更清楚。假设您要 advice 以 <code>Account</code> 对象作为第一个参数的 DAO 操作的执行，并且您需要在 advice 正文中访问该帐户。您可以编写以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切入点表达式的 <code>args(account,..)</code> 部分有两个用途。首先，它将匹配限制为仅方法采用至少一个参数且传递给该参数的参数为 <code>​​Account</code> 实例的那些方法执行。其次，它通过 <code>account</code> 参数使 advice 的实际 <code>Account</code> 对象可用。</p>
<p>编写此代码的另一种方法是声明一个切入点，当切入点与匹配点匹配时“提供” <code>Account</code> 对象值，然后从通知中引用命名切入点。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accountDataAccessOperation</span><span class="params">(Account account)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"accountDataAccessOperation(account)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关更多详细信息，请参见 AspectJ 编程指南。</p>
<p>代理对象（<code>this</code>），目标对象（<code>target</code>）和注释（<code>@within</code>，<code>@target</code>，<code>@annotation</code> 和 <code>@args</code>）都可以以类似的方式绑定。接下来的两个示例显示如何匹配使用 <code>@Auditable</code> 注释注释的方法的执行并提取审计代码：</p>
<p>这两个示例中的第一个显示了 <code>@Auditable</code> 批注的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Auditable &#123;</span><br><span class="line">    <span class="function">AuditCode <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个示例中的第二个示例显示了与 <code>@Auditable</code> 方法的执行相匹配的 advice：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="advice-参数和泛型"><a href="#advice-参数和泛型" class="headerlink" title="advice 参数和泛型"></a>advice 参数和泛型</h5><p>Spring AOP 可以处理类声明和方法参数中使用的泛型。假设您具有如下通用类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sample</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericMethod</span><span class="params">(T param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericCollectionMethod</span><span class="params">(Collection&lt;T&gt; param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以通过在要拦截方法的参数类型中键入 advice 参数，将方法类型的拦截限制为某些参数类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(MyType param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advice implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法不适用于通用集合。因此，您不能按以下方式定义切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(Collection&lt;MyType&gt; param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advice implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使这项工作有效，我们将不得不检查集合的每个元素，这是不合理的，因为我们也无法决定通常如何处理空值。要实现类似的目的，您必须定义参数 <code>Collection&lt;?&gt;</code> 并手动检查元素的类型。</p>
<h5 id="确定参数名称"><a href="#确定参数名称" class="headerlink" title="确定参数名称"></a>确定参数名称</h5><p>通知调用中的参数绑定依赖于切入点表达式中使用的名称与通知和切入点方法签名中声明的参数名称的匹配。通过 Java 反射无法获得参数名称，因此 Spring AOP 使用以下策略来确定参数名称：</p>
<ul>
<li>如果用户已明确指定参数名称，则使用指定的参数名称。advice 和切入点注释均具有可选的 <code>argNames</code> 属性，您可以使用该属性来指定带注释的方法的参数名称。这些参数名称在运行时可用。以下示例显示如何使用 <code>argNames</code> 属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)"</span>,</span><br><span class="line">        argNames=<span class="string">"bean,auditable"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Object bean, Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ... use code and bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第一个参数是 <code>JoinPoint</code>，<code>ProceedingJoinPoint</code> 或 <code>JoinPoint.StaticPart</code> 类型，则可以从 <code>argNames</code> 属性的值中忽略该参数的名称。例如，如果您修改前面的 advice 以接收连接点对象，则 <code>argNames</code> 属性不需要包括它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)"</span>,</span><br><span class="line">        argNames=<span class="string">"bean,auditable"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp, Object bean, Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ... use code, bean, and jp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>JoinPoint</code>，<code>ProceedingJoinPoint</code> 和 <code>JoinPoint.StaticPart</code> 类型的第一个参数给予的特殊处理对于不收集任何其他联接点上下文的 advice 实例特别方便。 在这种情况下，您可以省略 <code>argNames</code> 属性。 例如，以下 advice 无需声明 <code>argNames</code> 属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"com.xyz.lib.Pointcuts.anyPublicMethod()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... use jp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>&#39;argNames&#39;</code> 属性有点笨拙，因此，如果未指定 <code>&#39;argNames&#39;</code> 属性，Spring AOP 将查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要已使用调试信息（至少是 <code>&#39;-g:vars&#39;</code> ）编译了类，此信息就会存在。启用此标志时进行编译的结果是：（1）您的代码更易于理解（反向工程），（2）类文件的大小略大（通常无关紧要），（3）删除未使用的本地代码的优化变量不适用于您的编译器。换句话说，通过启用该标志，您应该不会遇到任何困难。</li>
</ul>
<blockquote>
<p>如果即使没有调试信息，AspectJ 编译器（ajc）都已编译 @AspectJ 切面，则无需添加 <code>argNames</code> 属性，因为编译器会保留所需的信息。</p>
</blockquote>
<ul>
<li><p>如果在没有必要调试信息的情况下编译了代码，Spring AOP 将尝试推断绑定变量与参数的配对（例如，如果切入点表达式中仅绑定了一个变量，并且 advice 方法仅接受一个参数，则配对很明显）。如果在给定可用信息的情况下变量的绑定不明确，则抛出 <code>AmbiguousBindingException</code>。</p>
</li>
<li><p>如果以上所有策略均失败，则抛出 <code>IllegalArgumentException</code>。</p>
</li>
</ul>
<h5 id="带参数执行"><a href="#带参数执行" class="headerlink" title="带参数执行"></a>带参数执行</h5><p>前面我们提到过，我们将描述如何编写一个在 Spring AOP 和 AspectJ 中始终有效的参数的 <code>proceed</code> 调用。 解决方案是确保 advice 签名按顺序绑定每个方法参数。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(List&lt;Account&gt; find*(..)) &amp;&amp; "</span> +</span><br><span class="line">        <span class="string">"com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; "</span> +</span><br><span class="line">        <span class="string">"args(accountHolderNamePattern)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">preProcessQueryPattern</span><span class="params">(ProceedingJoinPoint pjp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String accountHolderNamePattern)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String newPattern = preProcess(accountHolderNamePattern);</span><br><span class="line">    <span class="keyword">return</span> pjp.proceed(<span class="keyword">new</span> Object[] &#123;newPattern&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在许多情况下，无论如何都要进行此绑定（如上例所示）。</p>
<h4 id="advice-顺序"><a href="#advice-顺序" class="headerlink" title="advice 顺序"></a>advice 顺序</h4><p>当多条 advice 都希望在同一连接点上运行时会发生什么？ Spring AOP 遵循与 AspectJ 相同的优先级规则来确定 advice 执行的顺序。优先级最高的 advice 首先“在途中”运行（因此，给定两条优先 advice，则优先级最高的 advice 首先运行）。从连接点“出路”时，优先级最高的 advice 将最后运行（因此，给定两条后置通知，优先级最高的 advice 将第二次运行）。</p>
<p>当在不同切面定义的两条 advice 都需要在同一连接点上运行时，除非另行指定，否则执行顺序是不确定的。您可以通过指定优先级来控制执行顺序。通过在切面类中实现 <code>org.springframework.core.Ordered</code> 接口或使用 Order 批注对其进行注释，可以通过常规的 Spring 方法来完成。给定两个切面，从 <code>Ordered.getValue()</code>（或注释值）返回较低值的切面具有较高的优先级。</p>
<p>当在相同切面定义的两条 advice 都需要在同一连接点上运行时，其顺序是未定义的（因为无法通过反射为 javac 编译的类检索声明顺序）。考虑将这些 advice 方法折叠为每个切面类中每个连接点的一个 advice 方法，或将 advice 重构为单独的切面类，您可以在切面级别进行订购。</p>
<h3 id="简介-Introductions"><a href="#简介-Introductions" class="headerlink" title="简介 Introductions"></a>简介 Introductions</h3><p>简介（在 AspectJ 中称为类型间声明）使切面可以声明 advice 对象实现给定的接口，并代表那些对象提供该接口的实现。</p>
<p>您可以使用 @DeclareParents 批注进行介绍。 此批注用于声明匹配类型具有新的父代（因此具有名称）。 例如，给定一个名为 UsageTracked 的接口和该接口名为 DefaultUsageTracked 的实现，以下切面声明服务接口的所有实现者也都实现了 UsageTracked 接口（例如，通过 JMX 公开统计信息）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents</span>(value=<span class="string">"com.xzy.myapp.service.*+"</span>, defaultImpl=DefaultUsageTracked.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;</span><br><span class="line">        usageTracked.incrementUseCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现的接口由带注释的字段的类型确定。 @DeclareParents 批注的 value 属性是 AspectJ 类型的模式。 匹配类型的任何 bean 都实现 UsageTracked 接口。 请注意，在前面示例的之前 advice 中，服务 Bean 可以直接用作 UsageTracked 接口的实现。 如果以编程方式访问 bean，则应编写以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string">"myService"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="切面实例化模型"><a href="#切面实例化模型" class="headerlink" title="切面实例化模型"></a>切面实例化模型</h3><blockquote>
<p>这是一个高级主题。如果您刚开始使用 AOP，则可以放心地跳过它，直到以后。</p>
</blockquote>
<p>默认情况下，应用程序上下文中每个切面都有一个实例。 AspectJ 将此称为单例实例化模型。 可以使用备用生命周期来定义切面。 Spring 支持 AspectJ 的 <code>perthis</code> 和 <code>pertarget</code> 实例化模型（当前不支持 <code>percflow</code>，<code>percflowbelow</code> 和 <code>pertypewithin</code>）。</p>
<p>您可以通过在 <code>@Aspect</code> 批注中指定 <code>perthis</code> 子句来声明 <code>perthis</code> 切面。 考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>(<span class="string">"perthis(com.xyz.myapp.SystemArchitecture.businessService())"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> someState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(com.xyz.myapp.SystemArchitecture.businessService())</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordServiceUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，<code>&#39;perthis&#39;</code> 子句的作用是为每个执行业务服务的唯一服务对象（每个与切入点表达式匹配的联接点绑定到 “this” 的唯一对象）创建一个切面实例。切面实例是在服务对象上首次调用方法时创建的。 当服务对象超出范围时，切面将超出范围。在创建切面实例之前，其中的任何 advice 都不会执行。创建切面实例后，在其中声明的 advice 将在匹配的连接点处执行，但是仅当服务对象是与此切面相关联的对象时才执行。有关 <code>per</code> 子句的更多信息，请参见 AspectJ 编程指南。</p>
<p><code>pertarget</code> 实例化模型的工作方式与 <code>perthis</code> 完全相同，但是它在匹配的连接点为每个唯一目标对象创建一个切面实例。</p>
<h3 id="AOP-示例"><a href="#AOP-示例" class="headerlink" title="AOP 示例"></a>AOP 示例</h3><p>既然您已经了解了所有组成部分是如何工作的，那么我们可以将它们放在一起做一些有用的事情。</p>
<p>有时由于并发问题（例如，死锁失败者），业务服务的执行可能会失败。如果重试该操作，则很可能在下一次尝试中成功。对于适合在这种情况下重试的业务（不需要为解决冲突而需要返回给用户的幂等操作），我们希望透明地重试该操作，以避免客户端看到 <code>PessimisticLockingFailureException</code>。这项要求明确地跨越了服务层中的多个服务，因此非常适合通过一个切面实施。</p>
<p>因为我们想重试该操作，所以我们需要使用周围 advice，以便可以多次调用 proceed。 以下清单显示了基本切面的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentOperationExecutor</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> order = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxRetries</span><span class="params">(<span class="keyword">int</span> maxRetries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxRetries = maxRetries;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doConcurrentOperation</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numAttempts = <span class="number">0</span>;</span><br><span class="line">        PessimisticLockingFailureException lockFailureException;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            numAttempts++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(PessimisticLockingFailureException ex) &#123;</span><br><span class="line">                lockFailureException = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(numAttempts &lt;= <span class="keyword">this</span>.maxRetries);</span><br><span class="line">        <span class="keyword">throw</span> lockFailureException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，切面实现了 <code>Ordered</code> 接口，因此我们可以将切面的优先级设置为高于事务 advice（每次重试时都希望有新的事务）。 maxRetries 和 order 属性均由 Spring 配置。 advice 的主要动作发生在 <code>doConcurrentOperation</code> 中。 请注意，目前，我们将重试逻辑应用于每个 <code>businessService()</code>。 我们尝试继续，如果失败并出现 <code>PessimisticLockingFailureException</code>，则我们将再次尝试，除非我们用尽了所有重试尝试。</p>
<p>相应的 Spring 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"concurrentOperationExecutor"</span> <span class="attr">class</span>=<span class="string">"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxRetries"</span> <span class="attr">value</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了完善切面，使其仅重试幂等运算，我们可以定义以下幂等注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Idempotent &#123;</span><br><span class="line">    <span class="comment">// marker annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们可以使用注释来注释服务操作的实现。切面更改为仅重试幂等操作涉及更改切入点表达式，以便仅 <code>@Idempotent</code> 操作匹配，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; "</span> +</span><br><span class="line">        <span class="string">"@annotation(com.xyz.myapp.service.Idempotent)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doConcurrentOperation</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于-Schema-的-AOP-支持"><a href="#基于-Schema-的-AOP-支持" class="headerlink" title="基于 Schema 的 AOP 支持"></a>基于 Schema 的 AOP 支持</h2><p>如果您更喜欢基于 XML 的格式，Spring 还提供了使用新的 aop 名称空间标签定义切面的支持。支持与使用 <code>@AspectJ</code> 样式时完全相同的切入点表达式和 advice 类型。因此，在本节中，我们将重点放在新语法上，并使读者参考上一节中的讨论（<code>@AspectJ</code> 支持），以了解编写切入点表达式和 advice 参数的绑定。</p>
<p>要使用本节中描述的 aop 名称空间标签，您需要导入 spring-aop 模式，如基于 XML Schema 的配置中所述。有关如何在 aop 名称空间中导入标签的信息，请参见 AOP 模式。</p>
<p>在您的 Spring 配置中，所有切面和顾问程序元素都必须放在 <code>&lt;aop:config&gt;</code> 元素内（在应用程序上下文配置中可以有多个 <code>&lt;aop:config&gt;</code> 元素）。<code>&lt;aop:config&gt;</code> 元素可以包含切入点，顾问程序和 aspect 元素（请注意，必须按此顺序声明它们）。</p>
<blockquote>
<p><code>&lt;aop:config&gt;</code> 的配置样式大量使用了 Spring 的自动代理机制。如果您已经通过使用 <code>BeanNameAutoProxyCreator</code> 或类似方法使用显式自动代理，则可能会导致问题（例如，未编制 advice）。推荐的用法模式是仅使用 <code>&lt;aop:config&gt;</code> 样式或仅使用 <code>AutoProxyCreator</code> 样式，并且不要混合使用。</p>
</blockquote>
<p>因为我不喜欢 XML 格式，此段暂时跳过，原文参考 <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-schema" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-schema</a></p>
<h2 id="选择要使用的-AOP-声明样式"><a href="#选择要使用的-AOP-声明样式" class="headerlink" title="选择要使用的 AOP 声明样式"></a>选择要使用的 AOP 声明样式</h2><p>一旦确定切面是实现给定需求的最佳方法，您如何在使用 Spring AOP 或 AspectJ 以及在 Aspect 语言（代码）样式，@ AspectJ 批注样式或 Spring XML 样式之间做出选择？这些决定受许多因素影响，包括应用程序需求，开发工具和团队对 AOP 的熟悉程度。</p>
<h3 id="Spring-AOP-还是-Full-AspectJ？"><a href="#Spring-AOP-还是-Full-AspectJ？" class="headerlink" title="Spring AOP 还是 Full AspectJ？"></a>Spring AOP 还是 Full AspectJ？</h3><p>使用最简单的方法即可。 Spring AOP 比使用完整的 AspectJ 更简单，因为不需要在开发和构建过程中引入 AspectJ 编译器/编织器。如果您只需要 advice 在 Spring bean 上执行操作，则 Spring AOP 是正确的选择。如果您需要 advice 不受 Spring 容器管理的对象（通常是域对象），则需要使用 AspectJ。如果您希望 advice 除简单方法执行之外的连接点（例如，字段 get 或设置连接点等），则还需要使用 AspectJ。</p>
<p>使用 AspectJ 时，可以选择 AspectJ 语言语法（也称为“代码样式”）或@AspectJ 注释样式。显然，如果您不使用 Java 5+，则已经为您做出了选择：使用代码样式。如果切面在您的设计中起着重要作用，并且您能够使用用于 Eclipse 的 AspectJ 开发工具（AJDT）插件，则 AspectJ 语言语法是首选。它更干净，更简单，因为该语言是专为编写切面而设计的。如果您不使用 Eclipse 或只有少数几个切面在您的应用程序中不起作用，那么您可能要考虑使用@AspectJ 样式，在 IDE 中坚持常规 Java 编译，并向其中添加切面编织阶段您的构建脚本。</p>
<h3 id="AspectJ-或-Spring-AOP-的-XML？"><a href="#AspectJ-或-Spring-AOP-的-XML？" class="headerlink" title="@AspectJ 或 Spring AOP 的 XML？"></a>@AspectJ 或 Spring AOP 的 XML？</h3><p>如果您选择使用 Spring AOP，则可以选择 @AspectJ 或 XML 样式。有各种折衷考虑。</p>
<p>XML 样式可能是现有 Spring 用户最熟悉的，并且得到了真正的 POJO 的支持。当使用 AOP 作为配置企业服务的工具时，XML 是一个不错的选择（一个很好的测试是您是否将切入点表达式视为您可能希望独立更改的配置的一部分）。使用 XML 样式，可以说从您的配置中可以更清楚地了解系统中存在哪些切面。</p>
<p>XML 样式有两个缺点。首先，它没有完全将要解决的需求的实现封装在一个地方。 DRY 原则说，系统中的任何知识都应该有一个单一，明确，权威的表示形式。使用 XML 样式时，关于如何实现需求的知识会在配置文件中的后备 bean 类的声明和 XML 中分散。当您使用@AspectJ 样式时，此信息将封装在一个模块中：切面。其次，与@AspectJ 样式相比，XML 样式在表达能力上有更多限制：仅支持“单例”切面实例化模型，并且无法组合以 XML 声明的命名切入点。例如，使用@AspectJ 样式，您可以编写如下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* get*())"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">propertyAccess</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(org.xyz.Account+ *(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationReturningAnAccount</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"propertyAccess() &amp;&amp; operationReturningAnAccount()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountPropertyAccess</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在 XML 样式中，您可以声明前两个切入点：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"propertyAccess"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">"execution(* get*())"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"operationReturningAnAccount"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">"execution(org.xyz.Account+ *(..))"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>XML 方法的缺点是您无法通过组合这些定义来定义 <code>accountPropertyAccess</code> 切入点。</p>
<p>@AspectJ 样式支持其他实例化模型和更丰富的切入点组合。 它具有将切面保持为模块化单元的优势。 它还具有的优点是，Spring AOP 和 AspectJ 都可以理解 @AspectJ 切面。 因此，如果您以后决定需要 AspectJ 的功能来实现其他要求，则可以轻松地迁移到经典的 AspectJ 设置。 总而言之，Spring 团队在自定义切面更喜欢 @AspectJ 样式，而不是简单地配置企业服务。</p>
<h2 id="混合切面类型"><a href="#混合切面类型" class="headerlink" title="混合切面类型"></a>混合切面类型</h2><p>通过使用自动代理支持，模式定义的<code>&lt;aop:aspect&gt;</code>切面，<code>&lt;aop:advisor&gt;</code> 声明的顾问程序，甚至是同一配置中其他样式的代理和拦截器，完全可以混合 @AspectJ 样式的切面。 所有这些都是通过使用相同的基础支持机制实现的，并且可以毫无困难地共存。</p>
<h2 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h2><p>Spring AOP 使用 JDK 动态代理或 CGLIB 创建给定目标对象的代理。 JDK 动态代理内置在 JDK 中，而 CGLIB 是常见的开源类定义库（重新包装到 <code>spring-core</code> 中）。</p>
<p>如果要代理的目标对象实现至少一个接口，则使用 JDK 动态代理。代理了由目标类型实现的所有接口。如果目标对象未实现任何接口，则将创建 CGLIB 代理。</p>
<p>如果要强制使用 CGLIB 代理（例如，代理为目标对象定义的每个方法，而不仅是由其接口实现的方法），都可以这样做。但是，您应该考虑以下问题：</p>
<ul>
<li>使用 CGLIB，不能 advice final 方法，因为不能在运行时生成的子类中覆盖它们。</li>
<li>从 Spring 4.0 开始，由于 CGLIB 代理实例是通过 Objenesis 创建的，因此不再调用代理对象的构造函数两次。只有在您的 JVM 不允许绕过构造函数的情况下，您才可能从 Spring 的 AOP 支持中看到两次调用和相应的调试日志条目。</li>
</ul>
<p>要强制使用 CGLIB 代理，请将 <code>&lt;aop:config&gt;</code> 元素的 <code>proxy-target-class</code> 属性的值设置为 true，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- other beans defined here... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要在使用 <code>@AspectJ</code> 自动代理支持时强制 CGLIB 代理，请将 <code>&lt;aop:aspectj-autoproxy&gt;</code> 元素的 <code>proxy-target-class</code> 属性设置为 true，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>多个 <code>&lt;aop:config/&gt;</code> 部分在运行时折叠到一个统一的自动代理创建器中，该创建器将应用任何 <code>&lt;aop:config/&gt;</code> 部分（通常来自不同的 XML bean 定义文件）指定的最强的代理设置。 这也适用于 <code>&lt;tx:annotation-driven/&gt;</code> 和 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素。</p>
<p>为了清楚起见，在 <code>&lt;tx:annotation-driven/&gt;</code>，<code>&lt;aop:aspectj-autoproxy/&gt;</code> 或 <code>&lt;aop:config/&gt;</code> 元素上使用 <code>proxy-target-class=&quot;true&quot;</code> 会强制对所有三个元素使用 CGLIB 代理。</p>
</blockquote>
<h3 id="理解-AOP-代理"><a href="#理解-AOP-代理" class="headerlink" title="理解 AOP 代理"></a>理解 AOP 代理</h3><p>Spring AOP 是基于代理的。 在编写自己的切面或使用 Spring Framework 随附的任何基于 Spring AOP 的切面之前，掌握最后一条语句实际含义的语义至关重要。</p>
<p>首先考虑以下情况：您有一个普通的，未经代理的，无特殊要求的直接对象引用，如以下代码片段所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="keyword">implements</span> <span class="title">Pojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this next method invocation is a direct call on the 'this' reference</span></span><br><span class="line">        <span class="keyword">this</span>.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在对象引用上调用方法，则直接在该对象引用上调用该方法，如下图所示：</p>
<p><img src="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/images/aop-proxy-plain-pojo-call.png" alt="aop-proxy-plain-pojo-call"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pojo pojo = <span class="keyword">new</span> SimplePojo();</span><br><span class="line">        <span class="comment">// this is a direct method call on the 'pojo' reference</span></span><br><span class="line">        pojo.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端代码具有的引用是代理时，情况会稍有变化。考虑以下图表和代码片段：</p>
<p><img src="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/images/aop-proxy-call.png" alt="aop-proxy-call"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());</span><br><span class="line">        factory.addInterface(Pojo.class);</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> RetryAdvice());</span><br><span class="line"></span><br><span class="line">        Pojo pojo = (Pojo) factory.getProxy();</span><br><span class="line">        <span class="comment">// this is a method call on the proxy!</span></span><br><span class="line">        pojo.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处要理解的关键是，Main 类的 <code>main(..)</code> 方法内部的客户端代码具有对代理的引用。 这意味着该对象引用上的方法调用是代理上的调用。结果，代理可以委派给与该特定方法调用相关的所有拦截器（advice）。 但是，一旦调用最终到达目标对象（在此示例中为 <code>SimplePojo</code>，则为引用），它可能对其自身进行的任何方法调用（例如 <code>this.bar()</code> 或 <code>this.foo()</code>）都是针对 this 引用的调用，而不是代理。这具有重要意义。这意味着自调用不会导致与方法调用相关的 advice 得到执行的机会。</p>
<p>好吧，那么该怎么办？ 最佳方法（在这里宽松地使用术语“最佳”）是重构代码，以免发生自调用。这确实需要您做一些工作，但这是最好的，侵入性最小的方法。下一种方法绝对可怕，我们正要指出这一点，恰恰是因为它是如此可怕。您可以（对我们来说是痛苦的）完全将类中的逻辑与 Spring AOP 绑定在一起，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="keyword">implements</span> <span class="title">Pojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this works, but... gah!</span></span><br><span class="line">        ((Pojo) AopContext.currentProxy()).bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将您的代码完全耦合到 Spring AOP，并且使类本身意识到在 AOP 上下文中使用它的事实，而 AOP 上下文却是这样。创建代理时，还需要一些其他配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());</span><br><span class="line">        factory.addInterface(Pojo.class);</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> RetryAdvice());</span><br><span class="line">        factory.setExposeProxy(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Pojo pojo = (Pojo) factory.getProxy();</span><br><span class="line">        <span class="comment">// this is a method call on the proxy!</span></span><br><span class="line">        pojo.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，必须注意，AspectJ 没有此自调用问题，因为它不是基于代理的 AOP 框架。</p>
<h2 id="以编程方式创建-AspectJ-代理"><a href="#以编程方式创建-AspectJ-代理" class="headerlink" title="以编程方式创建 @AspectJ 代理"></a>以编程方式创建 @AspectJ 代理</h2><p>除了通过使用 <code>&lt;aop:config&gt;</code> 或 <code>&lt;aop:aspectj-autoproxy&gt;</code> 声明配置中的各个切面外，还可以通过编程方式创建建议目标对象的代理。有关 Spring 的 AOP API 的完整详细信息，请参阅下一章。在这里，我们要重点介绍使用 @AspectJ 切面自动创建代理的功能。</p>
<p>您可以使用 <code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> 类为一个或多个 @AspectJ 切面建议的目标对象创建代理。此类的基本用法非常简单，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a factory that can generate a proxy for the given target object</span></span><br><span class="line">AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory(targetObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add an aspect, the class must be an @AspectJ aspect</span></span><br><span class="line"><span class="comment">// you can call this as many times as you need with different aspects</span></span><br><span class="line">factory.addAspect(SecurityManager.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span></span><br><span class="line">factory.addAspect(usageTracker);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now get the proxy object...</span></span><br><span class="line">MyInterfaceType proxy = factory.getProxy();</span><br></pre></td></tr></table></figure>

<p>有关更多信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/5.3.0-SNAPSHOT/javadoc-api/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.html" target="_blank" rel="noopener">javadoc</a>。</p>
<h2 id="在-Spring-应用程序中使用-AspectJ"><a href="#在-Spring-应用程序中使用-AspectJ" class="headerlink" title="在 Spring 应用程序中使用 AspectJ"></a>在 Spring 应用程序中使用 AspectJ</h2><p>到目前为止，本章介绍的所有内容都是纯 Spring AOP。 在本节中，我们将研究如果您的需求超出了 Spring AOP 所提供的功能，那么如何使用 AspectJ 编译器或 weaver 代替 Spring AOP 或除 Spring AOP 之外使用。</p>
<p>Spring 附带了一个小的 AspectJ 切面库，该库在您的发行版中可以作为 <code>spring-aspects.jar</code> 独立使用。您需要将其添加到类路径中才能使用其中的切面。<a href="#使用-AspectJ-通过-Spring-依赖注入域对象">使用 AspectJ 通过 Spring 依赖注入域对象</a><br>和 <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-ajlib-other" target="_blank" rel="noopener">AspectJ 的其他 Spring 切面</a> 讨论了该库的内容以及如何使用它。 <a href>使用 Spring IoC 配置 AspectJ 切面</a>讨论了如何依赖注入使用 AspectJ 编译器编织的 AspectJ 切面。 最后，<a href>Spring Framework 中使用 AspectJ 进行的加载时编织</a>为使用 AspectJ 的 Spring 应用程序提供了加载时编织的介绍。</p>
<h3 id="使用-AspectJ-通过-Spring-依赖注入域对象"><a href="#使用-AspectJ-通过-Spring-依赖注入域对象" class="headerlink" title="使用 AspectJ 通过 Spring 依赖注入域对象"></a>使用 AspectJ 通过 Spring 依赖注入域对象</h3><p>Spring 容器实例化并配置在您的应用程序上下文中定义的 bean。 给定包含要应用的配置的 Bean 定义的名称，也可以要求 Bean 工厂配置预先存在的对象。 <code>spring-aspects.jar</code> 包含注释驱动的切面，该切面利用此功能允许依赖项注入任何对象。 该支撑旨在用于在任何容器的控制范围之外创建的对象。 域对象通常属于此类，因为它们通常是通过数据库查询的结果由 new 运算符或 ORM 工具以编程方式创建的。</p>
<p><code>@Configurable</code> 批注将一个类标记为符合 Spring 驱动的配置。 在最简单的情况下，您可以将其纯粹用作标记注释，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当以这种方式用作标记接口时，Spring 通过使用具有与完全限定类型名称（<code>com.xyz.myapp.domain.Account</code>）相同名称的 bean 定义（通常为原型作用域）来配置带注释类型的新实例（在这种情况下为 Account）。由于 bean 的默认名称是其类型的全限定名，因此声明原型定义的便捷方法是省略 id 属性，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xyz.myapp.domain.Account"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fundsTransferService"</span> <span class="attr">ref</span>=<span class="string">"fundsTransferService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要显式指定要使用的原型 bean 定义的名称，则可以直接在批注中这样做，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurable</span>(<span class="string">"account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 现在查找名为 account 的 bean 定义，并将其用作配置新 Account 实例的定义。</p>
<p>您也可以使用自动装配来避免完全指定专用的 bean 定义。要让 Spring 应用自动装配，请使用 <code>@Configurable</code> 批注的 <code>autowire</code> 属性。您可以指定 <code>@Configurable(autowire=Autowire.BY_TYPE)</code> 或 <code>@Configurable(autowire=Autowire.BY_NAME)</code> 分别按类型或名称进行自动装配。作为替代方案，最好为您的对象指定显式的，注释驱动的依赖项注入。通过 <code>@Autowired</code> 或 <code>@Inject</code> 在字段或方法级别上使用 <code>@Configurable</code> bean（有关更多详细信息，请参见基于注释的容器配置）。</p>
<p>最后，您可以使用 <code>dependencyCheck</code> 属性（例如，<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>）为新创建和配置的对象中的对象引用启用 Spring 依赖检查。如果此属性设置为 true，则 Spring 在配置后验证是否已设置所有属性（不是基本类型或集合）。</p>
<p>请注意，单独使用注释不会执行任何操作。<code>spring-aspects.jar</code> 中的 <code>AnnotationBeanConfigurerAspect</code> 会对注释的存在起作用。从本质上讲，切面说：“在从带有 <code>@Configurable</code> 注释的类型的新对象的初始化返回之后，使用 Spring 根据注释的属性配置新创建的对象”。在这种情况下，“初始化”是指新实例化的对象（例如，用 new 运算符实例化的对象）以及正在进行反序列化（例如，通过 <code>readResolve()</code> 的可序列化的对象）。</p>
<blockquote>
<p>上段中的关键短语之一是“本质上”。在大多数情况下，“从新对象的初始化返回后”的确切语义是可以的。在这种情况下，“初始化之后”是指在构造对象之后注入依赖项。这意味着该依赖项不可在类的构造函数体中使用。如果您希望在构造函数主体执行之前注入依赖项，从而可以在构造函数主体中使用这些依赖项，则需要在 <code>@Configurable</code> 声明中对此进行定义，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Configurable</span>(preConstruction = <span class="keyword">true</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>您可以在<a href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html" target="_blank" rel="noopener">AspectJ 编程指南</a>的<a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html" target="_blank" rel="noopener">此附录</a>中找到有关各种切入点类型的语言语义的更多信息。</p>
</blockquote>
<p>为此，必须将带注释的类型与 AspectJ 编织器编织在一起。您可以使用构建时的 Ant 或 Maven 任务来执行此操作（例如，参见《 AspectJ 开发环境指南》），也可以使用加载时编织（请参见 Spring Framework 中的使用 AspectJ 进行加载时编织）。 Spring 需要配置 <code>AnnotationBeanConfigurerAspect</code> 自身（以便获得对将用于配置新对象的 Bean 工厂的引用）。如果使用基于 Java 的配置，则可以将 <code>@EnableSpringConfigured</code> 添加到任何 <code>@Configuration</code> 类中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSpringConfigured</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您更喜欢基于 XML 的配置，则 Spring 上下文名称空间定义了一个方便的 <code>context:spring-configured</code> 元素，您可以按以下方式使用它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:spring-configured</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除非您真的想在运行时依赖它的语义，否则不要通过 bean configurer 切面激活 <code>@Configurable</code> 处理。特别是，请确保不要在通过容器注册为常规 Spring bean 的 bean 类上使用 <code>@Configurable</code>。这样做会导致两次初始化，一次是通过容器，一次是通过切面。</p>
</blockquote>
<h4 id="单元测试-Configurable-对象"><a href="#单元测试-Configurable-对象" class="headerlink" title="单元测试@Configurable 对象"></a>单元测试@Configurable 对象</h4><p><code>@Configurable</code> 支持的目标之一是实现域对象的独立单元测试，而不会遇到与硬编码查找相关的困难。如果 AspectJ 尚未编织 <code>@Configurable</code> 类型，则注释在单元测试期间不起作用。您可以在被测对象中设置模拟或存根属性引用，然后照常进行。如果 AspectJ 编织了 <code>@Configurable</code> 类型，您仍然可以像往常一样在容器外部进行单元测试，但是每次构造 <code>@Configurable</code> 对象时，您都会看到一条警告消息，指示该对象尚未由 Spring 配置。</p>
<h4 id="使用多个应用程序上下文"><a href="#使用多个应用程序上下文" class="headerlink" title="使用多个应用程序上下文"></a>使用多个应用程序上下文</h4><p>用于实现 <code>@Configurable</code> 支持的 <code>AnnotationBeanConfigurerAspect</code> 是 AspectJ 单例切面。单例切面的范围与静态成员的范围相同：每个类加载器都有一个切面实例来定义类型。这意味着，如果您在同一个类加载器层次结构中定义多个应用程序上下文，则需要考虑在何处定义@EnableSpringConfigured bean，以及在哪里将 spring-aspects.jar 放置在类路径上。</p>
<p>考虑一个典型的 Spring Web 应用程序配置，该配置具有一个共享的父应用程序上下文，该上下文定义了通用的业务服务，支持那些服务所需的一切，以及每个 Servlet 的一个子应用程序上下文（其中包含该 Servlet 的特定定义）。所有这些上下文共存于同一类加载器层次结构中，因此 <code>AnnotationBeanConfigurerAspect</code> 只能保存对其中一个的引用。在这种情况下，我们建议在共享（父）应用程序上下文中定义<code>@EnableSpringConfigured</code> bean。这定义了您可能想注入域对象的服务。结果是，您无法使用@Configurable 机制来配置域对象，该域对象引用的是在子（特定于 servlet 的）上下文中定义的 Bean 的引用（无论如何，这可能不是您想要做的）。</p>
<p>在同一容器中部署多个 Web 应用程序时，请确保每个 Web 应用程序通过使用其自己的类加载器（例如，将 <code>spring-aspects.jar</code> 放置在 <code>&#39;WEB-INF/lib&#39;</code> 中）将其类型加载到 <code>spring-aspects.jar</code> 中。如果将 <code>spring-aspects.jar</code> 仅添加到容器级的类路径中（并因此由共享的父类加载器加载），则所有 Web 应用程序都共享相同的切面实例（可能不是您想要的）。</p>
<h3 id="AspectJ-的其他-Spring-切面"><a href="#AspectJ-的其他-Spring-切面" class="headerlink" title="AspectJ 的其他 Spring 切面"></a>AspectJ 的其他 Spring 切面</h3><p>除了 <code>@Configurable</code> 切面之外，<code>spring-aspects.jar</code> 还包含一个 AspectJ 切面，您可以使用该切面来驱动 Spring 的事务管理，以使用 <code>@Transactional</code> 批注来批注类型和方法。这主要适用于希望在 Spring 容器之外使用 Spring Framework 的事务支持的用户。</p>
<p>解释 <code>@Transactional</code> 批注的切面是 <code>AnnotationTransactionAspect</code>。使用此切面时，必须注释实现类（或该类中的方法或两者），而不是注释该类所实现的接口（如果有）。AspectJ 遵循 Java 的规则，即不继承接口上的注释。</p>
<p>类上的 <code>@Transactional</code> 批注指定用于执行该类中任何公共操作的默认事务语义。</p>
<p>类中方法上的 <code>@Transactional</code> 注释将覆盖类注释（如果存在）给出的默认事务语义。可以注释任何可见性的方法，包括私有方法。直接注释非公共方法是执行此类方法而获得事务划分的唯一方法。</p>
<blockquote>
<p>从 Spring Framework 4.2 开始，spring-aspects 提供了一个相似的切面，为标准 <code>javax.transaction.Transactional</code> 注释提供了完全相同的功能。检查 <code>JtaAnnotationTransactionAspect</code> 了解更多详细信息。</p>
</blockquote>
<p>对于希望使用 Spring 配置和事务管理支持但又不想（或不能）使用注释的 AspectJ 程序员，<code>spring-aspects.jar</code> 也包含抽象切面，您可以扩展它们以提供自己的切入点定义。有关更多信息，请参见 <code>AbstractBeanConfigurerAspect</code> 和 <code>AbstractTransactionAspect</code> 切面的资源。作为示例，以下摘录显示了如何编写切面来使用与完全限定的类名匹配的原型 bean 定义来配置域模型中定义的对象的所有实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DomainObjectConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setBeanWiringInfoResolver(<span class="keyword">new</span> ClassNameBeanWiringInfoResolver());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the creation of a new bean (any object in the domain model)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> pointcut <span class="title">beanCreation</span><span class="params">(Object beanInstance)</span> :</span></span><br><span class="line"><span class="function">        <span class="title">initialization</span><span class="params">(new(..)</span>) &amp;&amp;</span></span><br><span class="line"><span class="function">        SystemArchitecture.<span class="title">inDomainModel</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">this</span><span class="params">(beanInstance)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Spring-IoC-配置-AspectJ-Aspects"><a href="#使用-Spring-IoC-配置-AspectJ-Aspects" class="headerlink" title="使用 Spring IoC 配置 AspectJ Aspects"></a>使用 Spring IoC 配置 AspectJ Aspects</h3><p>当您将 AspectJ 切面与 Spring 应用程序一起使用时，既自然又希望能够使用 Spring 配置这些切面。 AspectJ 运行时本身负责切面的创建，并且通过 Spring 配置 AspectJ 创建的切面的方法取决于切面所使用的 AspectJ 实例化模型（per-xxx 子句）。</p>
<p>AspectJ 的大多数切面都是单例切面。这些切面的配置很容易。您可以创建一个 bean 定义，该 bean 定义按常规引用切面类型，并包括 factory-method =“ aspectOf” bean 属性。这样可以确保 Spring 通过向 AspectJ 索要长宽比实例，而不是尝试自己创建实例来获得长宽比实例。以下示例显示如何使用 factory-method =“ aspectOf”属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"profiler"</span> <span class="attr">class</span>=<span class="string">"com.xyz.profiler.Profiler"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">factory-method</span>=<span class="string">"aspectOf"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"profilingStrategy"</span> <span class="attr">ref</span>=<span class="string">"jamonProfilingStrategy"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意 factory-method =“ aspectOf”属性<br>非单一切面很难配置。但是，可以通过创建原型 Bean 定义并使用 spring-aspects.jar 中的@Configurable 支持来实现，一旦它们由 AspectJ 运行时创建了 Bean，就可以配置切面实例。</p>
<p>如果您有一些要与 AspectJ 编织的@AspectJ 切面（例如，对域模型类型使用加载时编织）以及要与 Spring AOP 一起使用的其他@AspectJ 切面，那么这些切面都已在 Spring 中配置，您需要告诉 Spring AOP @AspectJ 自动代理支持，应使用配置中定义的@AspectJ 切面的确切子集进行自动代理。您可以通过在<code>&lt;aop：aspectj-autoproxy /&gt;</code>声明中使用一个或多个<code>&lt;include /&gt;</code>元素来做到这一点。每个<code>&lt;include /&gt;</code>元素都指定一个名称模式，只有名称与至少一个模式匹配的 bean 才可用于 Spring AOP 自动代理配置。以下示例显示了如何使用<code>&lt;include /&gt;</code>元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:include</span> <span class="attr">name</span>=<span class="string">"thisBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:include</span> <span class="attr">name</span>=<span class="string">"thatBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要被 <code>&lt;aop：aspectj-autoproxy/&gt;</code> 元素的名称所迷惑。使用它可以创建 Spring AOP 代理。 这里使用的是 @AspectJ 样式的切面声明，但不涉及 AspectJ 运行时。</p>
</blockquote>
<h3 id="在-Spring-Framework-中使用-AspectJ-进行加载时编织"><a href="#在-Spring-Framework-中使用-AspectJ-进行加载时编织" class="headerlink" title="在 Spring Framework 中使用 AspectJ 进行加载时编织"></a>在 Spring Framework 中使用 AspectJ 进行加载时编织</h3><p>AspectJ 切面加载到应用程序的类文件中时将其编织到 Java 虚拟机（JVM）中的过程。本节的重点是在 Spring 框架的特定上下文中配置和使用 LTW。本节不是 LTW 的一般介绍。有关 LTW 的详细信息以及仅使用 AspectJ 配置 LTW（完全不涉及 Spring）的详细信息，请参阅《AspectJ 开发环境指南》的 LTW 部分。</p>
<p>Spring 框架为 AspectJ LTW 带来的价值在于能够对编织过程进行更精细的控制。 “Vanilla” AspectJ LTW 通过使用 Java（5+）代理来实现，该代理在启动 JVM 时通过指定 VM 参数来打开。因此，它是一个 JVM 范围的设置，在某些情况下可能很好，但通常有点过于粗糙。启用 S​​pring 的 LTW 可让您基于每个 ClassLoader 开启 LTW，它的粒度更细，并且在“单个 JVM-多个应用程序”环境（例如在典型的应用程序服务器中发现）中更有意义。环境）。</p>
<p>此外，在某些环境中，此支持无需在添加<code>-javaagent:path/to/aspectjweaver.jar</code> 或（如本节稍后所述）<code>-javaagent:path/to/spring-instrument.jar</code> 所需的应用程序服务器的启动脚本进行任何修改的情况下即可进行加载时编织。开发人员将应用程序上下文配置为启用加载时编织，而不是依赖通常负责部署配置（例如启动脚本）的管理员。</p>
<p>现在，销售工作已经结束，让我们首先浏览一个使用 Spring 的 AspectJ LTW 的快速示例，然后详细介绍示例中引入的元素。有关完整的示例，请参见 Petclinic 示例应用程序。</p>
<p>此处过于深入，暂时跳过。</p>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p>可以在 <a href="https://www.eclipse.org/aspectj" target="_blank" rel="noopener">AspectJ 网站</a>上找到有关 AspectJ 的更多信息。</p>
<p>Eclipse AspectJ，作者：Adrian Colyer 等。（Addison-Wesley，2005 年）为 AspectJ 语言提供了全面的介绍和参考。</p>
<p>强烈推荐 Ramnivas Laddad 撰写的《AspectJ in Action》第二版（Manning，2009 年）。本书的重点是 AspectJ，但是（在一定程度上）探讨了许多通用的 AOP 主题。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring进阶 - spring 表达式语言（SpEL）]]></title>
      <url>https://HaleLu.github.io/2020/06/spring-5/</url>
      <content type="html"><![CDATA[<p>书接<a href="https://halelu.github.io/2020/05/spring-4/">上文</a></p>
<p>接下来到 Spring framework core 的第四大块 —— spring 表达式语言（SpEL）</p>
<a id="more"></a>

<h1 id="spring-表达式语言（SpEL）"><a href="#spring-表达式语言（SpEL）" class="headerlink" title="spring 表达式语言（SpEL）"></a>spring 表达式语言（SpEL）</h1><p>Spring 表达式语言（简称“SpEL”）是一种功能强大的表达式语言，支持在运行时查询和操作对象图。语言语法与 Unified EL 相似，但提供了其他功能，最著名的是方法调用和基本的字符串模板功能。</p>
<p>尽管还有其他几种 Java 表达式语言可用-OGNL，MVEL 和 JBoss EL，仅举几例-Spring 表达式语言的创建是为了向 Spring 社区提供一种受良好支持的表达式语言，该语言可用于以下版本中的所有产品春季投资组合。它的语言功能受 Spring 产品组合中项目的要求驱动，包括 Spring Tools for Eclipse 中代码完成支持的工具要求。也就是说，SpEL 基于与技术无关的 API，如果需要，可以将其他表达语言实现集成在一起。</p>
<p>虽然 SpEL 是 Spring 产品组合中表达评估的基础，但它并不直接与 Spring 绑定，可以独立使用。为了自成一体，本章中的许多示例都将 SpEL 用作独立的表达语言。这需要创建一些自举基础结构类，例如解析器。 Spring 的大多数用户不需要处理这种基础结构，而只能编写表达式字符串进行评估。这种典型用法的一个示例是将 SpEL 集成到创建 XML 或基于注释的 Bean 定义中，如 Expression 支持中定义的 Bean 定义所示。</p>
<p>本章介绍了表达语言，其 API 和语言语法的功能。在许多地方，Inventor 和 Society 类都用作表达评估的目标对象。这些类声明和用于填充它们的数据在本章末尾列出。</p>
<p>表达式语言支持以下功能：</p>
<ul>
<li>文字表达</li>
<li>布尔运算符和关系运算符</li>
<li>正则表达式</li>
<li>类表达式</li>
<li>访问属性，数组，列表和映射</li>
<li>方法调用</li>
<li>关系运算符</li>
<li>分配</li>
<li>调用构造函数</li>
<li>Bean 引用</li>
<li>数组构造</li>
<li>内联列表</li>
<li>内联映射</li>
<li>三元运算符</li>
<li>变数</li>
<li>用户定义的功能</li>
<li>集合投影</li>
<li>集合选择</li>
<li>模板表达式</li>
</ul>
<h2 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h2><p>本节介绍 SpEL 接口及其表达语言的简单用法。 完整的语言参考可以在<a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#expressions-language-ref" target="_blank" rel="noopener">“语言参考”</a>中找到。</p>
<p>以下代码介绍了 SpEL API，用于计算文字字符串表达式 <code>Hello World</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"'Hello World'"</span>);</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>message 变量的值为“ Hello World”。</p>
<p>您最可能使用的 SpEL 类和接口位于 <code>org.springframework.expression</code> 包及其子包中，例如 <code>spel.support</code>。</p>
<p><code>ExpressionParser</code> 接口负责解析表达式字符串。在前面的示例中，表达式字符串是由周围的单引号表示的字符串文字。<code>Expression</code> 接口负责评估先前定义的表达式字符串。分别调用 parser.<code>parseExpression</code> 和 <code>exp.getValue</code> 时，可以引发两个异常 <code>ParseException</code> 和 <code>EvaluationException</code>。</p>
<p>SpEL 支持多种功能，例如调用方法，访问属性和调用构造函数。</p>
<p>在以下方法调用示例中，我们在字符串文字上调用 <code>concat</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"'Hello World'.concat('!')"</span>);</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>message == ‘Hello World!’</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokes 'getBytes()'</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"'Hello World'.bytes"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = (<span class="keyword">byte</span>[]) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>SpEL 还通过使用标准的点符号（例如 prop1.prop2.prop3）以及相应的属性值设置来支持嵌套属性。 也可以访问公共字段。</p>
<p>下面的示例演示如何使用点表示法获取文字的长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokes 'getBytes().length'</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"'Hello World'.bytes.length"</span>);</span><br><span class="line"><span class="keyword">int</span> length = (Integer) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>可以调用 String 的构造函数，而不是使用字符串文字，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"new String('hello world').toUpperCase()"</span>);</span><br><span class="line">String message = exp.getValue(String.class);</span><br></pre></td></tr></table></figure>

<p>上例会从文字构造一个新的 String 并将其变为大写。</p>
<p>注意使用通用方法：<code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code>。使用此方法无需将表达式的值强制转换为所需的结果类型。 如果该值不能转换为 <code>T</code> 类型或无法使用已注册的类型转换器转换，则将引发 <code>EvaluationException</code>。</p>
<p>SpEL 的更常见用法是提供一个针对特定对象实例（称为根对象）进行评估的表达式字符串。 以下示例显示如何从 <code>Inventor</code> 类的实例检索 <code>name</code> 属性或如何创建布尔条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and set a calendar</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The constructor arguments are name, birthday, and nationality.</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, c.getTime(), <span class="string">"Serbian"</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"name"</span>); <span class="comment">// Parse name as an expression</span></span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br><span class="line"><span class="comment">// name == "Nikola Tesla"</span></span><br><span class="line"></span><br><span class="line">exp = parser.parseExpression(<span class="string">"name == 'Nikola Tesla'"</span>);</span><br><span class="line"><span class="keyword">boolean</span> result = exp.getValue(tesla, Boolean.class);</span><br><span class="line"><span class="comment">// result == true</span></span><br></pre></td></tr></table></figure>

<h3 id="理解-EvaluationContext"><a href="#理解-EvaluationContext" class="headerlink" title="理解 EvaluationContext"></a>理解 <code>EvaluationContext</code></h3><p>在评估表达式以解析属性，方法或字段并帮助执行类型转换时，使用 <code>EvaluationContext</code> 接口。 Spring 提供了两种实现。</p>
<ul>
<li><code>SimpleEvaluationContext</code>：针对不需要全部 SpEL 语言语法范围且应受到有意义限制的表达式类别，公开了 SpEL 基本语言功能和配置选项的子集。示例包括但不限于数据绑定表达式和基于属性的过滤器。</li>
<li><code>StandardEvaluationContext</code>：公开了全套 SpEL 语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</li>
</ul>
<p><code>SimpleEvaluationContext</code> 设计为仅支持 SpEL 语言语法的子集。它不包括 Java 类型引用，构造函数和 Bean 引用。它还要求您明确选择对表达式中的属性和方法的支持级别。默认情况下，<code>create()</code> 静态工厂方法仅启用对属性的读取访问。您还可以获取构建器来配置所需的确切支持级别，并针对以下一种或某种组合：</p>
<ul>
<li>仅自定义 <code>PropertyAccessor</code>（无反射）</li>
<li>只读访问的数据绑定属性</li>
<li>读写的数据绑定属性</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>默认情况下，SpEL 使用 Spring 核心中可用的转换服务（<code>org.springframework.core.convert.ConversionService</code>）。此转换服务附带许多内置转换器，用于常见转换，但也可以完全扩展，以便您可以在类型之间添加自定义转换。此外，它是泛型感知的。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试进行转换以维护遇到的任何对象的类型正确性。</p>
<p>实际上这是什么意思？假设使用 <code>setValue()</code> 进行赋值来设置 <code>List</code> 属性。该属性的类型实际上是 <code>List&lt;Boolean&gt;</code>。 SpEL 认识到列表中的元素在放入列表之前需要转换为布尔值。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; booleanList = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">simple.booleanList.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// "false" is passed in here as a String. SpEL and the conversion service</span></span><br><span class="line"><span class="comment">// will recognize that it needs to be a Boolean and convert it accordingly.</span></span><br><span class="line">parser.parseExpression(<span class="string">"booleanList[0]"</span>).setValue(context, simple, <span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b is false</span></span><br><span class="line">Boolean b = simple.booleanList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="解析器配置"><a href="#解析器配置" class="headerlink" title="解析器配置"></a>解析器配置</h3><p>可以使用解析器配置对象（<code>org.springframework.expression.spel.SpelParserConfiguration</code>）配置 SpEL 表达式解析器。 配置对象控制某些表达式组件的行为。 例如，如果您索引到数组或集合中并且指定索引处的元素为 <code>null</code>，则可以自动创建该元素。 当使用由属性引用链组成的表达式时，这很有用。 如果您索引到数组或列表中并指定了超出数组或列表当前大小末尾的索引，则可以自动增长数组或列表以容纳该索引。下面的示例演示如何自动增加列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Turn on:</span></span><br><span class="line"><span class="comment">// - auto null reference initialization</span></span><br><span class="line"><span class="comment">// - auto collection growing</span></span><br><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">"list[3]"</span>);</span><br><span class="line"></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">Object o = expression.getValue(demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.list will now be a real collection of 4 entries</span></span><br><span class="line"><span class="comment">// Each entry is a new empty String</span></span><br></pre></td></tr></table></figure>

<h3 id="SpEL-编译"><a href="#SpEL-编译" class="headerlink" title="SpEL 编译"></a>SpEL 编译</h3><p>Spring Framework 4.1 包含一个基本的表达式编译器。通常对表达式进行解释，这样可以在评估过程中提供很大的动态灵活性，但不能提供最佳性能。对于偶尔使用表达式，这很好，但是，当与其他组件（例如 Spring Integration）一起使用时，性能可能非常重要，并且不需要动态性。</p>
<p>SpEL 编译器旨在满足这一需求。在评估过程中，编译器会生成一个 Java 类，该类体现了运行时的表达式行为，并使用该类来实现更快的表达式评估。由于缺少在表达式周围输入内容的信息，因此编译器在执行编译时会使用在表达式的解释式求值过程中收集的信息。例如，它不仅仅从表达式中就知道属性引用的类型，而是在第一次解释求值时就知道它是什么。当然，如果各种表达元素的类型随时间变化，则基于此类派生信息进行编译会在以后引起麻烦。因此，编译最适合类型信息在重复求值时不会改变的表达式。</p>
<p>考虑以下基本表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someArray[0].someProperty.someOtherProperty &lt; 0.1</span><br></pre></td></tr></table></figure>

<p>由于前面的表达式涉及数组访问，一些属性取消引用和数字运算，因此性能提升可能非常明显。在一个示例中，进行了 50000 次迭代的微基准测试，使用解释器评估需要 75 毫秒，而使用表达式的编译版本仅需要 3 毫秒。</p>
<h4 id="编译器配置"><a href="#编译器配置" class="headerlink" title="编译器配置"></a>编译器配置</h4><p>两种不同的方式之一来打开它。当 SpEL 用法嵌入到另一个组件中时，可以使用解析器配置过程（前面讨论过）或使用系统属性来打开它。本节讨论这两个选项。</p>
<p>编译器可以在 <code>org.springframework.expression.spel.SpelCompilerMode</code> 枚举中捕获的三种模式之一进行操作。模式如下：</p>
<ul>
<li><code>OFF</code>（默认）：编译器已关闭。</li>
<li><code>IMMEDIATE</code>：在立即模式下，将尽快编译表达式。通常是在第一次解释评估之后。如果编译的表达式失败（通常是由于类型更改，如前所述），则表达式求值的调用者将收到异常。</li>
<li><code>MIXED</code>：在混合模式下，表达式会随着时间静默在解释模式和编译模式之间切换。经过一定数量的解释运行后，它们会切换到编译形式，如果编译形式出了问题（例如，如前面所述的类型更改），则表达式会自动再次切换回解释形式。稍后，它可能会生成另一个已编译的表单并切换到该表单。基本上，用户进入即时模式的异常是在内部处理的。</li>
</ul>
<p>存在 <code>IMMEDIATE</code> 模式是因为 <code>MIXED</code> 模式可能会导致具有副作用的表达式出现问题。如果已编译的表达式在部分成功后就崩溃了，则它可能已经完成了影响系统状态的操作。如果发生这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能运行了两次。</p>
<p>选择模式后，使用 <code>SpelParserConfiguration</code> 配置解析器。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,</span><br><span class="line">    <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expr = parser.parseExpression(<span class="string">"payload"</span>);</span><br><span class="line"></span><br><span class="line">MyMessage message = <span class="keyword">new</span> MyMessage();</span><br><span class="line"></span><br><span class="line">Object payload = expr.getValue(message);</span><br></pre></td></tr></table></figure>

<p>当指定编译器模式时，还可以指定一个类加载器（允许传递 null）。编译的表达式在提供的任何子类加载器中定义。重要的是要确保，如果指定了类加载器，则它可以查看表达式评估过程中涉及的所有类型。如果未指定类加载器，则使用默认的类加载器（通常是在表达式求值期间运行的线程的上下文类加载器）。</p>
<p>第二种配置编译器的方法是将 SpEL 嵌入到其他组件中，并且可能无法通过配置对象进行配置。 在这些情况下，可以使用系统属性。 您可以将 <code>spring.expression.compiler.mode</code> 属性设置为 <code>SpelCompilerMode</code> 枚举值之一（<code>off</code>、<code>immediate</code> 或 <code>mixed</code>）。</p>
<h4 id="编译器限制"><a href="#编译器限制" class="headerlink" title="编译器限制"></a>编译器限制</h4><p>从 Spring Framework 4.1 开始，已经有了基本的编译框架。但是，该框架尚不支持编译每种表达式。最初的重点是可能在性能关键型上下文中使用的通用表达式。目前无法编译以下类型的表达式：</p>
<ul>
<li>涉及赋值的表达</li>
<li>表达式依赖转换服务</li>
<li>使用自定义解析器或访问器的表达式</li>
<li>使用选择或投影的表达式</li>
</ul>
<p>将来会编译更多类型的表达。</p>
<h2 id="Bean-定义中的表达式"><a href="#Bean-定义中的表达式" class="headerlink" title="Bean 定义中的表达式"></a>Bean 定义中的表达式</h2><p>您可以将 SpEL 表达式与基于 XML 或基于注释的配置元数据一起使用，以定义 <code>BeanDefinition</code> 实例。 在这两种情况下，用于定义表达式的语法都采用 <code>#{ &lt;expression string&gt; }</code> 的形式。</p>
<h3 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h3><p>可以使用表达式来设置属性或构造函数参数值，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"numberGuess"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.NumberGuess"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"randomNumber"</span> <span class="attr">value</span>=<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>应用程序上下文中的所有 bean 都可以使用其公共 bean 名称作为预定义变量使用。 这包括标准上下文 Bean，例如用于访问运行时环境的 <code>environment</code>（类型为 <code>org.springframework.core.env.Environment</code>）以及 <code>systemProperties</code> 和 <code>systemEnvironment</code>（类型为 <code>Map&lt;String，Object&gt;</code>）。</p>
<p>下面的示例显示了如何对 <code>systemProperties</code> bean 作为 SpEL 变量的访问：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taxCalculator"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.TaxCalculator"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultLocale"</span> <span class="attr">value</span>=<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，此处不必在预定义变量前加上 <code>＃</code> 符号。</p>
<p>您还可以按名称引用其他 bean 属性，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"numberGuess"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.NumberGuess"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"randomNumber"</span> <span class="attr">value</span>=<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shapeGuess"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.ShapeGuess"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialShapeSeed"</span> <span class="attr">value</span>=<span class="string">"#&#123; numberGuess.randomNumber &#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>若要指定默认值，可以将 <code>@Value</code> 批注放置在字段，方法以及方法或构造函数参数上。</p>
<p>下面的示例设置字段变量的默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了等效的但使用属性设置器方法的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动装配的方法和构造函数也可以使用 @Value 批注，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line">    <span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(MovieFinder movieFinder,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Value(<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>)</span> String defaultLocale) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">        <span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Value(<span class="string">"#&#123;systemProperties['user.country']&#125;"</span>)</span> String defaultLocale) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">        <span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="语言参考"><a href="#语言参考" class="headerlink" title="语言参考"></a>语言参考</h2><p>本节描述了 Spring Expression Language 的工作方式。 它涵盖以下主题：</p>
<ul>
<li>文字表达式</li>
<li>属性，数组，列表，映射和索引器</li>
<li>内联列表</li>
<li>内联映射</li>
<li>数组构造</li>
<li>方法</li>
<li>运算符</li>
<li>类型</li>
<li>构造器</li>
<li>变数</li>
<li>函数</li>
<li>Bean 引用</li>
<li>三元运算符（If-Then-Else）</li>
<li>Elvis 运算符</li>
<li>安全导航运算符</li>
</ul>
<h3 id="文字表达式"><a href="#文字表达式" class="headerlink" title="文字表达式"></a>文字表达式</h3><p>支持的文字表达式的类型为字符串，数值（int，实数，十六进制），布尔值和 null。 字符串由单引号引起来。 要将单引号本身放在字符串中，请使用两个单引号字符。</p>
<p>以下清单显示了文字的简单用法。 通常，它们不是像这样孤立地使用，而是作为更复杂的表达式的一部分使用-例如，在逻辑比较运算符的一侧使用文字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// evals to "Hello World"</span></span><br><span class="line">String helloWorld = (String) parser.parseExpression(<span class="string">"'Hello World'"</span>).getValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> avogadrosNumber = (Double) parser.parseExpression(<span class="string">"6.0221415E+23"</span>).getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// evals to 2147483647</span></span><br><span class="line"><span class="keyword">int</span> maxValue = (Integer) parser.parseExpression(<span class="string">"0x7FFFFFFF"</span>).getValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> trueValue = (Boolean) parser.parseExpression(<span class="string">"true"</span>).getValue();</span><br><span class="line"></span><br><span class="line">Object nullValue = parser.parseExpression(<span class="string">"null"</span>).getValue();</span><br></pre></td></tr></table></figure>

<p>数字支持使用负号，指数符号和小数点。 默认情况下，使用 Double.parseDouble()解析实数。</p>
<h3 id="属性，数组，列表，映射和索引器"><a href="#属性，数组，列表，映射和索引器" class="headerlink" title="属性，数组，列表，映射和索引器"></a>属性，数组，列表，映射和索引器</h3><p>使用属性引用进行导航很容易。为此，请使用句点来指示嵌套的属性值。<code>Inventor</code> 类的实例 <code>pupin</code> 和 <code>tesla</code> 填充有 <a href="#示例中使用的类">示例中使用的类</a> 中列出的数据。要向下导航并获取特斯拉(Tesla)的出生年份和普平(Pupin)的出生城市，我们使用以下表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evals to 1856</span></span><br><span class="line"><span class="keyword">int</span> year = (Integer) parser.parseExpression(<span class="string">"Birthdate.Year + 1900"</span>).getValue(context);</span><br><span class="line"></span><br><span class="line">String city = (String) parser.parseExpression(<span class="string">"placeOfBirth.City"</span>).getValue(context);</span><br></pre></td></tr></table></figure>

<p>属性名称的首字母允许不区分大小写。 数组和列表的内容通过使用方括号表示法获得，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inventions Array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to "Induction motor"</span></span><br><span class="line">String invention = parser.parseExpression(<span class="string">"inventions[3]"</span>).getValue(</span><br><span class="line">        context, tesla, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Members List</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to "Nikola Tesla"</span></span><br><span class="line">String name = parser.parseExpression(<span class="string">"Members[0].Name"</span>).getValue(</span><br><span class="line">        context, ieee, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List and Array navigation</span></span><br><span class="line"><span class="comment">// evaluates to "Wireless communication"</span></span><br><span class="line">String invention = parser.parseExpression(<span class="string">"Members[0].Inventions[6]"</span>).getValue(</span><br><span class="line">        context, ieee, String.class);</span><br></pre></td></tr></table></figure>

<p>通过在方括号内指定文字键值可以获取映射的内容。 在下面的示例中，由于 Officer 映射的键是字符串，因此我们可以指定字符串文字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Officer's Dictionary</span></span><br><span class="line"></span><br><span class="line">Inventor pupin = parser.parseExpression(<span class="string">"Officers['president']"</span>).getValue(</span><br><span class="line">        societyContext, Inventor.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to "Idvor"</span></span><br><span class="line">String city = parser.parseExpression(<span class="string">"Officers['president'].PlaceOfBirth.City"</span>).getValue(</span><br><span class="line">        societyContext, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setting values</span></span><br><span class="line">parser.parseExpression(<span class="string">"Officers['advisors'][0].PlaceOfBirth.Country"</span>).setValue(</span><br><span class="line">        societyContext, <span class="string">"Croatia"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="内联列表"><a href="#内联列表" class="headerlink" title="内联列表"></a>内联列表</h3><p>您可以使用 <code>{}</code> 表示法在表达式中直接表达列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evaluates to a Java list containing the four numbers</span></span><br><span class="line">List numbers = (List) parser.parseExpression(<span class="string">"&#123;1,2,3,4&#125;"</span>).getValue(context);</span><br><span class="line"></span><br><span class="line">List listOfLists = (List) parser.parseExpression(<span class="string">"&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;"</span>).getValue(context);</span><br></pre></td></tr></table></figure>

<p><code>{}</code> 本身表示一个空列表。出于性能原因，如果列表本身完全由固定文字组成，则会创建一个常量列表来表示该表达式（而不是在每次求值时都建立一个新列表）。</p>
<h3 id="内联映射"><a href="#内联映射" class="headerlink" title="内联映射"></a>内联映射</h3><p>您也可以使用 <code>{key:value}</code> 表示法在表达式中直接表达映射。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evaluates to a Java map containing the two entries</span></span><br><span class="line">Map inventorInfo = (Map) parser.parseExpression(<span class="string">"&#123;name:'Nikola',dob:'10-July-1856'&#125;"</span>).getValue(context);</span><br><span class="line"></span><br><span class="line">Map mapOfMaps = (Map) parser.parseExpression(<span class="string">"&#123;name:&#123;first:'Nikola',last:'Tesla'&#125;,dob:&#123;day:10,month:'July',year:1856&#125;&#125;"</span>).getValue(context);</span><br></pre></td></tr></table></figure>

<p><code>{:}</code> 本身意味着一个空的映射。出于性能原因，如果映射图本身由固定的文字或其他嵌套的常量结构（列表或映射）组成，则会创建一个常量映射来表示该表达式（而不是在每次求值时都构建一个新的映射）。映射键的引号是可选的。上面的示例使用的是不带引号的键。</p>
<h3 id="构建数组"><a href="#构建数组" class="headerlink" title="构建数组"></a>构建数组</h3><p>您可以使用熟悉的 Java 语法来构建数组，可以选择提供一个初始化程序，以在构造时填充该数组。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers1 = (<span class="keyword">int</span>[]) parser.parseExpression(<span class="string">"new int[4]"</span>).getValue(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array with initializer</span></span><br><span class="line"><span class="keyword">int</span>[] numbers2 = (<span class="keyword">int</span>[]) parser.parseExpression(<span class="string">"new int[]&#123;1,2,3&#125;"</span>).getValue(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multi dimensional array</span></span><br><span class="line"><span class="keyword">int</span>[][] numbers3 = (<span class="keyword">int</span>[][]) parser.parseExpression(<span class="string">"new int[4][5]"</span>).getValue(context);</span><br></pre></td></tr></table></figure>

<p>构造多维数组时，当前无法提供初始化程序。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>您可以使用典型的 Java 编程语法来调用方法。 您还可以在文字上调用方法。 还支持变量参数。 下面的示例演示如何调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string literal, evaluates to "bc"</span></span><br><span class="line">String bc = parser.parseExpression(<span class="string">"'abc'.substring(1, 3)"</span>).getValue(String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to true</span></span><br><span class="line"><span class="keyword">boolean</span> isMember = parser.parseExpression(<span class="string">"isMember('Mihajlo Pupin')"</span>).getValue(</span><br><span class="line">        societyContext, Boolean.class);</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Spring 表达式语言支持以下几种运算符：</p>
<ul>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>数学运算符</li>
<li>赋值运算符</li>
</ul>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>使用标准运算符表示法支持关系运算符（等于，不等于，小于，小于或等于，大于和大于或等于）。 以下清单显示了一些运算符示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evaluates to true</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"2 == 2"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to false</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"2 &lt; -5.0"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to true</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"'black' &lt; 'block'"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对 <code>null</code> 的大于和小于比较遵循一个简单的规则：<code>null</code> 被视为无（不是零）。结果，任何其他值始终大于 <code>null</code>（<code>X &gt; null</code> 始终为 <code>true</code>），并且其他任何值都不小于零（<code>X &lt; null</code> 始终为 <code>false</code>）。</p>
<p>如果您需要数字比较，请避免使用基于数字的 <code>null</code> 比较，而建议使用零进行比较（例如，<code>X &gt; 0</code> 或 <code>X &lt; 0</code>）。</p>
</blockquote>
<p>除了标准的关系运算符外，SpEL 还支持 <code>instanceof</code> 和基于正则表达式的匹配运算符。 以下清单显示了两个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evaluates to false</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(</span><br><span class="line">        <span class="string">"'xyz' instanceof T(Integer)"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to true</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(</span><br><span class="line">        <span class="string">"'5.00' matches '^-?\\d+(\\.\\d&#123;2&#125;)?$'"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//evaluates to false</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(</span><br><span class="line">        <span class="string">"'5.0067' matches '^-?\\d+(\\.\\d&#123;2&#125;)?$'"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意原始类型，因为它们会立即被包装为包装器类型，因此，按预期方式，<code>1 instanceof T(int)</code> 的计算结果为 <code>false</code>，而 <code>1 instanceof T(Integer)</code> 的计算结果为 <code>true</code>。</p>
</blockquote>
<p>每个符号运算符也可以指定为纯字母等效项。 这样可以避免使用的符号对于嵌入表达式的文档类型具有特殊含义的问题（例如在 XML 文档中）。等效的文字是：</p>
<ul>
<li>lt (&lt;)</li>
<li>gt (&gt;)</li>
<li>le (&lt;=)</li>
<li>ge (&gt;=)</li>
<li>eq (==)</li>
<li>ne (!=)</li>
<li>div (/)</li>
<li>mod (%)</li>
<li>not (!)</li>
</ul>
<p>所有的文本运算符都不区分大小写。</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>SpEL 支持以下逻辑运算符：</p>
<ul>
<li>与（<code>&amp;&amp;</code>）</li>
<li>或（<code>||</code>）</li>
<li>非（<code>!</code>）</li>
</ul>
<p>下面的示例演示如何使用逻辑运算符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -- AND --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to false</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"true and false"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to true</span></span><br><span class="line">String expression = <span class="string">"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')"</span>;</span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- OR --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to true</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"true or false"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to true</span></span><br><span class="line">String expression = <span class="string">"isMember('Nikola Tesla') or isMember('Albert Einstein')"</span>;</span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- NOT --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to false</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"!true"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- AND and NOT --</span></span><br><span class="line">String expression = <span class="string">"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')"</span>;</span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></td></tr></table></figure>

<h4 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h4><p>您可以在数字和字符串上使用加法运算符。 您只能对数字使用减法，乘法和除法运算符。 您还可以使用模数（％）和指数幂（^）运算符。 强制执行标准运算符优先级。 以下示例显示了正在使用的数学运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Addition</span></span><br><span class="line"><span class="keyword">int</span> two = parser.parseExpression(<span class="string">"1 + 1"</span>).getValue(Integer.class);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">String testString = parser.parseExpression(</span><br><span class="line">        <span class="string">"'test' + ' ' + 'string'"</span>).getValue(String.class);  <span class="comment">// 'test string'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Subtraction</span></span><br><span class="line"><span class="keyword">int</span> four = parser.parseExpression(<span class="string">"1 - -3"</span>).getValue(Integer.class);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = parser.parseExpression(<span class="string">"1000.00 - 1e4"</span>).getValue(Double.class);  <span class="comment">// -9000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplication</span></span><br><span class="line"><span class="keyword">int</span> six = parser.parseExpression(<span class="string">"-2 * -3"</span>).getValue(Integer.class);  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> twentyFour = parser.parseExpression(<span class="string">"2.0 * 3e0 * 4"</span>).getValue(Double.class);  <span class="comment">// 24.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Division</span></span><br><span class="line"><span class="keyword">int</span> minusTwo = parser.parseExpression(<span class="string">"6 / -3"</span>).getValue(Integer.class);  <span class="comment">// -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> one = parser.parseExpression(<span class="string">"8.0 / 4e0 / 2"</span>).getValue(Double.class);  <span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Modulus</span></span><br><span class="line"><span class="keyword">int</span> three = parser.parseExpression(<span class="string">"7 % 4"</span>).getValue(Integer.class);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> one = parser.parseExpression(<span class="string">"8 / 5 % 2"</span>).getValue(Integer.class);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operator precedence</span></span><br><span class="line"><span class="keyword">int</span> minusTwentyOne = parser.parseExpression(<span class="string">"1+2-3*8"</span>).getValue(Integer.class);  <span class="comment">// -21</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>要设置属性，请使用赋值运算符（=）。 这通常在对 <code>setValue</code> 的调用内完成，但也可以在对 <code>getValue</code> 的调用内完成。 下面的清单显示了使用赋值运算符的两种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Inventor inventor = <span class="keyword">new</span> Inventor();</span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();</span><br><span class="line"></span><br><span class="line">parser.parseExpression(<span class="string">"Name"</span>).setValue(context, inventor, <span class="string">"Aleksandar Seovic"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// alternatively</span></span><br><span class="line">String aleks = parser.parseExpression(</span><br><span class="line">        <span class="string">"Name = 'Aleksandar Seovic'"</span>).getValue(context, inventor, String.class);</span><br></pre></td></tr></table></figure>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>您可以使用特殊的 <code>T</code> 运算符来指定 <code>java.lang.Class</code>（类型）的实例。静态方法也可以通过使用此运算符来调用。<code>StandardEvaluationContext</code> 使用 <code>TypeLocator</code> 查找类型，而 <code>StandardTypeLocator</code>（可以替换）是在了解 <code>java.lang</code> 包的情况下构建的。 这意味着对 <code>Java.lang</code> 中的类型的 <code>T()</code> 引用不需要完全限定，但是所有其他类型引用都必须是完全限定的。下面的示例演示如何使用 <code>T</code> 运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class dateClass = parser.parseExpression(<span class="string">"T(java.util.Date)"</span>).getValue(Class.class);</span><br><span class="line"></span><br><span class="line">Class stringClass = parser.parseExpression(<span class="string">"T(String)"</span>).getValue(Class.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(</span><br><span class="line">        <span class="string">"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR"</span>)</span><br><span class="line">        .getValue(Boolean.class);</span><br></pre></td></tr></table></figure>

<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>您可以使用 <code>new</code> 运算符来调用构造函数。 除基本类型（<code>int</code>，<code>float</code> 等）和 <code>String</code> 以外的所有其他类都应使用完全限定的类名。 下面的示例演示如何使用 new 运算符调用构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Inventor einstein = p.parseExpression(</span><br><span class="line">        <span class="string">"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')"</span>)</span><br><span class="line">        .getValue(Inventor.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//create new inventor instance within add method of List</span></span><br><span class="line">p.parseExpression(</span><br><span class="line">        <span class="string">"Members.add(new org.spring.samples.spel.inventor.Inventor(</span></span><br><span class="line"><span class="string">            'Albert Einstein', 'German'))"</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>您可以使用 <code>#variableName</code> 语法在表达式中引用变量。 通过在 <code>EvaluationContext</code> 实现上使用 <code>setVariable</code> 方法设置变量。</p>
<blockquote>
<p>有效的变量名称必须由以下一个或多个受支持的字符组成。</p>
<ul>
<li>字母：<code>A</code> 到 <code>Z</code> 和 <code>a</code> 到 <code>z</code></li>
<li>数字：<code>0</code> 到 <code>9</code></li>
<li>下划线：<code>_</code></li>
<li>美元符号：<code>$</code></li>
</ul>
</blockquote>
<p>以下示例显示了如何使用变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, <span class="string">"Serbian"</span>);</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();</span><br><span class="line">context.setVariable(<span class="string">"newName"</span>, <span class="string">"Mike Tesla"</span>);</span><br><span class="line"></span><br><span class="line">parser.parseExpression(<span class="string">"Name = #newName"</span>).getValue(context, tesla);</span><br><span class="line">System.out.println(tesla.getName())  <span class="comment">// "Mike Tesla"</span></span><br></pre></td></tr></table></figure>

<h4 id="this-和-root-变量"><a href="#this-和-root-变量" class="headerlink" title="#this 和 #root 变量"></a><code>#this</code> 和 <code>#root</code> 变量</h4><p><code>#this</code> 变量始终是定义的，并且引用当前的评估对象（反对解决不合格的引用）。<code>#root</code> 变量也是始终定义，并引用根上下文对象。尽管 <code>#this</code> 可能随表达式的组成部分的求值而变化，但 <code>#root</code> 始终引用根。 以下示例说明如何使用 <code>#this</code> 和 <code>#root</code> 变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an array of integers</span></span><br><span class="line">List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">primes.addAll(Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create parser and set variable 'primes' as the array of integers</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess();</span><br><span class="line">context.setVariable(<span class="string">"primes"</span>, primes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// all prime numbers &gt; 10 from the list (using selection ?&#123;...&#125;)</span></span><br><span class="line"><span class="comment">// evaluates to [11, 13, 17]</span></span><br><span class="line">List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(</span><br><span class="line">        <span class="string">"#primes.?[#this&gt;10]"</span>).getValue(context);</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>您可以通过注册可以在表达式字符串中调用的用户定义函数来扩展 SpEL。该函数通过 <code>EvaluationContext</code> 注册。下面的示例显示如何注册用户定义的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method method = ...;</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line">context.setVariable(<span class="string">"myFunction"</span>, method);</span><br></pre></td></tr></table></figure>

<p>例如，考虑以下用于反转字符串的实用程序方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder(input.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，您可以注册并使用前面的方法，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line">context.setVariable(<span class="string">"reverseString"</span>,</span><br><span class="line">        StringUtils.class.getDeclaredMethod(<span class="string">"reverseString"</span>, String.class));</span><br><span class="line"></span><br><span class="line">String helloWorldReversed = parser.parseExpression(</span><br><span class="line">        <span class="string">"#reverseString('hello')"</span>).getValue(context, String.class);</span><br></pre></td></tr></table></figure>

<h3 id="Bean-引用"><a href="#Bean-引用" class="headerlink" title="Bean 引用"></a>Bean 引用</h3><p>如果评估上下文已使用 bean 解析器配置，则可以使用@符号从表达式中查找 bean。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context.setBeanResolver(<span class="keyword">new</span> MyBeanResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation</span></span><br><span class="line">Object bean = parser.parseExpression(<span class="string">"@something"</span>).getValue(context);</span><br></pre></td></tr></table></figure>

<p>要访问工厂 bean 本身，您应该在 bean 名称前加上＆符号。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context.setBeanResolver(<span class="keyword">new</span> MyBeanResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will end up calling resolve(context,"&amp;foo") on MyBeanResolver during evaluation</span></span><br><span class="line">Object bean = parser.parseExpression(<span class="string">"&amp;foo"</span>).getValue(context);</span><br></pre></td></tr></table></figure>

<h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>您可以使用三元运算符在表达式内部执行 if-then-else 条件逻辑。 以下清单显示了一个最小的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String falseString = parser.parseExpression(</span><br><span class="line">        <span class="string">"false ? 'trueExp' : 'falseExp'"</span>).getValue(String.class);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，布尔值 false 导致返回字符串值’falseExp’。 一个更现实的示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parser.parseExpression(<span class="string">"Name"</span>).setValue(societyContext, <span class="string">"IEEE"</span>);</span><br><span class="line">societyContext.setVariable(<span class="string">"queryName"</span>, <span class="string">"Nikola Tesla"</span>);</span><br><span class="line"></span><br><span class="line">expression = <span class="string">"isMember(#queryName)? #queryName + ' is a member of the ' "</span> +</span><br><span class="line">        <span class="string">"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'"</span>;</span><br><span class="line"></span><br><span class="line">String queryResultString = parser.parseExpression(expression)</span><br><span class="line">        .getValue(societyContext, String.class);</span><br><span class="line"><span class="comment">// queryResultString = "Nikola Tesla is a member of the IEEE Society"</span></span><br></pre></td></tr></table></figure>

<p>有关三元运算符的更短语法，请参阅关于 Elvis 运算符的下一部分。</p>
<h3 id="Elvis-运算符"><a href="#Elvis-运算符" class="headerlink" title="Elvis 运算符"></a>Elvis 运算符</h3><p>Elvis 运算符是三元运算符语法的简化，并且在 Groovy 语言中使用。 使用三元运算符语法，通常必须将变量重复两次，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"Elvis Presley"</span>;</span><br><span class="line">String displayName = (name != <span class="keyword">null</span> ? name : <span class="string">"Unknown"</span>);</span><br></pre></td></tr></table></figure>

<p>相反，您可以使用 Elvis 运算符（其命名类似于 Elvis 的发型）。 以下示例显示了如何使用 Elvis 运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">String name = parser.parseExpression(<span class="string">"name?:'Unknown'"</span>).getValue(<span class="keyword">new</span> Inventor(), String.class);</span><br><span class="line">System.out.println(name);  <span class="comment">// 'Unknown'</span></span><br></pre></td></tr></table></figure>

<p>以下显示了一个更复杂的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, <span class="string">"Serbian"</span>);</span><br><span class="line">String name = parser.parseExpression(<span class="string">"Name?:'Elvis Presley'"</span>).getValue(context, tesla, String.class);</span><br><span class="line">System.out.println(name);  <span class="comment">// Nikola Tesla</span></span><br><span class="line"></span><br><span class="line">tesla.setName(<span class="keyword">null</span>);</span><br><span class="line">name = parser.parseExpression(<span class="string">"Name?:'Elvis Presley'"</span>).getValue(context, tesla, String.class);</span><br><span class="line">System.out.println(name);  <span class="comment">// Elvis Presley</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>您可以使用 Elvis 运算符在表达式中应用默认值。 以下示例显示了如何在 <code>@Value</code> 表达式中使用 Elvis 运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Value</span>(<span class="string">"#&#123;systemProperties['pop3.port'] ?: 25&#125;"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>上例将注入系统属性 <code>pop3.port</code>，为空将注入 25。</p>
</blockquote>
<h3 id="安全导航运算符"><a href="#安全导航运算符" class="headerlink" title="安全导航运算符"></a>安全导航运算符</h3><p>安全导航运算符用于避免 <code>NullPointerException</code>，它来自 Groovy 语言。通常，当您引用一个对象时，可能需要在访问该对象的方法或属性之前验证其是否为 null。为了避免这种情况，安全导航运算符返回 null 而不是引发异常。 下面的示例演示如何使用安全导航操作符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, <span class="string">"Serbian"</span>);</span><br><span class="line">tesla.setPlaceOfBirth(<span class="keyword">new</span> PlaceOfBirth(<span class="string">"Smiljan"</span>));</span><br><span class="line"></span><br><span class="line">String city = parser.parseExpression(<span class="string">"PlaceOfBirth?.City"</span>).getValue(context, tesla, String.class);</span><br><span class="line">System.out.println(city);  <span class="comment">// Smiljan</span></span><br><span class="line"></span><br><span class="line">tesla.setPlaceOfBirth(<span class="keyword">null</span>);</span><br><span class="line">city = parser.parseExpression(<span class="string">"PlaceOfBirth?.City"</span>).getValue(context, tesla, String.class);</span><br><span class="line">System.out.println(city);  <span class="comment">// null - does not throw NullPointerException!!!</span></span><br></pre></td></tr></table></figure>

<h3 id="集合选择"><a href="#集合选择" class="headerlink" title="集合选择"></a>集合选择</h3><p>选择是一种强大的表达语言功能，可让您通过从源集合中进行选择来将其转换为另一个集合。</p>
<p>选择使用 <code>.?[selectionExpression]</code> 的语法。 它过滤集合并返回一个包含原始元素子集的新集合。例如，通过选择，我们可以轻松地获得 Serbian inventors 的列表，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(</span><br><span class="line">        <span class="string">"Members.?[Nationality == 'Serbian']"</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure>

<p>在列表和映射上都可以选择。对于列表，将针对每个单独的列表元素评估选择标准。针对映射，针对每个映射条目（Java 类型 Map.Entry 的对象）评估选择标准。每个映射条目都有其键和值，可作为属性访问以供选择。</p>
<p>以下表达式返回一个新映射，该映射由原始映射中条目值小于 27 的那些元素组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map newMap = parser.parseExpression(<span class="string">"map.?[value&lt;27]"</span>).getValue();</span><br></pre></td></tr></table></figure>

<p>除了返回所有选定的元素外，您只能检索第一个或最后一个值。为了获得与选择匹配的第一个条目，语法为 <code>.^[selectionExpression]</code>。要获取最后一个匹配选择，语法为 <code>.$[selectionExpression]</code>。</p>
<h3 id="集合投影"><a href="#集合投影" class="headerlink" title="集合投影"></a>集合投影</h3><p>投影使集合可以驱动子表达式的求值，结果是一个新的集合。投影的语法为 <code>.![projectionExpression]</code>。例如，假设我们有一个 inventor 列表，但是想要他们出生的城市列表。实际上，我们希望为 inventor 列表中的每个条目计算“placeOfBirth.city”。 下面的示例使用投影来做到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// returns [&apos;Smiljan&apos;, &apos;Idvor&apos; ]</span><br><span class="line">List placesOfBirth = (List)parser.parseExpression(&quot;Members.![placeOfBirth.city]&quot;);</span><br></pre></td></tr></table></figure>

<p>您还可以使用映射来驱动投影，在这种情况下，将针对映射中的每个条目（表示为 Java Map.Entry）对投影表达式进行评估。 跨映射的投影结果是一个列表，其中包含针对每个映射条目的投影表达式的评估。</p>
<h3 id="表达式模板"><a href="#表达式模板" class="headerlink" title="表达式模板"></a>表达式模板</h3><p>表达式模板允许将文字文本与一个或多个评估块混合。每个评估块均以您可以定义的前缀和后缀字符分隔。常见的选择是使用 <code>#{ }</code> 作为分隔符，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String randomPhrase = parser.parseExpression(</span><br><span class="line">        <span class="string">"random number is #&#123;T(java.lang.Math).random()&#125;"</span>,</span><br><span class="line">        <span class="keyword">new</span> TemplateParserContext()).getValue(String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluates to "random number is 0.7038186818312008"</span></span><br></pre></td></tr></table></figure>

<p>通过将文字文本 <code>&#39;random number is &#39;</code> 与评估 <code>#{ }</code> 分隔符内的表达式的结果（在本例中为调用 <code>random()</code> 方法的结果）相连接来评估字符串。<code>parseExpression()</code> 方法的第二个参数的类型为 <code>ParserContext</code>。<code>ParserContext</code> 接口用于影响表达式的解析方式，以支持表达式模板功能。<code>TemplateParserContext</code> 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateParserContext</span> <span class="keyword">implements</span> <span class="title">ParserContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#&#123;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例中使用的类"><a href="#示例中使用的类" class="headerlink" title="示例中使用的类"></a>示例中使用的类</h2><p>本节列出了本章示例中使用的类。</p>
<p>Inventor.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spring.samples.spel.inventor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inventor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nationality;</span><br><span class="line">    <span class="keyword">private</span> String[] inventions;</span><br><span class="line">    <span class="keyword">private</span> Date birthdate;</span><br><span class="line">    <span class="keyword">private</span> PlaceOfBirth placeOfBirth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Inventor</span><span class="params">(String name, String nationality)</span> </span>&#123;</span><br><span class="line">        GregorianCalendar c= <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nationality = nationality;</span><br><span class="line">        <span class="keyword">this</span>.birthdate = c.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Inventor</span><span class="params">(String name, Date birthdate, String nationality)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nationality = nationality;</span><br><span class="line">        <span class="keyword">this</span>.birthdate = birthdate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Inventor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNationality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nationality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNationality</span><span class="params">(String nationality)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nationality = nationality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthdate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthdate</span><span class="params">(Date birthdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthdate = birthdate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlaceOfBirth <span class="title">getPlaceOfBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> placeOfBirth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPlaceOfBirth</span><span class="params">(PlaceOfBirth placeOfBirth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.placeOfBirth = placeOfBirth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInventions</span><span class="params">(String[] inventions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inventions = inventions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getInventions() &#123;</span><br><span class="line">        <span class="keyword">return</span> inventions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PlaceOfBirth.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spring.samples.spel.inventor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOfBirth</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlaceOfBirth</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city=city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlaceOfBirth</span><span class="params">(String city, String country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(city);</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountry</span><span class="params">(String country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Society.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spring.samples.spel.inventor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Society</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String Advisors = <span class="string">"advisors"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String President = <span class="string">"president"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Inventor&gt; members = <span class="keyword">new</span> ArrayList&lt;Inventor&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map officers = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getOfficers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> officers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMember</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Inventor inventor : members) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inventor.getName().equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring进阶 - 验证、数据绑定和类型转换]]></title>
      <url>https://HaleLu.github.io/2020/05/spring-4/</url>
      <content type="html"><![CDATA[<p>书接<a href="https://halelu.github.io/2020/05/spring-3/">上文</a></p>
<p>接下来到 Spring framework core 的第三大块 —— 验证、数据绑定和类型转换</p>
<a id="more"></a>

<h1 id="验证、数据绑定和类型转换"><a href="#验证、数据绑定和类型转换" class="headerlink" title="验证、数据绑定和类型转换"></a>验证、数据绑定和类型转换</h1><p>考虑将验证作为业务逻辑有利有弊，Spring 提供了一种验证（和数据绑定）设计。具体来说，验证不应与 Web 层绑定，并且应该易于本地化，并且应该可以插入任何可用的验证器。考虑到这些问题，Spring 提供了一个 <code>Validator</code> 合同，该合同既基本又可以在应用程序的每个层中使用。</p>
<p>数据绑定对于使用户输入动态绑定到应用程序的域模型（或用于处理用户输入的任何对象）非常有用。Spring 提供了恰当地命名为 <code>DataBinder</code> 的功能。 <code>Validator</code> 和 <code>DataBinder</code> 组成了验证包，该验证包主要用于但不限于 Web 层。</p>
<p><code>BeanWrapper</code> 是 Spring 框架中的基本概念，并在很多地方使用。但是，您可能不需要直接使用 <code>BeanWrapper</code>。但是，因为这是参考文档，所以我们认为可能需要进行一些解释。我们将在本章中解释 <code>BeanWrapper</code>，因为如果您要使用它，那么在尝试将数据绑定到对象时最有可能使用它。</p>
<p>Spring 的 <code>DataBinder</code> 和较低级别的 <code>BeanWrapper</code> 都使用 <code>PropertyEditorSupport</code> 实现来解析和格式化属性值。 <code>PropertyEditor</code> 和 <code>PropertyEditorSupport</code> 类型是 JavaBeans 规范的一部分，本章还将对此进行说明。 Spring 3 引入了 <code>core.convert</code> 包，该包提供了常规的类型转换工具，以及用于格式化 UI 字段值的高级“format”包。您可以将这些包用作 <code>PropertyEditorSupport</code> 实现的更简单替代方案。本章还将对它们进行讨论。</p>
<p>Spring 通过设置基础结构和 Spring 自己的 <code>Validator</code> 合同的适配器来支持 Java Bean 验证。应用程序可以全局启用一次 Bean 验证，如 Java Bean 验证中所述，并将其专用于所有验证需求。在 Web 层中，应用程序可以每个 <code>DataBinder</code> 进一步注册控制器本地的 Spring <code>Validator</code> 实例，如配置 <code>DataBinder</code> 中所述，这对于插入自定义验证逻辑很有用。</p>
<h2 id="使用-Spring-的-Validator-接口进行验证"><a href="#使用-Spring-的-Validator-接口进行验证" class="headerlink" title="使用 Spring 的 Validator 接口进行验证"></a>使用 Spring 的 Validator 接口进行验证</h2><p>Spring 具有 <code>Validator</code> 接口，可用于验证对象。 <code>Validator</code> 接口通过使用 <code>Errors</code> 对象来工作，以便验证器在验证时可以将验证失败报告给 <code>Errors</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the usual getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例通过实现 <code>org.springframework.validation.Validator</code> 接口的以下两个方法来提供 <code>Person</code> 类的验证行为：</p>
<ul>
<li><code>supports(Class)</code>：此验证程序可以验证提供的 Class 的实例吗？</li>
<li><code>validate(Object, org.springframework.validation.Errors)</code>：验证给定的对象，并在发生验证错误的情况下，向给定的 <code>Errors</code> 对象注册这些对象。</li>
</ul>
<p>实施 <code>Validator</code> 非常简单，尤其是当您知道 Spring Framework 也提供的 <code>ValidationUtils</code> 帮助器类时。 以下示例实现了用于 <code>Person</code> 实例的 <code>Validator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This Validator validates only Person instances</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object obj, Errors e)</span> </span>&#123;</span><br><span class="line">        ValidationUtils.rejectIfEmpty(e, <span class="string">"name"</span>, <span class="string">"name.empty"</span>);</span><br><span class="line">        Person p = (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">"age"</span>, <span class="string">"negativevalue"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">"age"</span>, <span class="string">"too.darn.old"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ValidationUtils</code> 类上的静态 <code>rejectIfEmpty(..)</code>方法用于拒绝 name 属性（如果该属性为 null 或为空字符串）。查看 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/ValidationUtils.html" target="_blank" rel="noopener"><code>ValidationUtils</code> javadoc</a>，看看它除了提供前面显示的示例外还提供什么功能。</p>
<p>虽然可以实现单个 <code>Validator</code> 类来验证丰富对象中的每个嵌套对象，但最好在其自己的 <code>Validator</code> 实现中封装对象的每个嵌套类的验证逻辑。一个“丰富”对象的简单示例是一个 <code>Customer</code>，它由两个 String 属性（第一个和第二个名称）和一个复杂的 <code>Address</code> 对象组成。地址对象可以独立于客户对象使用，因此已实现了不同的 <code>AddressValidator</code>。如果希望 <code>CustomerValidator</code> 重用 <code>AddressValidator</code> 类中包含的逻辑而不求助于复制和粘贴，则可以在 <code>CustomerValidator</code> 中依赖注入或实例化一个 <code>AddressValidator</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator addressValidator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerValidator</span><span class="params">(Validator addressValidator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addressValidator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] is "</span> +</span><br><span class="line">                <span class="string">"required and must not be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!addressValidator.supports(Address.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] must "</span> +</span><br><span class="line">                <span class="string">"support the validation of [Address] instances."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.addressValidator = addressValidator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This Validator validates Customer instances, and any subclasses of Customer too</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"firstName"</span>, <span class="string">"field.required"</span>);</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"surname"</span>, <span class="string">"field.required"</span>);</span><br><span class="line">        Customer customer = (Customer) target;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            errors.pushNestedPath(<span class="string">"address"</span>);</span><br><span class="line">            ValidationUtils.invokeValidator(<span class="keyword">this</span>.addressValidator, customer.getAddress(), errors);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            errors.popNestedPath();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证错误将报告给传递给验证器的 <code>Errors</code> 对象。 对于 Spring Web MVC，可以使用 <code>&lt;spring:bind/&gt;</code> 标记检查错误消息，但是也可以自己检查 <code>Errors</code> 对象。关于它提供的方法的更多信息可以在 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframeworkvalidation/Errors.html" target="_blank" rel="noopener">javadoc</a> 中找到。</p>
<h2 id="将代码解析为错误消息"><a href="#将代码解析为错误消息" class="headerlink" title="将代码解析为错误消息"></a>将代码解析为错误消息</h2><p>我们介绍了数据绑定和验证。本节介绍与验证错误相对应的输出消息。在上一节显示的示例中，我们拒绝了名称和年龄字段。如果要使用 <code>MessageSource</code> 输出错误消息，可以使用拒绝字段时提供的错误代码（在这种情况下为“名称”和“年龄”）来进行输出。当您从 <code>Errors</code> 接口调用（直接或间接通过使用诸如 <code>ValidationUtils</code> 类的直接或间接）<code>rejectValue</code> 或其他拒绝方法之一时，基础实现不仅注册您传入的代码，还注册许多其他错误代码。<code>MessageCodesResolver</code> 确定 <code>Errors</code> 接口寄存器中的哪个错误代码。默认情况下，使用 <code>DefaultMessageCodesResolver</code>，它（例如）不仅使用您提供的代码注册消息，而且还注册包含传递给拒绝方法的字段名称的消息。因此，如果您通过使用 <code>rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)</code> 拒绝字段，除了 <code>too.darn.old</code> 代码外，Spring 还会注册 <code>too.darn.old.age</code> 和 <code>too.darn.old.age.int</code>（第一个包含字段名称，第二个包含字段类型）。这样做是为了方便开发人员在定位错误消息时提供帮助。</p>
<p>有关 MessageCodesResolver 和默认策略的更多信息，可以分别在 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/MessageCodesResolver.html" target="_blank" rel="noopener"><code>MessageCodesResolver</code></a> 和 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html" target="_blank" rel="noopener"><code>DefaultMessageCodesResolver</code></a> 的 javadoc 中找到。</p>
<h2 id="Bean-操作和-BeanWrapper"><a href="#Bean-操作和-BeanWrapper" class="headerlink" title="Bean 操作和 BeanWrapper"></a>Bean 操作和 BeanWrapper</h2><p><code>org.springframework.beans</code> 包遵循 JavaBeans 标准。 JavaBean 是具有默认无参数构造函数的类，并且遵循命名约定，在该命名约定下，例如，名为 <code>bingoMadness</code> 的属性将具有 setter 方法 <code>setBingoMadness(..)</code> 和 getter 方法 <code>getBingoMadness()</code>。有关 JavaBean 和规范的更多信息，请参见 <a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html" target="_blank" rel="noopener">javabeans</a>。</p>
<p>Bean 包中的一个非常重要的类是 <code>BeanWrapper</code> 接口及其相应的实现（<code>BeanWrapperImpl</code>）。就像从 Javadoc 引用的那样，<code>BeanWrapper</code> 提供了以下功能：设置和获取属性值（单独或批量），获取属性描述符以及查询属性以确定它们是否可读或可写。此外，<code>BeanWrapper</code> 还支持嵌套属性，从而可以将子属性上的属性设置为无限深度。 <code>BeanWrapper</code> 还支持添加标准 JavaBeans <code>PropertyChangeListeners</code> 和 <code>VetoableChangeListeners</code> 的功能，而无需在目标类中支持代码。最后但并非最不重要的一点是，<code>BeanWrapper</code> 支持设置索引属性。 <code>BeanWrapper</code> 通常不直接由应用程序代码使用，而是由 <code>DataBinder</code> 和 <code>BeanFactory</code> 使用。</p>
<p><code>BeanWrapper</code> 的工作方式部分由其名称表示：它包装一个 Bean，以对该 Bean 执行操作，例如设置和检索属性。</p>
<h3 id="设置和获取基本和嵌套属性"><a href="#设置和获取基本和嵌套属性" class="headerlink" title="设置和获取基本和嵌套属性"></a>设置和获取基本和嵌套属性</h3><p>设置和获取属性是通过 <code>BeanWrapper</code> 的 <code>setPropertyValue</code> 和 <code>getPropertyValue</code> 重载方法变体完成的。有关详细信息，请参见其 Javadoc。下表显示了这些约定的一些示例：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>表示与 <code>getName()</code> 或 <code>isName()</code> 和 <code>setName(..)</code> 方法相对应的 <code>name</code> 属性 。</td>
</tr>
<tr>
<td>account.name</td>
<td>表示与 <code>getAccount().setName()</code> 或 <code>getAccount().getName()</code> 方法相对应的 <code>account</code> 属性的 <code>name</code> 嵌套属性。</td>
</tr>
<tr>
<td>account[2]</td>
<td>表示索引属性的<em>第三个</em>元素 <code>account</code>。索引属性可能是的 <code>array</code>，<code>list</code> 或其它天然有序集合。</td>
</tr>
<tr>
<td>account[COMPANYNAME]</td>
<td>表示<code>account</code> 这个 <code>Map</code>由 <code>COMPANYNAME</code> 键索引的条目的值。</td>
</tr>
</tbody></table>
<p>（如果您不打算直接使用 <code>BeanWrapper</code>，那么下一部分对您而言并不是至关重要的。如果仅使用 <code>DataBinder</code> 和 <code>BeanFactory</code> 及其默认实现，则应跳到 <code>PropertyEditors</code> 的部分。）</p>
<p>以下两个示例类使用 <code>BeanWrapper</code> 来获取和设置属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Employee managingDirector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getManagingDirector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManagingDirector</span><span class="params">(Employee managingDirector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.managingDirector = managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码段显示了一些有关如何检索和操纵实例化的 <code>Companies</code> 和 <code>Employees</code> 的某些属性的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BeanWrapper company = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Company());</span><br><span class="line"><span class="comment">// setting the company name..</span></span><br><span class="line">company.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</span><br><span class="line"><span class="comment">// ... can also be done like this:</span></span><br><span class="line">PropertyValue value = <span class="keyword">new</span> PropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</span><br><span class="line">company.setPropertyValue(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok, let's create the director and tie it to the company:</span></span><br><span class="line">BeanWrapper jim = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Employee());</span><br><span class="line">jim.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Jim Stravinsky"</span>);</span><br><span class="line">company.setPropertyValue(<span class="string">"managingDirector"</span>, jim.getWrappedInstance());</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieving the salary of the managingDirector through the company</span></span><br><span class="line">Float salary = (Float) company.getPropertyValue(<span class="string">"managingDirector.salary"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="内置的-PropertyEditor-实现"><a href="#内置的-PropertyEditor-实现" class="headerlink" title="内置的 PropertyEditor 实现"></a>内置的 <code>PropertyEditor</code> 实现</h3><p>pring 使用 <code>PropertyEditor</code> 的概念来实现对象和字符串之间的转换。以不同于对象本身的方式表示属性可能很方便。例如，日期可以用人类可读的方式表示（如字符串：”2007-14-09”），而我们仍然可以将人类可读的形式转换回原始日期（或者更好的是，转换任何日期以人类可读的形式输入到 <code>Date</code> 对象）。通过注册类型为 <code>java.beans.PropertyEditor</code> 的自定义编辑器，可以实现此行为。在 <code>BeanWrapper</code> 上或在特定的 IoC 容器中注册自定义编辑器（如上一章所述），使它具有如何将属性转换为所需类型的知识。有关 <code>PropertyEditor</code> 的更多信息，请参见 <a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html" target="_blank" rel="noopener">Oracle 的 java.beans 包的 javadoc</a>。</p>
<p>在 Spring 中使用属性编辑的两个示例：</p>
<ul>
<li>通过使用 <code>PropertyEditor</code> 实现在 bean 上设置属性。当使用 <code>String</code> 作为在 XML 文件中声明的某个 bean 的属性的值时，Spring（如果相应属性的设置器具有 <code>Class</code> 参数）将使用 <code>ClassEditor</code> 尝试将参数解析为 <code>Class</code> 对象。</li>
<li>在 Spring 的 MVC 框架中，通过使用各种 <code>PropertyEditor</code> 实现来解析 HTTP 请求参数，您可以在 <code>CommandController</code> 的所有子类中手动绑定这些实现。</li>
</ul>
<p>Spring 具有许多内置的 <code>PropertyEditor</code> 实现，以简化生活。它们都位于<code>org.springframework.beans.propertyeditors</code> 包中。默认情况下，大多数（但不是全部，如下表所示）由 <code>BeanWrapperImpl</code> 注册。如果可以通过某种方式配置属性编辑器，则仍可以注册自己的变体以覆盖默认变体。下表描述了 Spring 提供的各种 <code>PropertyEditor</code> 实现：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayPropertyEditor</code></td>
<td>字节数组的编辑器。将字符串转换为其相应的字节表示形式。默认情况下由 <code>BeanWrapperImpl</code> 注册。</td>
</tr>
<tr>
<td><code>ClassEditor</code></td>
<td>将代表类的字符串解析为实际类，反之亦然。当找不到类时，将抛出 <code>IllegalArgumentException</code>。默认情况下，由 <code>BeanWrapperImpl</code> 注册。</td>
</tr>
<tr>
<td><code>CustomBooleanEditor</code></td>
<td>布尔属性的可定制属性编辑器。默认情况下，由 <code>BeanWrapperImpl</code> 注册，但是可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td><code>CustomCollectionEditor</code></td>
<td>集合的属性编辑器，可将任何源 <code>Collection</code> 转换为给定的目标 <code>Collection</code> 类型。</td>
</tr>
<tr>
<td><code>CustomDateEditor</code></td>
<td><code>java.util.Date</code> 的可自定义属性编辑器，支持自定义 <code>DateFormat</code>。默认未注册。必须根据需要以适当的格式进行用户注册。</td>
</tr>
<tr>
<td><code>CustomNumberEditor</code></td>
<td>任何 <code>Number</code> 子类（例如 <code>Integer</code>，<code>Long</code>，<code>Float</code> 或 <code>Double</code>）的可自定义属性编辑器。默认情况下，由 <code>BeanWrapperImpl</code> 注册，但是可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td><code>FileEditor</code></td>
<td>将字符串解析为 <code>java.io.File</code> 对象。默认情况下，由 <code>BeanWrapperImpl</code> 注册。</td>
</tr>
<tr>
<td><code>InputStreamEditor</code></td>
<td>单向属性编辑器，它可以采用字符串并生成（通过中间的 <code>ResourceEditor</code> 和 <code>Resource</code>）一个 <code>InputStream</code>，以便可以将 <code>InputStream</code> 属性直接设置为字符串。请注意，默认用法不会为您关闭 <code>InputStream</code>。默认情况下，由 <code>BeanWrapperImpl</code> 注册。</td>
</tr>
<tr>
<td><code>LocaleEditor</code></td>
<td>可以将字符串解析为 <code>Locale</code> 对象，反之亦然（字符串格式为 _<code>[country]</code>_<code>[variant]</code>，与 Locale 的 <code>toString()</code> 方法相同）。默认情况下，由 <code>BeanWrapperImpl</code> 注册。</td>
</tr>
<tr>
<td><code>PatternEditor</code></td>
<td>可以将字符串解析为 <code>java.util.regex.Pattern</code> 对象，反之亦然。</td>
</tr>
<tr>
<td><code>PropertiesEditor</code></td>
<td>可以将字符串（以 <code>java.util.Properties</code> 类的 javadoc 中定义的格式格式化）转换为 <code>Properties</code> 对象。默认情况下，由 <code>BeanWrapperImpl</code> 注册。</td>
</tr>
<tr>
<td><code>StringTrimmerEditor</code></td>
<td>修剪字符串的属性编辑器。（可选）允许将空字符串转换为空值。默认情况下未注册——必须是用户注册的。</td>
</tr>
<tr>
<td><code>URLEditor</code></td>
<td>可以将 URL 的字符串表示形式解析为实际的 <code>URL</code> 对象。默认情况下，由 <code>BeanWrapperImpl</code> 注册</td>
</tr>
</tbody></table>
<p>Spring 使用 <code>java.beans.PropertyEditorManager</code> 设置可能需要的属性编辑器的搜索路径。搜索路径还包括 <code>sun.bean.editors</code>，其中包括针对诸如 <code>Font</code>，<code>Color</code> 和大多数基本类型的类型的 <code>PropertyEditor</code> 实现。 还要注意，如果标准 JavaBeans 基础结构与它们处理的类在同一包中，并且与该类具有相同的名称，并附加了 Editor，则标准 JavaBeans 基础结构将自动发现 <code>PropertyEditor</code> 类（无需显式注册它们）。例如，可能具有以下类和包结构，足以使 <code>SomethingEditor</code> 类被识别并用作 <code>Something</code> 类型的属性的 <code>PropertyEditor</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  chank</span><br><span class="line">    pop</span><br><span class="line">      Something</span><br><span class="line">      SomethingEditor // the PropertyEditor for the Something class</span><br></pre></td></tr></table></figure>

<p>注意，您也可以在此处使用标准的 <code>BeanInfo</code> JavaBeans 机制（在某种程度上进行了描述）。 以下示例使用 <code>BeanInfo</code> 机制使用关联类的属性显式注册一个或多个 <code>PropertyEditor</code> 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  chank</span><br><span class="line">    pop</span><br><span class="line">      Something</span><br><span class="line">      SomethingBeanInfo // the BeanInfo for the Something class</span><br></pre></td></tr></table></figure>

<p>所引用的 <code>SomethingBeanInfo</code> 类的以下 Java 源代码将 <code>CustomNumberEditor</code> 与 <code>Something</code> 类的 <code>age</code> 属性相关联：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomethingBeanInfo</span> <span class="keyword">extends</span> <span class="title">SimpleBeanInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> PropertyEditor numberPE = <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">true</span>);</span><br><span class="line">            PropertyDescriptor ageDescriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"age"</span>, Something.class) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> PropertyEditor <span class="title">createPropertyEditor</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> numberPE;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PropertyDescriptor[] &#123; ageDescriptor &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IntrospectionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册其他自定义-PropertyEditor-实现"><a href="#注册其他自定义-PropertyEditor-实现" class="headerlink" title="注册其他自定义 PropertyEditor 实现"></a>注册其他自定义 PropertyEditor 实现</h4><p>当将 bean 属性设置为字符串值时，Spring IoC 容器最终使用标准 JavaBeans <code>PropertyEditor</code> 实现将这些字符串转换为属性的复杂类型。Spring 预注册了许多自定义的 <code>PropertyEditor</code> 实现（例如，将表示为字符串的类名称转换为 <code>Class</code> 对象）。此外，Java 的标准 JavaBeans <code>PropertyEditor</code> 查找机制允许适当地命名类的 <code>PropertyEditor</code>，并将其与提供支持的类放在同一包中，以便可以自动找到它。</p>
<p>如果需要注册其他自定义 <code>PropertyEditor</code>，则可以使用几种机制。最手动的方法（通常不方便或不建议使用）是使用 <code>ConfigurableBeanFactory</code> 接口的 <code>registerCustomEditor()</code> 方法，并假设您有 <code>BeanFactory</code> 引用。另一种（稍微方便些）的机制是使用一种称为 <code>CustomEditorConfigurer</code> 的特殊 bean 工厂后处理器。尽管您可以将 Bean 工厂后处理器与 BeanFactory 实现一起使用，但 <code>CustomEditorConfigurer</code> 具有嵌套的属性设置，因此我们强烈建议您将其与 <code>ApplicationContext</code> 一起使用，在这里可以将其以与其他任何 Bean 相似的方式进行部署，并且可以在任何位置进行部署。自动检测并应用。</p>
<p>请注意，所有的 bean 工厂和应用程序上下文通过使用 BeanWrapper 来处理属性转换，都会自动使用许多内置的属性编辑器。上一节列出了 BeanWrapper 注册的标准属性编辑器。此外，<code>ApplicationContext</code> 还以适合特定应用程序上下文类型的方式重写或添加其他编辑器，以处理资源查找。</p>
<p>标准 JavaBeans <code>PropertyEditor</code> 实例用于将以字符串表示的属性值转换为该属性的实际复杂类型。您可以使用 bean 工厂的后处理器 <code>CustomEditorConfigurer</code> 来方便地将对其他 <code>PropertyEditor</code> 实例的支持添加到 <code>ApplicationContext</code>。</p>
<p>考虑以下示例，该示例定义了一个名为 <code>ExoticType</code> 的用户类和另一个名为 <code>DependsOnExoticType</code> 的类，该类需要将 <code>ExoticType</code> 设置为属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExoticType</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependsOnExoticType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExoticType type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(ExoticType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确设置之后，我们希望能够将 type 属性分配为字符串，<code>PropertyEditor</code> 会将其转换为实际的 <code>ExoticType</code> 实例。 以下 bean 定义显示了如何建立这种关系：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sample"</span> <span class="attr">class</span>=<span class="string">"example.DependsOnExoticType"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">value</span>=<span class="string">"aNameForExoticType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>PropertyEditor</code> 实现可能类似于以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// converts string representation to ExoticType object</span></span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticTypeEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        setValue(<span class="keyword">new</span> ExoticType(text.toUpperCase()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-类型转换"><a href="#Spring-类型转换" class="headerlink" title="Spring 类型转换"></a>Spring 类型转换</h2><p>Spring 3 引入了 <code>core.convert</code> 包，该包提供了通用的类型转换系统。系统定义了一个用于实现类型转换逻辑的 SPI 和一个用于在运行时执行类型转换的 API。在 Spring 容器中，可以使用此系统作为 <code>PropertyEditor</code> 实现的替代方法，以将外部化的 bean 属性值字符串转换为所需的属性类型。 您还可以在应用程序中需要类型转换的任何地方使用公共 API。</p>
<h3 id="转换器-SPI"><a href="#转换器-SPI" class="headerlink" title="转换器 SPI"></a>转换器 SPI</h3><p>如以下接口定义所示，用于实现类型转换逻辑的 SPI 非常简单且具有强类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要创建自己的转换器，请实现 Converter 接口并将 S 设置为要转换的类型，并将 T 设置为要转换的类型。如果还需要注册一个委托数组或集合转换器（默认情况下 DefaultConversionService 会这样做），则也可以透明地应用此类转换器，如果需要将 S 的集合或数组转换为 T 的数组或集合。</p>
<p>对于每次对 convert（S）的调用，保证源参数不为 null。如果转换失败，您的转换器可能会引发任何未经检查的异常。具体来说，它应该抛出 IllegalArgumentException 以报告无效的源值。注意确保您的 Converter 实现是线程安全的。</p>
<p>为了方便起见，在 core.convert.support 软件包中提供了几种转换器实现。这些包括从字符串到数字和其他常见类型的转换器。下面的清单显示了 StringToInteger 类，它是一个典型的 Converter 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInteger</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-ConverterFactory"><a href="#使用-ConverterFactory" class="headerlink" title="使用 ConverterFactory"></a>使用 <code>ConverterFactory</code></h3><p>当需要集中整个类层次结构的转换逻辑时（例如，从 String 转换为 Enum 对象时），可以实现 ConverterFactory，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数化 S 为您要转换的类型，参数化 R 为基类型，定义可以转换为的类的范围。 然后实现 getConverter（Class <t>），其中 T 是 R 的子类。</t></p>
<p>以 StringToEnumConverterFactory 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Enum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Enum&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringToEnumConverter(targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Class&lt;T&gt; enumType;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StringToEnumConverter</span><span class="params">(Class&lt;T&gt; enumType)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.enumType = enumType;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Enum.valueOf(<span class="keyword">this</span>.enumType, source.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-GenericConverter"><a href="#使用-GenericConverter" class="headerlink" title="使用 GenericConverter"></a>使用 <code>GenericConverter</code></h3><p>当您需要复杂的 <code>Converter</code> 实现时，请考虑使用 <code>GenericConverter</code> 接口。 与 <code>Converter</code> 相比，<code>GenericConverter</code> 具有比 <code>Converter</code> 更灵活但强度不高的签名，支持在多种源类型和目标类型之间进行转换。此外，<code>GenericConverter</code> 使您可以在实现转换逻辑时使用可用的源字段和目标字段上下文。 这种上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。 以下清单显示了 <code>GenericConverter</code> 的接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现 <code>GenericConverter</code>，请让 <code>getConvertibleTypes()</code> 返回支持的源 → 目标类型对。 然后实现 <code>convert(Object，TypeDescriptor，TypeDescriptor)</code> 包含您的转换逻辑。 源 <code>TypeDescriptor</code> 提供对包含正在转换的值的源字段的访问。 使用目标 <code>TypeDescriptor</code>，可以访问要设置转换值的目标字段。</p>
<p><code>GenericConverter</code> 的一个很好的例子是在 Java 数组和集合之间进行转换的转换器。 这样的 <code>ArrayToCollectionConverter</code> 会对声明目标集合类型的字段进行内省，以解析集合的元素类型。 这样就可以在将集合设置到目标字段上之前，将源数组中的每个元素转换为集合元素类型。</p>
<blockquote>
<p>由于 <code>GenericConverter</code> 是一个更复杂的 SPI 接口，因此仅应在需要时使用它。 支持 <code>Converter</code> 或 <code>ConverterFactory</code> 以满足基本的类型转换需求。</p>
</blockquote>
<h4 id="使用-ConditionalGenericConverter"><a href="#使用-ConditionalGenericConverter" class="headerlink" title="使用 ConditionalGenericConverter"></a>使用 <code>ConditionalGenericConverter</code></h4><p>有时，您希望 Converter 仅在满足特定条件时才运行。 例如，您可能只想在目标字段上存在特定注释时才运行 Converter，或者可能仅在目标类上定义了特定方法（例如静态 valueOf 方法）时才运行 Converter。 ConditionalGenericConverter 是 GenericConverter 和 ConditionalConverter 接口的联合，可让您定义以下自定义匹配条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span> <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConditionalGenericConverter</code> 的一个很好的例子是 <code>EntityConverter</code>，它在持久实体标识符和实体引用之间进行转换。仅当目标实体类型声明静态查找器方法（例如 <code>findAccount(Long)</code>）时，此类 <code>EntityConverter</code> 才可能匹配。 您可以在 <code>matchs(TypeDescriptor，TypeDescriptor)</code> 的实现中执行这种 finder 方法检查。</p>
<h3 id="ConversionService-API"><a href="#ConversionService-API" class="headerlink" title="ConversionService API"></a><code>ConversionService</code> API</h3><p><code>ConversionService</code> 定义了一个统一的 API，用于在运行时执行类型转换逻辑。转换器通常在以下外观接口后面执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数 <code>ConversionService</code> 实现也都实现 <code>ConverterRegistry</code>，该转换器提供用于注册转换器的 SPI。在内部，<code>ConversionService</code> 实现委派其注册的转换器执行类型转换逻辑。</p>
<p><code>core.convert.support</code> 软件包中提供了一个强大的 <code>ConversionService</code> 实现。 <code>GenericConversionService</code> 是适用于大多数环境的通用实现。<code>ConversionServiceFactory</code> 提供了一个方便的工厂来创建通用的 <code>ConversionService</code> 配置。</p>
<h3 id="注册一个-ConversionService"><a href="#注册一个-ConversionService" class="headerlink" title="注册一个 ConversionService"></a>注册一个 <code>ConversionService</code></h3><p><code>ConversionService</code> 是无状态对象，旨在在应用程序启动时实例化，然后在多个线程之间共享。在 Spring 应用程序中，通常为每个 Spring 容器（或 <code>ApplicationContext</code>）配置一个 <code>ConversionService</code> 实例。当框架需要执行类型转换时，Spring 会调用该 <code>ConversionService</code> 并使用它。 您还可以将此 <code>ConversionService</code> 注入到任何 bean 中，然后直接调用它。</p>
<blockquote>
<p>如果未向 Spring 注册任何 <code>ConversionService</code>，则使用原始的基于 <code>PropertyEditor</code> 的系统。</p>
</blockquote>
<p>要向 Spring 注册默认的 <code>ConversionService</code>，请添加以下 bean 定义，其 id 为 <code>conversionService</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认的 <code>ConversionService</code> 可以在字符串，数字，枚举，集合，映射和其他常见类型之间进行转换。 要用您自己的自定义转换器补充或覆盖默认转换器，请设置 <code>converters</code> 属性。 属性值可以实现 <code>Converter</code>，<code>ConverterFactory</code> 或 <code>GenericConverter</code> 接口中的任何一个。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.MyCustomConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Spring MVC 应用程序中使用 <code>ConversionService</code> 也很常见。 参见 Spring MVC 一章中的转换和格式化。</p>
<p>在某些情况下，您可能希望在转换过程中应用格式设置。 有关使用 <code>FormattingConversionServiceFactoryBean</code> 的详细信息，请参见 <code>FormatterRegistry</code> SPI。</p>
<h3 id="使用-ConversionService-编码"><a href="#使用-ConversionService-编码" class="headerlink" title="使用 ConversionService 编码"></a>使用 ConversionService 编码</h3><p>要以编程方式使用 ConversionService 实例，可以像对其他任何 bean 一样注入对该实例的引用。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService.convert(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于大多数用例，可以使用指定 targetType 的 convert 方法，但不适用于更复杂的类型，例如参数化元素的集合。 例如，如果要以编程方式将整数列表转换为字符串列表，则需要提供源类型和目标类型的正式定义。</p>
<p>幸运的是，如下面的示例所示，TypeDescriptor 提供了各种选项来使操作变得简单明了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultConversionService cs = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; input = ...</span><br><span class="line">cs.convert(input,</span><br><span class="line">    TypeDescriptor.forObject(input), <span class="comment">// List&lt;Integer&gt; type descriptor</span></span><br><span class="line">    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</span><br></pre></td></tr></table></figure>

<p>请注意，<code>DefaultConversionService</code> 自动注册适用于大多数环境的转换器。 这包括集合转换器，标量转换器和基本的对象到字符串转换器。 您可以使用 <code>DefaultConversionService</code> 类上的静态 <code>addDefaultConverters</code> 方法向任何 <code>ConverterRegistry</code> 注册相同的转换器。</p>
<p>值类型的转换器可重用于数组和集合，因此，假设标准的集合处理适当，则无需创建特定的转换器即可将 S 的集合转换为 T 的集合。</p>
<h2 id="Spring-字段格式"><a href="#Spring-字段格式" class="headerlink" title="Spring 字段格式"></a>Spring 字段格式</h2><p>如上一节所述，<code>core.convert</code> 是一种通用类型转换系统。它提供了统一的 <code>ConversionService</code> API 和强类型的 <code>Converter</code> SPI，用于实现从一种类型到另一种类型的转换逻辑。 Spring 容器使用此系统绑定 bean 属性值。此外，Spring Expression Language（SpEL）和 <code>DataBinder</code> 都使用此系统绑定字段值。例如，当 SpEL 需要强制将 <code>Short</code> 转换为 <code>Long</code> 来完成 <code>expression.setValue(Object bean, Object value)</code> 尝试时，<code>core.convert</code> 系统将执行强制转换。</p>
<p>现在考虑典型客户端环境（例如 Web 或桌面应用程序）的类型转换要求。在这样的环境中，您通常会从 <code>String</code> 转换为支持客户端回发过程，然后又转换为 <code>String</code> 以支持视图渲染过程。另外，您通常需要本地化 <code>String</code> 值。更通用的 <code>core.convert</code> <code>Converter</code> SPI 不能直接满足此类格式化要求。为了直接解决这些问题，Spring 3 引入了方便的 <code>Formatter</code> SPI，它为客户端环境提供了 <code>PropertyEditor</code> 实现的简单而强大的替代方案。</p>
<p>通常，当您需要实现通用类型转换逻辑时（例如，用于在 <code>java.util.Date</code> 和 <code>Long</code> 之间进行转换），可以使用 <code>Converter</code> SPI。在客户端环境（例如 Web 应用程序）中工作并且需要解析和打印本地化的字段值时，可以使用 <code>Formatter</code> SPI。 <code>ConversionService</code> 为两个 SPI 提供统一的类型转换 API。</p>
<h3 id="Formatter-SPI"><a href="#Formatter-SPI" class="headerlink" title="Formatter SPI"></a>Formatter SPI</h3><p>用于实现字段格式化逻辑的 <code>Formatter</code> SPI 非常简单且类型严格。 以下清单显示了 <code>Formatter</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Formatter</code> 从 <code>Printer</code> 和 <code>Parser</code> 构建块接口扩展。 以下清单显示了这两个接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">print</span><span class="params">(T fieldValue, Locale locale)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">parse</span><span class="params">(String clientValue, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要创建自己的 <code>Formatter</code>，请实现前面显示的 <code>Formatter</code> 接口。将 T 参数化为您希望格式化的对象的类型（例如 <code>java.util.Date</code>）。实现 <code>print()</code> 操作以打印 T 的实例以在客户端语言环境中显示。实现 <code>parse()</code> 操作，以从客户端语言环境返回的格式化表示形式解析 T 的实例。如果解析尝试失败，则 <code>Formatter</code> 应该抛出 <code>ParseException</code> 或 <code>IllegalArgumentException</code>。注意确保您的 <code>Formatter</code> 实现是线程安全的。</p>
<p><code>format</code> 子包为方便起见提供了几种 <code>Formatter</code> 实现。数字程序包提供 <code>NumberStyleFormatter``，CurrencyStyleFormatter</code> 和 <code>PercentStyleFormatter</code> 来格式化使用 <code>java.text.NumberFormat</code> 的 <code>Number</code> 对象。<code>datetime</code> 包提供了一个 <code>DateFormatter</code>，用于使用 <code>java.text.DateFormat</code> 格式化 <code>java.util.Date</code> 对象。<code>datetime.joda</code> 包基于 Joda-Time 库提供了全面的日期时间格式支持。</p>
<p>以下 <code>DateFormatter</code> 是 <code>Formatter</code> 实现的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format.datetime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateFormatter</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date date, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (date == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat(locale).format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String formatted, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (formatted.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat(locale).parse(formatted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">getDateFormat</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="keyword">this</span>.pattern, locale);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> dateFormat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 团队欢迎社区推动的 <code>Formatter</code> 贡献。 请参阅 GitHub 问题以做出贡献。</p>
<h3 id="注释驱动的格式"><a href="#注释驱动的格式" class="headerlink" title="注释驱动的格式"></a>注释驱动的格式</h3><p>可以通过字段类型或注释配置字段格式。要将注释绑定到 <code>Formatter</code>，请实现 <code>AnnotationFormatterFactory</code>。以下显示了<code>AnnotationFormatterFactory</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</span><br><span class="line"></span><br><span class="line">    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line"></span><br><span class="line">    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要创建一个实现：将 A 参数化为要与格式逻辑关联的字段注解类型，例如 <code>org.springframework.format.annotation.DateTimeFormat</code>。让 <code>getFieldTypes()</code> 返回可在其上使用注释的字段类型。让 <code>getPrinter()</code> 返回 <code>Printer</code> 以打印带注释的字段的值。让 <code>getParser()</code> 返回解析器以解析带注释字段的 <code>clientValue</code>。</p>
<p>以下示例 <code>AnnotationFormatterFactory</code> 实现将 <code>@NumberFormat</code> 批注绑定到格式化程序，以指定数字样式或模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatAnnotationFormatterFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberFormat</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;(asList(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;</span><br><span class="line">            Short.class, Integer.class, Long.class, Float.class,</span><br><span class="line">            Double.class, BigDecimal.class, BigInteger.class &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Printer&lt;Number&gt; <span class="title">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parser&lt;Number&gt; <span class="title">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title">configureFormatterFrom</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!annotation.pattern().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter(annotation.pattern());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Style style = annotation.style();</span><br><span class="line">            <span class="keyword">if</span> (style == Style.PERCENT) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PercentStyleFormatter();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (style == Style.CURRENCY) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CurrencyStyleFormatter();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要触发格式，可以使用 <code>@NumberFormat</code> 注释字段，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NumberFormat</span>(style=Style.CURRENCY)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal decimal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="格式注释-API"><a href="#格式注释-API" class="headerlink" title="格式注释 API"></a>格式注释 API</h4><p><code>org.springframework.format.annotation</code> 包中存在一个可移植的格式注释 API。 您可以使用 <code>@NumberFormat</code> 格式化数字字段（例如 Double 和 Long），并使用 <code>@DateTimeFormat</code> 格式化 <code>java.util.Date</code>，<code>java.util.Calendar</code>，<code>Long</code>（用于毫秒时间戳）以及 JSR-310 <code>java.time</code> 和 Joda-Time 值类型。</p>
<p>以下示例使用 <code>@DateTimeFormat</code> 将 <code>java.util.Date</code> 格式化为 ISO 日期（yyyy-MM-dd）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(iso=ISO.DATE)</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FormatterRegistry-SPI"><a href="#FormatterRegistry-SPI" class="headerlink" title="FormatterRegistry SPI"></a><code>FormatterRegistry</code> SPI</h3><p><code>FormatterRegistry</code> 是用于注册格式器和转换器的 SPI。<code>FormattingConversionService</code> 是适用于大多数环境的 <code>FormatterRegistry</code> 的实现。 您可以通过编程方式或声明方式将此变体配置为 Spring Bean，例如通过使用 <code>FormattingConversionServiceFactoryBean</code>。 由于此实现还实现了 <code>ConversionService</code>，因此您可以直接将其配置为与 Spring 的 <code>DataBinder</code> 和 Spring 表达式语言（SpEL）一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?&gt; factory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前面的清单所示，您可以按字段类型或批注注册格式化程序。</p>
<p><code>FormatterRegistry</code> SPI 使您可以集中配置格式设置规则，而不必在控制器之间复制此类配置。 例如，您可能要强制所有日期字段以某种方式设置格式或带有特定注释的字段以某种方式设置格式。 使用共享的 <code>FormatterRegistry</code>，您可以一次定义这些规则，并在需要格式化时应用它们。</p>
<h3 id="FormatterRegistrar-SPI"><a href="#FormatterRegistrar-SPI" class="headerlink" title="FormatterRegistrar SPI"></a><code>FormatterRegistrar</code> SPI</h3><p><code>FormatterRegistrar</code> 是一个 SPI，用于通过 <code>FormatterRegistry</code> 注册格式器和转换器。 以下清单显示了其接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为给定的格式类别（例如日期格式）注册多个相关的转换器和格式器时，<code>FormatterRegistrar</code> 很有用。 在声明式注册不足的情况下（例如，当格式化程序需要在不同于其自身 <code>&lt;T&gt;</code> 的特定字段类型下建立索引或注册 <code>Printer</code>/<code>Parser</code> 对时），它也很有用。 下一节将提供有关转换器和格式化程序注册的更多信息。</p>
<h3 id="在-Spring-MVC-中配置格式"><a href="#在-Spring-MVC-中配置格式" class="headerlink" title="在 Spring MVC 中配置格式"></a>在 Spring MVC 中配置格式</h3><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-conversion" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-conversion</a></p>
<h3 id="配置全局日期和时间格式"><a href="#配置全局日期和时间格式" class="headerlink" title="配置全局日期和时间格式"></a>配置全局日期和时间格式</h3><p>默认情况下，未使用 <code>@DateTimeFormat</code> 注释的日期和时间字段是使用 <code>DateFormat.SHORT</code> 样式从字符串转换的。 如果愿意，可以通过定义自己的全局格式来更改此设置。</p>
<p>为此，请确保 Spring 不注册默认格式器。 相反，可以借助以下方法手动注册格式化程序：</p>
<ul>
<li><code>org.springframework.format.datetime.standard.DateTimeFormatterRegistrar</code></li>
<li><code>org.springframework.format.datetime.DateFormatterRegistrar</code> 或 joda-Time 的 <code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code>。</li>
</ul>
<p>例如，以下 Java 配置注册全局 yyyyMMdd 格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span></span><br><span class="line">        DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure @NumberFormat is still supported</span></span><br><span class="line">        conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register JSR-310 date conversion with a specific global format</span></span><br><span class="line">        DateTimeFormatterRegistrar registrar = <span class="keyword">new</span> DateTimeFormatterRegistrar();</span><br><span class="line">        registrar.setDateFormatter(DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>));</span><br><span class="line">        registrar.registerFormatters(conversionService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register date conversion with a specific global format</span></span><br><span class="line">        DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();</span><br><span class="line">        registrar.setFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyyMMdd"</span>));</span><br><span class="line">        registrar.registerFormatters(conversionService);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conversionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您喜欢基于 XML 的配置，则可以使用 FormattingConversionServiceFactoryBean。 以下示例显示了如何执行此操作（这次使用 Joda Time）:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">    &lt;bean id="</span><span class="attr">conversionService</span>" <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"registerDefaultFormatters"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.number.NumberFormatAnnotationFormatterFactory"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatterRegistrars"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormatter"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"yyyyMMdd"</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，在 Web 应用程序中配置日期和时间格式时，还有其他注意事项。请参阅 <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/web.html#mvc-config-conversion" target="_blank" rel="noopener">WebMVC 转换和格式</a>或 <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/web-reactive.html#webflux-config-conversion" target="_blank" rel="noopener">WebFlux 转换和格式</a>。</p>
<h2 id="Java-Bean-验证"><a href="#Java-Bean-验证" class="headerlink" title="Java Bean 验证"></a>Java Bean 验证</h2><p>Spring 框架提供了对 <a href="https://beanvalidation.org/" target="_blank" rel="noopener">Java Bean 验证</a> API 的支持。</p>
<h3 id="Bean-验证概述"><a href="#Bean-验证概述" class="headerlink" title="Bean 验证概述"></a>Bean 验证概述</h3><p>Bean 验证为 Java 应用程序提供了通过约束声明和元数据进行验证的通用方法。要使用它，您需要使用声明性验证约束对域模型属性进行注释，然后由运行时强制实施。有内置的约束，您也可以定义自己的自定义约束。</p>
<p>考虑以下示例，该示例显示了具有两个属性的简单 <code>PersonForm</code> 模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean 验证使您可以声明约束，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size</span>(max=<span class="number">64</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，Bean 验证验证器根据声明的约束来验证此类的实例。 有关该 API 的一般信息，请参见 <a href="https://beanvalidation.org/" target="_blank" rel="noopener">Bean 验证</a>。 有关特定限制，请参见 <a href="https://hibernate.org/validator/" target="_blank" rel="noopener">Hibernate Validator 文档</a>。 要学习如何将 bean 验证提供程序设置为 Spring bean，请继续阅读。</p>
<h3 id="配置-Bean-验证提供程序"><a href="#配置-Bean-验证提供程序" class="headerlink" title="配置 Bean 验证提供程序"></a>配置 Bean 验证提供程序</h3><p>Spring 提供了对 Bean 验证 API 的全面支持，包括将 Bean 验证提供程序作为 Spring Bean 进行引导。 这使您可以在应用程序中需要验证的任何地方注入 <code>javax.validation.ValidatorFactory</code> 或 <code>javax.validation.Validator</code>。</p>
<p>您可以使用 <code>LocalValidatorFactoryBean</code> 将默认的 <code>Validator</code> 配置为 Spring Bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalValidatorFactoryBean <span class="title">validator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalValidatorFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面示例中的基本配置触发 Bean 验证以使用其默认引导机制进行初始化。 Bean 验证提供程序，例如 Hibernate Validator，应该存在于类路径中并被自动检测到。</p>
<h4 id="注入验证器"><a href="#注入验证器" class="headerlink" title="注入验证器"></a>注入验证器</h4><p><code>LocalValidatorFactoryBean</code> 同时实现 <code>javax.validation.ValidatorFactory</code> 和 <code>javax.validation.Validator</code> 以及 Spring 的 <code>org.springframework.validation.Validator</code>。 您可以将对这些接口之一的引用注入需要调用验证逻辑的 bean 中。</p>
<p>如果您希望直接使用 Bean Validation API，则可以注入对 <code>javax.validation.Validator</code> 的引用，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您的 bean 需要使用 Spring Validation API，则可以注入对 <code>org.springframework.validation.Validator</code> 的引用，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置自定义约束"><a href="#配置自定义约束" class="headerlink" title="配置自定义约束"></a>配置自定义约束</h4><p>每个 bean 验证约束都包括两个部分：</p>
<p><code>@Constraint</code> 批注，用于声明约束及其可配置属性。</p>
<p><code>javax.validation.ConstraintValidator</code> 接口的实现，用于实现约束的行为。</p>
<p>要将声明与实现相关联，每个 <code>@Constraint</code> 批注都引用一个对应的 <code>ConstraintValidator</code> 实现类。 在运行时，当在域模型中遇到约束注释时，<code>ConstraintValidatorFactory</code>实例化引用的实现。</p>
<p>默认情况下，<code>LocalValidatorFactoryBean</code> 配置一个 <code>SpringConstraintValidatorFactory</code>，该工厂使用 Spring 创建 <code>ConstraintValidator</code> 实例。 这使您的自定义 <code>ConstraintValidators</code> 像其他任何 Spring bean 一样受益于依赖项注入。</p>
<p>以下示例显示了一个自定义 <code>@Constraint</code> 声明，后跟一个关联的 <code>ConstraintValidator</code> 实现，该实现使用 Spring 进行依赖项注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy=MyConstraintValidator.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyConstraint &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>;</span><br><span class="line">    <span class="keyword">private</span> Foo aDependency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前面的示例所示，<code>ConstraintValidator</code> 实现可以像其他任何 Spring bean 一样具有其 <code>@Autowired</code> 依赖项。</p>
<h4 id="Spring-驱动方法验证"><a href="#Spring-驱动方法验证" class="headerlink" title="Spring 驱动方法验证"></a>Spring 驱动方法验证</h4><p>您可以通过 <code>MethodValidationPostProcessor</code> bean 定义将 Bean Validation 1.1（以及作为自定义扩展，还包括 Hibernate Validator 4.3）支持的方法验证功能集成到 Spring 上下文中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.MethodValidationPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodValidationPostProcessor <span class="title">validationPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodValidationPostProcessor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了有资格进行 Spring 驱动的方法验证，所有目标类都必须使用 Spring 的 <code>@Validated</code> 注释进行注释，该注释也可以选择声明要使用的验证组。 有关使用 Hibernate Validator 和 Bean Validation 1.1 提供程序的设置详细信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/5.3.0-SNAPSHOT/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html" target="_blank" rel="noopener"><code>MethodValidationPostProcessor</code></a>。</p>
<blockquote>
<p>方法验证依赖于目标类周围的 AOP 代理，即接口上方法的 JDK 动态代理或 CGLIB 代理。 代理的使用存在某些限制，<a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#aop-understanding-aop-proxies" target="_blank" rel="noopener">《了解 AOP 代理》</a> 中介绍了其中的一些限制。 另外，请记住在代理类上始终使用方法和访问器；直接现场字段将不起作用。</p>
</blockquote>
<h4 id="其他配置选项"><a href="#其他配置选项" class="headerlink" title="其他配置选项"></a>其他配置选项</h4><p>在大多数情况下，默认 <code>LocalValidatorFactoryBean</code> 配置就足够了。 从消息插值到遍历解析，有许多用于各种 Bean 验证构造的配置选项。 有关这些选项的更多信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/5.3.0-SNAPSHOT/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html" target="_blank" rel="noopener"><code>LocalValidatorFactoryBean</code> Javadoc</a>。</p>
<h3 id="注册一个-DataBinder"><a href="#注册一个-DataBinder" class="headerlink" title="注册一个 DataBinder"></a>注册一个 <code>DataBinder</code></h3><p>从 Spring 3 开始，您可以使用 Validator 配置 <code>DataBinder</code> 实例。 配置完成后，您可以通过调用 <code>binder.validate()</code> 来调用 <code>Validator</code>。任何验证 <code>Errors</code> 都会自动添加到活页夹的 <code>BindingResult</code> 中。</p>
<p>下面的示例演示如何在绑定到目标对象后，以编程方式使用 <code>DataBinder</code> 来调用验证逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Foo target = <span class="keyword">new</span> Foo();</span><br><span class="line">DataBinder binder = <span class="keyword">new</span> DataBinder(target);</span><br><span class="line">binder.setValidator(<span class="keyword">new</span> FooValidator());</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind to the target object</span></span><br><span class="line">binder.bind(propertyValues);</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the target object</span></span><br><span class="line">binder.validate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// get BindingResult that includes any validation errors</span></span><br><span class="line">BindingResult results = binder.getBindingResult();</span><br></pre></td></tr></table></figure>

<p>您还可以通过 <code>dataBinder.addValidators</code> 和 <code>dataBinder.replaceValidators</code> 配置具有多个 <code>Validator</code> 实例的 <code>DataBinder</code>。当将全局配置的 bean 验证与在 <code>DataBinder</code> 实例上本地配置的 Spring Validator 结合使用时，这很有用。 请参阅 <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/web.html#mvc-config-validation" target="_blank" rel="noopener">Spring MVC 验证配置</a>。</p>
<h3 id="Spring-MVC-3-Validation"><a href="#Spring-MVC-3-Validation" class="headerlink" title="Spring MVC 3 Validation"></a>Spring MVC 3 Validation</h3><p>参见 <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/web.html#mvc-config-validation" target="_blank" rel="noopener">Spring MVC 中的验证</a>。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring进阶 - 资源]]></title>
      <url>https://HaleLu.github.io/2020/05/spring-3/</url>
      <content type="html"><![CDATA[<p>书接<a href="https://halelu.github.io/2020/04/spring-2/">上文</a></p>
<p>接下来到 Spring framework core 的第二大块 —— 资源</p>
<a id="more"></a>

<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>本章介绍了 Spring 如何处理资源以及如何在 Spring 中使用资源。它包括以下主题：</p>
<ul>
<li>介绍</li>
<li>Resource 接口</li>
<li>内置 Resource 实现</li>
<li>ResourceLoader</li>
<li><code>ResourceLoaderAware</code> 接口</li>
<li>资源依赖</li>
<li>应用程序上下文和资源路径</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>不幸的是，Java 的标准 <code>java.net.URL</code> 类和用于各种 URL 前缀的标准处理程序不足以满足所有对低级资源的访问。例如，没有标准化的 <code>URL</code> 实现可用于访问需要从类路径或相对于 <code>ServletContext</code> 获得的资源。 虽然可以注册用于特殊 <code>URL</code> 前缀的新处理程序（类似于用于诸如 <code>http:</code> 的现有前缀的处理程序），但这通常相当复杂，并且 <code>URL</code> 接口仍然缺少某些理想的功能，例如用于检查是否存在的方法指向的资源。</p>
<h2 id="Resource-接口"><a href="#Resource-接口" class="headerlink" title="Resource 接口"></a>Resource 接口</h2><p>Spring 的 <code>Resource</code> 接口旨在成为一种功能更强大的接口，用于抽象化对低级资源的访问。以下清单显示了 <code>Resource</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 <code>Resource</code> 接口的定义所示，它扩展了 <code>InputStreamSource</code> 接口。以下清单显示了 <code>InputStreamSource</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Resource 接口中一些最重要的方法是：</p>
<ul>
<li><code>getInputStream()</code>：找到并打开资源，返回一个 <code>InputStream</code> 以便从资源中读取。预期每次调用都返回一个新的 <code>InputStream</code>。调用方有责任关闭流。</li>
<li><code>exist()</code>：返回一个布尔值，指示此资源是否实际以物理形式存在。</li>
<li><code>isOpen()</code>：返回一个布尔值，指示此资源是否表示具有打开流的句柄。如果为 true，则不能多次读取 <code>InputStream</code>，必须只读取一次，然后将其关闭以避免资源泄漏。对于所有常规资源实现，返回 <code>false</code>，但 <code>InputStreamResource</code> 除外。</li>
<li><code>getDescription()</code>：返回对此资源的描述，用于在处理资源时用于错误输出。这通常是标准文件名或资源的实际 URL。</li>
</ul>
<p>其他方法可让您获取代表资源的实际 <code>URL</code> 或 <code>File</code> 对象（如果基础实现兼容并且支持该功能）。</p>
<p>当需要资源时，Spring 本身广泛使用 <code>Resource</code> 抽象作为许多方法签名中的参数类型。一些 Spring API 中的其他方法（例如，各种 <code>ApplicationContext</code> 实现的构造函数）采用 String 形式，该字符串以未经修饰或简单的形式用于创建适合该上下文实现的 <code>Resource</code>，或者通过 String 路径上的特殊前缀，让调用者指定必须创建并使用特定的资源实现。</p>
<p>尽管 Spring 经常使用 <code>Resource</code> 接口，但实际上，在您自己的代码中单独用作通用实用工具类来访问资源也非常有用，即使您的代码不了解也不关心 Spring 的其他任何部分。虽然这将您的代码耦合到 Spring，但实际上仅将其耦合到这套实用程序类，它们充当 <code>URL</code> 的更强大替代，并且可以被视为等同于您将用于此目的的任何其他库。</p>
<blockquote>
<p><code>Resource</code> 抽象不能替代功能。它尽可能地包装它。例如，<code>UrlResource</code> 包装一个 <code>URL</code>，然后使用包装的 <code>URL</code> 进行工作。</p>
</blockquote>
<h2 id="内置-Resource-实现"><a href="#内置-Resource-实现" class="headerlink" title="内置 Resource 实现"></a>内置 Resource 实现</h2><p>Spring 包含以下 Resource 实现：</p>
<ul>
<li>UrlResource</li>
<li>ClassPathResource</li>
<li>FileSystemResource</li>
<li>ServletContextResource</li>
<li>InputStreamResource</li>
<li>ByteArrayResource</li>
</ul>
<h3 id="UrlResource"><a href="#UrlResource" class="headerlink" title="UrlResource"></a>UrlResource</h3><p><code>UrlResource</code> 包装了 <code>java.net.URL</code>，可用于访问通常可以通过 URL 访问的任何对象，例如文件、HTTP 目标、FTP 目标等。所有 URL 都具有标准化的 String 表示形式，因此使用适当的标准化前缀来指示另一种 URL 类型。其中包括 <code>file:</code> 用于访问文件系统路径，<code>http:</code> 用于通过 HTTP 协议访问资源，<code>ftp:</code> 用于通过 FTP 访问资源等。</p>
<p><code>UrlResource</code> 是由 Java 代码通过显式使用 <code>UrlResource</code> 构造函数创建的，但通常在调用带有 String 参数表示路径的 API 方法时隐式创建。对于后一种情况，JavaBeans <code>PropertyEditor</code> 最终决定要创建哪种类型的资源。如果路径字符串包含众所周知的前缀（例如 <code>classpath:</code>），则它将为该前缀创建适当的专用资源。但是，如果它不能识别前缀，则假定该字符串是标准 URL 字符串并创建一个 <code>UrlResource</code>。</p>
<h3 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h3><p>此类表示应从类路径获取的资源。它使用线程上下文类加载器，给定的类加载器或给定的类来加载资源。</p>
<p>如果类路径资源驻留在文件系统中，而不是驻留在 jar 中并且尚未（通过 servlet 引擎或任何环境将其扩展到）文件系统的类路径资源驻留在文件系统中，则此 <code>Resource</code> 实现以 <code>java.io.File</code> 支持解析。 。为了解决这个问题，各种 <code>Resource</code> 实现始终支持将解析作为 <code>java.net.URL</code>。</p>
<p>Java 代码通过显式使用 <code>ClassPathResource</code> 构造函数来创建 <code>ClassPathResource</code>，但通常在调用带有 String 参数表示路径的 API 方法时隐式创建 <code>ClassPathResource</code>。对于后一种情况，JavaBeans PropertyEditor 可以识别字符串路径上的特殊前缀 <code>classpath:</code>，并在这种情况下创建 <code>ClassPathResource</code>。</p>
<h3 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h3><p>这是 <code>java.io.File</code> 和 <code>java.nio.file.Path</code> 句柄的 <code>Resource</code> 实现。它支持解析为 <code>File</code> 和 <code>URL</code>。</p>
<h3 id="ServletContextResource"><a href="#ServletContextResource" class="headerlink" title="ServletContextResource"></a>ServletContextResource</h3><p>这是 <code>ServletContext</code> 资源的 <code>Resource</code> 实现，它解释相关 Web 应用程序根目录中的相对路径。</p>
<p>它始终支持流访问和 URL 访问，但仅在扩展 Web 应用程序档案且资源实际位于文件系统上时才允许 java.io.File 访问。它是在文件系统上扩展还是直接扩展，或者直接从 JAR 或其他类似数据库（可以想到的）中访问，实际上取决于 Servlet 容器。</p>
<h3 id="InputStreamResource"><a href="#InputStreamResource" class="headerlink" title="InputStreamResource"></a>InputStreamResource</h3><p><code>InputStreamResource</code> 是给定 <code>InputStream</code> 的 <code>Resource</code> 实现。仅当没有特定的资源实现适用时才应使用它。特别是，在可能的情况下，最好选择 <code>ByteArrayResource</code> 或任何基于文件的 <code>Resource</code> 实现。</p>
<p>与其他 <code>Resource</code> 实现相反，这是一个已经打开的资源的描述符。因此，它从 <code>isOpen()</code> 返回 true。如果需要将资源描述符保留在某个地方，或者需要多次读取流，请不要使用它。</p>
<h3 id="ByteArrayResource"><a href="#ByteArrayResource" class="headerlink" title="ByteArrayResource"></a>ByteArrayResource</h3><p>这是给定字节数组的 <code>Resource</code> 实现。它为给定的字节数组创建一个 <code>ByteArrayInputStream</code>。</p>
<p>这对于从任何给定的字节数组加载内容很有用，而不必求助于一次性的 <code>InputStreamResource</code>。</p>
<h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p><code>ResourceLoader</code> 接口旨在由可以返回（即加载）<code>Resource</code> 实例的对象实现。以下显示了 <code>ResourceLoader</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有应用程序上下文均实现该 <code>ResourceLoader</code> 接口。因此，所有应用程序上下文都可用于获取 <code>Resource</code> 实例。</p>
<p>当您调用 <code>getResource()</code> 特定的应用程序上下文时，并且指定的位置路径没有特定的前缀时，您将获得 <code>Resource</code> 适合该特定应用程序上下文的类型。例如，假定针对 <code>ClassPathXmlApplicationContext</code> 实例执行了以下代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource template = ctx.getResource(<span class="string">"some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>针对 <code>ClassPathXmlApplicationContext</code>，该代码返回 <code>ClassPathResource</code>。如果对 <code>FileSystemXmlApplicationContext</code> 实例执行相同的方法，则将返回 <code>FileSystemResource</code>。对于 <code>WebApplicationContext</code>，它将返回 <code>ServletContextResource</code>。类似地，它将为每个上下文返回适当的对象。</p>
<p>所以，您可以以适合特定应用程序上下文的方式加载资源。</p>
<p>另一方面，<code>ClassPathResource</code> 无论应用程序上下文类型如何，您都可以通过指定特殊 <code>classpath:</code> 前缀来强制使用，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource template = ctx.getResource(<span class="string">"classpath:some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>同样，您可以通过指定任何标准 <code>java.net.URL</code> 前缀来强制使用 <code>UrlResource</code>。 以下两个示例使用 <code>file</code> 和 <code>http</code> 前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource template = ctx.getResource(<span class="string">"file:///some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource template = ctx.getResource(<span class="string">"https://myhost.com/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>下表总结了将 String 对象转换为 Resource 对象的策略：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>举例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:</td>
<td>classpath:com/myapp/config.xml</td>
<td>从类路径加载。</td>
</tr>
<tr>
<td>file:</td>
<td>file:///data/config.xml</td>
<td>从文件系统作为<code>URL</code>加载。另请参见 <code>FileSystemResource 警告</code>。</td>
</tr>
<tr>
<td>http:</td>
<td><a href="https://myserver/logo.png" target="_blank" rel="noopener">https://myserver/logo.png</a></td>
<td>加载为 <code>URL</code>。</td>
</tr>
<tr>
<td>（无）</td>
<td>/data/config.xml</td>
<td>取决于基础 ApplicationContext。</td>
</tr>
</tbody></table>
<h2 id="ResourceLoaderAware-接口"><a href="#ResourceLoaderAware-接口" class="headerlink" title="ResourceLoaderAware 接口"></a><code>ResourceLoaderAware</code> 接口</h2><p><code>ResourceLoaderAware</code> 接口是一个特殊的回调接口，用于标识期望提供 <code>ResourceLoader</code> 引用的组件。 以下显示了 <code>ResourceLoaderAware</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个类实现 <code>ResourceLoaderAware</code> 并部署到应用程序上下文中（作为 Spring 托管的 bean）时，该类被应用程序上下文识别为 <code>ResourceLoaderAware</code>。然后，应用程序上下文调用 <code>setResourceLoader(ResourceLoader)</code>，将自身作为参数提供（请记住，Spring 中的所有应用程序上下文均实现 <code>ResourceLoader</code> 接口）。</p>
<p>由于 <code>ApplicationContext</code> 是 <code>ResourceLoader，因此</code> Bean 也可以实现 <code>ApplicationContextAware</code> 接口，并直接使用提供的应用程序上下文来加载资源。但是，通常，如果需要的话，最好使用专用的 <code>ResourceLoader</code> 接口。该代码将仅耦合到资源加载接口（可以视为实用程序接口），而不耦合到整个 Spring <code>ApplicationContext</code> 接口。</p>
<p>在应用程序组件中，您还可以依靠自动装配 <code>ResourceLoader</code> 来实现 <code>ResourceLoaderAware</code> 接口。“传统”构造函数和 byType 自动装配模式（如“自动装配协作器”中所述）能够分别为构造函数参数或 setter 方法参数提供 <code>ResourceLoader</code>。为了获得更大的灵活性（包括自动装配字段和多个参数方法的能力），请考虑使用基于注释的自动装配功能。在这种情况下，只要有问题的字段，构造函数或方法带有 <code>@Autowired</code> 批注，<code>ResourceLoader</code> 就会自动连接到需要 <code>ResourceLoader</code> 类型的字段，构造函数参数或方法参数中。有关更多信息，请参见前文。</p>
<h2 id="资源依赖"><a href="#资源依赖" class="headerlink" title="资源依赖"></a>资源依赖</h2><p>如果 Bean 本身将通过某种动态过程来确定和提供资源路径，那么对于 Bean 来说，使用 <code>ResourceLoader</code> 接口加载资源可能是有意义的。例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。如果资源是静态的，则有必要完全消除对 <code>ResourceLoader</code> 接口的使用，让 Bean 公开所需的 <code>Resource</code> 属性，并期望将其注入其中。</p>
<p>然后注入这些属性的琐事是，所有应用程序上下文都注册并使用了特殊的 JavaBeans PropertyEditor，它可以将 String 路径转换为 <code>Resource</code> 对象。 因此，如果 myBean 具有资源类型的模板属性，则可以为该资源配置一个简单的字符串，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"template"</span> <span class="attr">value</span>=<span class="string">"some/resource/path/myTemplate.txt"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，资源路径没有前缀。因此，由于应用程序上下文本身将用作 <code>ResourceLoader</code>，因此根据上下文的确切类型，通过 <code>ClassPathResource</code>，<code>FileSystemResource</code> 或 <code>ServletContextResource</code> 加载资源本身。</p>
<p>如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示了如何强制 <code>ClassPathResource</code> 和 <code>UrlResource</code>（后者用于访问文件系统文件）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"template"</span> <span class="attr">value</span>=<span class="string">"classpath:some/resource/path/myTemplate.txt"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"template"</span> <span class="attr">value</span>=<span class="string">"file:///some/resource/path/myTemplate.txt"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="应用程序上下文和资源路径"><a href="#应用程序上下文和资源路径" class="headerlink" title="应用程序上下文和资源路径"></a>应用程序上下文和资源路径</h2><p>本节介绍如何使用资源创建应用程序上下文，包括使用 XML 的快捷方式，如何使用通配符以及其他详细信息。</p>
<h3 id="构造应用程序上下文"><a href="#构造应用程序上下文" class="headerlink" title="构造应用程序上下文"></a>构造应用程序上下文</h3><p>应用程序上下文构造函数（针对特定的应用程序上下文类型）通常采用字符串或字符串数 ​​ 组作为资源的位置路径，例如构成上下文定义的 XML 文件。</p>
<p>当这样的位置路径没有前缀时，从该路径构建并用于加载 Bean 定义的特定 <code>Resource</code> 类型取决于特定应用程序上下文，并且适用于该特定应用程序上下文。 例如，考虑以下示例，该示例创建一个 <code>ClassPathXmlApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"conf/appContext.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>由于使用了 <code>ClassPathResource</code>，因此从类路径中加载了 Bean 定义。 但是，请考虑以下示例，该示例创建一个 <code>FileSystemXmlApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"conf/appContext.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>现在，bean 定义是从文件系统位置（在这种情况下，是相对于当前工作目录）加载的。</p>
<p>请注意，在位置路径上使用特殊的类路径前缀或标准 URL 前缀会覆盖为加载定义而创建的默认资源类型。 考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:conf/appContext.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>使用 <code>FileSystemXmlApplicationContext</code> 从类路径加载 bean 定义。 但是，它仍然是 <code>FileSystemXmlApplicationContext</code>。 如果随后将其用作 <code>ResourceLoader</code>，则任何未前缀的路径仍将视为文件系统路径。</p>
<h4 id="构造-ClassPathXmlApplicationContext-实例-——-快捷方式"><a href="#构造-ClassPathXmlApplicationContext-实例-——-快捷方式" class="headerlink" title="构造 ClassPathXmlApplicationContext 实例 —— 快捷方式"></a>构造 <code>ClassPathXmlApplicationContext</code> 实例 —— 快捷方式</h4><p><code>ClassPathXmlApplicationContext</code> 公开了许多构造函数以启用方便的实例化。基本思想是，您只能提供一个字符串数组，该字符串数组仅包含 XML 文件本身的文件名（不包含前导路径信息），并且还提供一个 Class。然后，<code>ClassPathXmlApplicationContext</code> 从提供的类中派生路径信息。</p>
<p>请考虑以下目录布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com/</span><br><span class="line">  foo/</span><br><span class="line">    services.xml</span><br><span class="line">    daos.xml</span><br><span class="line">    MessengerService.class</span><br></pre></td></tr></table></figure>

<p>以下示例显示如何实例化由在名为 <code>service.xml</code> 和 <code>daos.xml</code>（位于类路径中）的文件中定义的 bean 组成的 <code>ClassPathXmlApplicationContext</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">    <span class="keyword">new</span> String[] &#123;<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>&#125;, MessengerService.class);</span><br></pre></td></tr></table></figure>

<p>有关各种构造函数的详细信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html" target="_blank" rel="noopener"><code>ClassPathXmlApplicationContext</code> javadoc</a>。</p>
<h3 id="应用程序上下文构造函数资源路径中的通配符"><a href="#应用程序上下文构造函数资源路径中的通配符" class="headerlink" title="应用程序上下文构造函数资源路径中的通配符"></a>应用程序上下文构造函数资源路径中的通配符</h3><p>应用程序上下文构造函数值中的资源路径可以是简单路径（如先前所示），每个路径都具有到目标资源的一对一映射，或者可以包含特殊的<code>classpath*:</code>前缀或内部 Ant 样式的正则表达式（通过使用 Spring 的 <code>PathMatcher</code> 实用程序进行匹配）。后者都是有效的通配符。</p>
<p>这种机制的一种用途是当您需要进行组件样式的应用程序组装时。所有组件都可以将上下文定义片段“发布”到一个众所周知的位置路径，并且当使用前缀为 <code>classpath*:</code> 的相同路径创建最终应用程序上下文时，所有组件片段都会被自动拾取。</p>
<p>请注意，此通配符特定于在应用程序上下文构造函数中使用资源路径（或当您直接使用 <code>PathMatcher</code> 实用工具类层次结构时），并且在构造时已解决。它与资源类型本身无关。您不能使用 <code>classpath*:</code> 前缀来构造实际的 <code>Resource</code>，因为资源一次仅指向一个资源。</p>
<h4 id="Ant-风格模式"><a href="#Ant-风格模式" class="headerlink" title="Ant 风格模式"></a>Ant 风格模式</h4><p>路径位置可以包含 Ant 样式的模式，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/WEB-INF/*-context.xml</span><br><span class="line">com/mycompany/**/applicationContext.xml</span><br><span class="line">file:C:/some/path/*-context.xml</span><br><span class="line">classpath:com/mycompany/**/applicationContext.xml</span><br></pre></td></tr></table></figure>

<p>当路径位置包含 Ant 样式的模式时，解析程序将遵循更复杂的过程来尝试解析通配符。 它为到达最后一个非通配符段的路径生成资源，并从中获取 URL。 如果此 URL 不是 <code>jar:</code> URL 或特定于容器的变体（例如 WebLogic 中的 <code>zip:</code> ，WebSphere 中的 <code>wsjar</code> 等），则从中获取 <code>java.io.File</code> 并将其用于遍历文件系统。 对于 jar URL，解析器可以从中获取 <code>java.net.JarURLConnection</code>，也可以手动解析 jar URL，然后遍历 jar 文件的内容以解析通配符。</p>
<h5 id="对可移植性的影响"><a href="#对可移植性的影响" class="headerlink" title="对可移植性的影响"></a>对可移植性的影响</h5><p>如果指定的路径已经是一个文件 URL（由于基本 <code>ResourceLoader</code> 是一个文件系统，所以它是隐式的，或者是显式的），则保证通配符可以完全可移植的方式工作。</p>
<p>如果指定的路径是类路径位置，则解析器必须通过调用 <code>Classloader.getResource()</code>获得最后的非通配符路径段 URL。由于这只是路径的一个节点（而不是末尾的文件），因此实际上（在 <code>ClassLoader</code> javadoc 中）未定义确切返回的是哪种 URL。实际上，它始终是代表目录的 <code>java.io.File</code>（类路径资源在其中解析到文件系统位置）或某种 jar URL（类路径资源在 jar 上解析）。尽管如此，此操作仍存在可移植性问题。</p>
<p>如果为最后一个非通配符段获取了 jar URL，则解析程序必须能够从中获取 <code>java.net.JarURLConnection</code> 或手动解析 jar URL，以便能够遍历 jar 的内容并解析通配符。这在大多数环境中确实有效，但在其他环境中则无效，因此我们强烈建议您在依赖特定环境之前，对来自 jars 的资源的通配符解析进行彻底测试。</p>
<h4 id="classpath-前缀"><a href="#classpath-前缀" class="headerlink" title="classpath*: 前缀"></a><code>classpath*:</code> 前缀</h4><p>在构造基于 XML 的应用程序上下文时，位置字符串可以使用特殊的 <code>classpath*:</code> 前缀，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath*:conf/appContext.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>这个特殊的前缀指定必须获取与给定名称匹配的所有类路径资源（内部其实是通过调用 <code>ClassLoader.getResources(…)</code> 完成的），然后合并形成最终的应用程序上下文定义。</p>
<p>通配符类路径依赖于基础类加载器的 <code>getResources()</code> 方法。 由于当今大多数应用程序服务器都提供自己的类加载器实现，因此行为可能有所不同，尤其是在处理 jar 文件时。 检查 <code>classpath*</code> 是否有效的一个简单测试是使用 <code>classloader</code> 从 classpath 的 jar 中加载文件：<code>getClass().getClassLoader().getResources(&quot;&lt;someFileInsideTheJar&gt;&quot;)</code>。 尝试对具有相同名称但位于两个不同位置的文件进行此测试。如果返回了不合适的结果，请检查应用程序服务器文档中可能会影响类加载器行为的设置。</p>
<p>您还可以在其余位置路径中将 <code>classpath*:</code>前缀与 <code>PathMatcher</code> 模式结合使用（例如，<code>classpath*:META-INF/*-beans.xml</code>）。在这种情况下，解析策略非常简单：在最后一个非通配符路径段上使用 <code>ClassLoader.getResources()</code> 调用，以获取类加载器层次结构中的所有匹配资源，然后从每个资源获取相同的 <code>PathMatcher</code> 解析 前面描述的策略用于通配符子路径。</p>
<h4 id="有关通配符的其他说明"><a href="#有关通配符的其他说明" class="headerlink" title="有关通配符的其他说明"></a>有关通配符的其他说明</h4><p>请注意，当 <code>classpath*:</code> 与 Ant 样式的模式结合使用时，除非模式文件实际驻留在文件系统中，否则在模式启动之前，它只能与至少一个根目录可靠地一起工作。这意味着诸如 <code>classpath*:*.xml</code> 之类的模式可能不会从 jar 文件的根目录检索文件，而只会从扩展目录的根目录检索文件。</p>
<p>Spring 检索类路径条目的能力源自 JDK 的 <code>ClassLoader.getResources()</code> 方法，该方法仅返回文件系统中的空字符串位置（指示可能要搜索的根目录）。 Spring 还会评估 jar 文件中的 <code>URLClassLoader</code> 运行时配置和 <code>java.class.path</code> 清单，但这不能保证会导致可移植行为。</p>
<blockquote>
<p>扫描类路径包需要在类路径中存在相应的目录条目。使用 Ant 构建 JAR 时，请勿激活 JAR 任务的仅文件开关。此外，在某些环境中，基于安全策略，可能不会公开类路径目录-例如，在 JDK 1.7.0_45 及更高版本上的独立应用程序（要求在清单中设置“受信任的库”。请参阅 <a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources）。" target="_blank" rel="noopener">https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources）。</a></p>
<p>在 JDK 9 的模块路径（Jigsaw）上，Spring 的类路径扫描通常可以正常进行。强烈建议在此处将资源放入专用目录，以避免在搜索 jar 文件根目录级别时出现上述可移植性问题。</p>
</blockquote>
<p>具有 <code>classpath:</code> 的 Ant 样式模式要搜索的根包如果在多个类路径位置可用，则不能保证资源找到匹配的资源。考虑以下资源位置示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com/mycompany/package1/service-context.xml</span><br></pre></td></tr></table></figure>

<p>现在考虑某人可能用来尝试找到该文件的 Ant 样式的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath:com/mycompany/**/service-context.xml</span><br></pre></td></tr></table></figure>

<p>这样的资源可能只在一个位置，但是当使用诸如上一示例的路径尝试对其进行解析时，解析器将处理 <code>getResource(&quot;com/mycompany&quot;);</code> 返回的（第一个）URL。如果此基本包节点存在于多个类加载器位置，则实际的最终资源可能不存在。因此，在这种情况下，您应该首选使用具有相同 Ant 样式模式的 <code>classpath*:</code>，该模式将搜索包含根包的所有类路径位置。</p>
<h3 id="FileSystemResource-警告"><a href="#FileSystemResource-警告" class="headerlink" title="FileSystemResource 警告"></a><code>FileSystemResource</code> 警告</h3><p>未附加到 <code>FileSystemApplicationContext</code> 的 <code>FileSystemResource</code>（即，当 <code>FileSystemApplicationContext</code> 不是实际的 <code>ResourceLoader</code> 时）将按您期望的方式处理绝对路径和相对路径。相对路径是相对于当前工作目录的，而绝对路径是相对于文件系统的根的。</p>
<p>但是，出于向后兼容性（历史）的原因，当 <code>FileSystemApplicationContext</code> 是 <code>ResourceLoader</code> 时，此情况会更改。<code>FileSystemApplicationContext</code> 强制所有附加的 <code>FileSystemResource</code> 实例将所有位置路径都视为相对位置，无论它们是否以前斜杠开头。 实际上，这意味着以下示例是等效的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>以下示例也是等效的（尽管使它们有所不同是有意义的，因为一种情况是相对的，另一种情况是绝对的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileSystemXmlApplicationContext ctx = ...;</span><br><span class="line">ctx.getResource(<span class="string">"some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileSystemXmlApplicationContext ctx = ...;</span><br><span class="line">ctx.getResource(<span class="string">"/some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>在实践中，如果需要真正的绝对文件系统路径，则应避免将绝对路径与 <code>FileSystemResource</code> 或 <code>FileSystemXmlApplicationContext</code> 一起使用，并通过使用 <code>file:</code> URL 前缀来强制使用 <code>UrlResource</code>。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actual context type doesn't matter, the Resource will always be UrlResource</span></span><br><span class="line">ctx.getResource(<span class="string">"file:///some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource</span></span><br><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"file:///conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring进阶 - IoC容器(2)]]></title>
      <url>https://HaleLu.github.io/2020/04/spring-2/</url>
      <content type="html"><![CDATA[<p>书接<a href="https://halelu.github.io/2020/02/spring-1/">上文</a></p>
<a id="more"></a>

<h2 id="自定义-bean-的行为-Nature"><a href="#自定义-bean-的行为-Nature" class="headerlink" title="自定义 bean 的行为(Nature)"></a>自定义 bean 的行为(Nature)</h2><p>Spring Framework 提供了许多可用于自定义 bean 行为的接口。依次讲这三种接口：</p>
<h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>想要介入容器的 bean 生命周期管理，可以实现 Spring InitializingBean 和 DisposableBean 接口。前者调用 afterPropertiesSet()初始化，后者调用 destroy() 销毁 ​​bean 。</p>
<p>JSR-250 规范中的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注释通常被认为是在现代 Spring 应用程序中接收生命周期回调的最佳实践。使用这些注释可以使 bean 解耦于这些 Spring 的接口。详见下文。</p>
<p>如果不想使用 JSR-250 规范的注释但仍想解耦，可以使用 init-method 和 destroy-method。</p>
<p>在内部，Spring Framework 使用 BeanPostProcessor 实现来处理它可以找到的任何回调接口并调用对应的方法。如果需要自定义其他 Spring 默认不提供的功能或生命周期行为，可以 BeanPostProcessor 自己实现。</p>
<p>除了初始化和销毁 ​​ 回调之外，Spring 管理的对象还可以实现 Lifecycle 接口，以便这些对象可以参与启动和关闭过程，这是由容器自身的生命周期驱动的。</p>
<p>接下来讲生命周期回调接口。</p>
<h4 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h4><p>org.springframework.beans.factory.InitializingBean 接口允许在容器设置 bean 的所有必要属性后进行初始化工作。InitializingBean 接口规定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>当然，上文说了，并不推荐使用 InitializingBean 接口，更好的做法是使用 <code>@PostConstruct</code> 方法或者指定 POJO 初始化方法。可以使用 XML 中的 init-method 属性或者 <code>@Bean</code> 注解的 initMethod 指定一个返回 void 且无参的方法作为初始化方法。</p>
<h4 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h4><p>对应的 org.springframework.beans.factory.DisposableBean 接口规定了一个销毁前执行的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>同理，建议 <code>@PreDestroy</code> 和 destroy-method 的 XML 配置或 <code>@Bean</code> 的 destroyMethod 属性。</p>
<h4 id="默认初始化和析构方法"><a href="#默认初始化和析构方法" class="headerlink" title="默认初始化和析构方法"></a>默认初始化和析构方法</h4><p>你可以将所有的初始化、销毁的方法使用相同的命名（比如 init、initialize、dispose 等），那么就可以定义默认初始化和析构方法。</p>
<p>举例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blogService"</span> <span class="attr">class</span>=<span class="string">"com.something.DefaultBlogService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogDao"</span> <span class="attr">ref</span>=<span class="string">"blogDao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 容器保证在为 bean 提供所有依赖项后立即调用已配置的初始化回调，所以初始化回调会在 AOP 作用之前。首先完全创建 bean，然后配置带有拦截器链的 AOP 代理。所以在 init 方法上使用拦截器可能会导致和预想不一致，因为这样会导致目标 bean 的生命周期与代理或拦截器耦合，代码与原始目标 bean 杂糅的语义就会难以预测。</p>
<h5 id="组合生命周期机制"><a href="#组合生命周期机制" class="headerlink" title="组合生命周期机制"></a>组合生命周期机制</h5><p>如果使用了多种生命周期机制，他们的先后顺序如下：</p>
<ol>
<li>用注释方法注释 <code>@PostConstruct</code></li>
<li>InitializingBean 接口定义的 <code>afterPropertiesSet()</code> 回调</li>
<li>自定义配置的 <code>init()</code> 方法</li>
</ol>
<p>Destroy 方法以相同的顺序调用：</p>
<ol>
<li>用注释方法注释 <code>@PreDestroy</code></li>
<li>DisposableBean 接口定义的 <code>destroy()</code> 回调</li>
<li>自定义配置的 <code>destroy()</code> 方法</li>
</ol>
<p>如果是同一个函数，那么只会执行一次。</p>
<h4 id="启动和关闭回调"><a href="#启动和关闭回调" class="headerlink" title="启动和关闭回调"></a>启动和关闭回调</h4><p>Lifecycle 接口为任何有生命周期要求的对象（例如启动和停止某些后台进程）定义了基本的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何 Spring 管理的对象都可以实现 Lifecycle 接口。当 ApplicationContext 接收到启动和停止信号时（例如，对于运行时的停止/重启场景），它将这些调用级联到容器内定义的所有 Lifecycle 实现，这个过程由 LifecycleProcessor 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LifecycleProcessor 是 Lifecycle 接口的扩展。它又添加了另外两种方法来响应刷新和关闭的容器。</p>
<p>值得注意的是，常规 <code>org.springframework.context.Lifecycle</code> 接口是显式启动和停止通知的简单合约，并不意味着在上下文刷新时自动启动。要对特定 bean 的自动启动（包括启动阶段）进行细粒度控制，需要实现 <code>org.springframework.context.SmartLifecycle</code>。</p>
<p>如果要控制顺序，可以再继承 Phased 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SmartLifecycle</code> 就继承了这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phase 表示相位，启动时从低相位开始执行，停止时低相位最后停止。换句话说，<code>Integer.MIN_VALUE</code> 相位的第一个开始、最后一个停止，而 <code>Integer.MAX_VALUE</code> 最后启动并首先停止。未定义的相位默认为 0。</p>
<p>SmartLifecycle 定义了 stop 回调方法。任何实现在关闭过程完成之后都必须调用其 <code>callback</code> 的 <code>run()</code> 方法，这样就可以在必要时启用异步关闭。LifecycleProcessor 接口的默认实现 DefaultLifecycleProcessor 等待每个阶段内对象组的超时值来调用该回调，默认的每阶段超时为 30 秒。也可以通过定义名为 lifecycleProcessor 的 bean 来覆盖默认生命周期处理器实例（不定义就是默认的 DefaultLifecycleProcessor）。如果只想修改超时，则定义以下内容就足够了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleProcessor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.DefaultLifecycleProcessor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutPerShutdownPhase"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在非-Web-应用程序中优雅地关闭-Spring-IoC-容器"><a href="#在非-Web-应用程序中优雅地关闭-Spring-IoC-容器" class="headerlink" title="在非 Web 应用程序中优雅地关闭 Spring IoC 容器"></a>在非 Web 应用程序中优雅地关闭 Spring IoC 容器</h4><p>Spring 的基于 Web 的 ApplicationContext 实现已经可以在相关 Web 应用程序关闭时正常关闭 Spring IoC 容器。本节仅适用于非 Web 应用程序。</p>
<p>如果在非 Web 应用程序环境中使用 Spring 的 IoC 容器（例如，在客户机桌面环境中），请使用 JVM 注册 shutdown hook。这样做可确保正常关闭并在单例 bean 上调用相关的 destroy 方法，以便释放所有资源。我们依然必须正确配置和实现这些 destroy 回调。</p>
<p>要注册 shutdown hook，需要调用接口 <code>registerShutdownHook()</code> 上声明的 ConfigurableApplicationContext 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a shutdown hook for the above context...</span></span><br><span class="line">        ctx.registerShutdownHook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// app runs here...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// main method exits, hook is called prior to the app shutting down...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationContextAware-和-BeanNameAware"><a href="#ApplicationContextAware-和-BeanNameAware" class="headerlink" title="ApplicationContextAware 和 BeanNameAware"></a>ApplicationContextAware 和 BeanNameAware</h3><p>当 ApplicationContext 创建实现 org.springframework.context.ApplicationContextAware 接口的对象实例时，将为该实例提供对该 ApplicationContext 的引用。 ApplicationContextAware 接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，bean 可以通过 ApplicationContext 接口以编程方式操作创建它们的 ApplicationContext，或者通过将引用转换为此接口的已知子类（例如 ConfigurableApplicationContext，包括其他功能）。一种作用是可以操作其他 bean。有时这种能力很有用。但是通常我们应该避免使用它，因为它会将代码耦合到 Spring 且不遵循 IoC 规范，其中协作者作为属性提供给 bean。 ApplicationContext 还提供对文件资源的访问，发布应用程序事件和对 MessageSource 的访问，详见下文。</p>
<p>从 Spring 2.5 开始，自动装配是另一种获取 ApplicationContext 引用的方法。“传统”构造函数和 byType 自动装配模式（见上文的自动装配协作者）可以分别为构造函数参数或 setter 方法参数提供 ApplicationContext 类型的依赖关系。 为了获得更大的灵活性，包括自动装配字段和多参数方法的能力，我们可以使用基于注释的新自动装配功能。如果带有 <code>@Autowired</code> 注解的字段，构造函数或方法需要 ApplicationContext 类型的参数，那么 ApplicationContext 将会被注入。详见下文的 <code>@Autowired</code> 注解。</p>
<p>BeanNameAware 可以获取到该类实现的 bean 的 name，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会在全体普通 bean 属性定义之后但在初始化回调之前（例如 InitializingBean，afterPropertiesSet 或自定义 init 方法）之前调用回调。</p>
<h3 id="其他-Aware-接口"><a href="#其他-Aware-接口" class="headerlink" title="其他 Aware 接口"></a>其他 Aware 接口</h3><table>
<thead>
<tr>
<th>名称</th>
<th>注入的依赖</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ApplicationContextAware</td>
<td>ApplicationContext</td>
<td></td>
</tr>
<tr>
<td>ApplicationEventPublisherAware</td>
<td>封闭 ApplicationContext 的事件发布者</td>
<td></td>
</tr>
<tr>
<td>BeanClassLoaderAware</td>
<td>用于加载 bean 类的类加载器</td>
<td></td>
</tr>
<tr>
<td>BeanFactoryAware</td>
<td>BeanFactory</td>
<td></td>
</tr>
<tr>
<td>BeanNameAware</td>
<td>声明的 bean 的名称</td>
<td></td>
</tr>
<tr>
<td>BootstrapContextAware</td>
<td>运行容器的资源适配器 BootstrapContext，仅在 JCA-aware ApplicationContext 的实例中可用</td>
<td></td>
</tr>
<tr>
<td>LoadTimeWeaverAware</td>
<td>用于在加载时处理类定义的 weaver</td>
<td></td>
</tr>
<tr>
<td>MessageSourceAware</td>
<td>用于解析消息的策略（支持参数化和国际化）</td>
<td></td>
</tr>
<tr>
<td>NotificationPublisherAware</td>
<td>Spring JMX 通知发布者</td>
<td></td>
</tr>
<tr>
<td>ResourceLoaderAware</td>
<td>用于对资源进行低级访问的加载器</td>
<td></td>
</tr>
<tr>
<td>ServletConfigAware</td>
<td>运行容器的 ServletConfig，仅在 web-aware Spring ApplicationContext 中可用</td>
<td></td>
</tr>
<tr>
<td>ServletContextAware</td>
<td>运行容器的 ServletContext，仅在 web-aware Spring ApplicationContext 中可用</td>
<td></td>
</tr>
</tbody></table>
<p>再次提醒，使用这些接口会将代码耦合到 Spring API 且不遵循 IoC 规范。除非是需要以代码方式访问容器的基础架构 bean，否则不建议使用这些方式。</p>
<h2 id="bean-定义的继承"><a href="#bean-定义的继承" class="headerlink" title="bean 定义的继承"></a>bean 定义的继承</h2><p>bean 定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子 bean 定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用继承 bean 定义可以节省大量的输入。这是一种模板模型。</p>
<p>在 ApplicationContext 级别上，子 bean 定义使用 ChildBeanDefinition 类表示，大多数时候我们并不用在这个级别上去做定义。以下是一个简单定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">abstract</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithDifferentClass"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子 bean 定义从父级继承 scope，构造函数参数值，属性值和方法覆盖并带有添加新值的选项。指定的 scope，初始化方法，销毁方法或静态工厂方法设置都会覆盖相应的父设置。</p>
<p>也有些不会被继承：依赖、自动装配模式、依赖检查、单例、懒加载。</p>
<p>前面的示例通过使用 abstract 属性将父 bean 定义显式标记为 abstract。 如果父定义未指定类，则需要将父 bean 定义显式标记为 abstract，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithClass"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个父 bean 不能单独实例化。标记为 abstract 的 bean 只做模板 bean 定义。如果尝试强行 getBean 则会报错。容器的 <code>preInstantiateSingletons()</code> 方法会忽略 abstract 的 bean 定义。</p>
<p><em>注：ApplicationContext 默认情况下预先实例化所有单例。因此，重要的是（至少对于单例 bean），如果你有一个（父）bean 定义，你只打算用作模板，并且这个定义指定了一个类，你必须确保将 abstract 属性设置为 true 否则应用程序上下文将实际（尝试）预先实例化 abstract bean。</em></p>
<h2 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h2><p>通常，应用程序开发人员不需要继承 ApplicationContext 实现类。 相反，可以通过插入特殊集成接口的实现来扩展 Spring IoC 容器。 接下来的几节将介绍这些集成接口。</p>
<h3 id="使用-BeanPostProcessor-自定义-bean"><a href="#使用-BeanPostProcessor-自定义-bean" class="headerlink" title="使用 BeanPostProcessor 自定义 bean"></a>使用 BeanPostProcessor 自定义 bean</h3><p>BeanPostProcessor 接口实现举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simply return the instantiated bean as-is</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanPostProcessor 接口允许用户实现自己的（或覆盖容器的默认）实例化逻辑、依赖关系解析逻辑等。如果要在 Spring 容器完成实例化，配置和初始化 bean 之后实现某些自定义逻辑，则可以插入一个或多个自定义 BeanPostProcessor 实现。多个 BeanPostProcessor 实例可以通过实现 Ordered 接口并设置 order 属性来控制执行顺序。</p>
<p>BeanPostProcessor 实例的范围是每个容器的范围。 仅当我们使用容器层次结构时，这才是相关的。 如果在一个容器中定义 BeanPostProcessor，它只对该容器中的 bean 进行后处理。 换句话说，在一个容器中定义的 bean 不会被另一个容器中定义的 BeanPostProcessor 进行后处理，即使两个容器都是同一层次结构的一部分。</p>
<p>如果要更改的是 bean 定义，我们可以使用 BeanFactoryPostProcessor，详见下文。</p>
<p>org.springframework.beans.factory.config.BeanPostProcessor 接口由两个回调方法组成。当这样的类被注册为容器的后处理器（post-processor）时，对于容器创建的每个 bean 实例，后处理器在容器初始化方法之前从容器中获取回调（比如 <code>InitializingBean.afterPropertiesSet()</code> 或 bean 声明的 init 方法）。后处理器可以对 bean 实例执行任何操作，甚至可以让它忽略回调。bean 后处理器通常用于检查回调接口，或者用来将 bean 包装成代理。一些 Spring AOP 的基础设施类就是用 bean 后处理器实现的，以便提供代理包装逻辑。</p>
<p>ApplicationContext 会自动检测所有实现 BeanPostProcessor 接口的 bean，并将他们注册为后处理器，以便稍后在创建 bean 时调用。后处理器可以用任何 bean 注册方式部署在容器中。</p>
<p>注意，在配置类上使用 <code>@Bean</code> 工厂方法声明 BeanPostProcessor 时，工厂方法的返回类型应该是实现类本身，或者至少是 org.springframework.beans.factory.config.BeanPostProcessor 接口，指示该 bean 的后处理器性质。否则，ApplicationContext 无法在完全创建之前按类型自动检测到它。由于 BeanPostProcessor 需要尽早实例化以便应用于上下文中其他 bean 的初始化，因此这种早期类型检测至关重要。</p>
<h4 id="以编程方式注册-BeanPostProcessor-实例"><a href="#以编程方式注册-BeanPostProcessor-实例" class="headerlink" title="以编程方式注册 BeanPostProcessor 实例"></a>以编程方式注册 BeanPostProcessor 实例</h4><p>虽然 BeanPostProcessor 注册的推荐方法是通过 ApplicationContext 自动检测（如前所述），但也可以使用 addBeanPostProcessor 方法以编程方式对 ConfigurableBeanFactory 注册它们。当您需要在注册前评估条件逻辑或甚至跨层次结构中的上下文复制 Bean 后处理器时，这非常有用。 但请注意，以编程方式添加的 BeanPostProcessor 实例不遵循 Ordered 接口。这里，注册的顺序决定了执行的顺序。另请注意，以编程方式注册的 BeanPostProcessor 实例始终在通过自动检测注册的实例之前处理，而不管任何显式排序。</p>
<h4 id="BeanPostProcessor-实例和-AOP-自动代理"><a href="#BeanPostProcessor-实例和-AOP-自动代理" class="headerlink" title="BeanPostProcessor 实例和 AOP 自动代理"></a>BeanPostProcessor 实例和 AOP 自动代理</h4><p>BeanPostProcessor 是不能使用 AOP 的。实现 BeanPostProcessor 接口的类是特殊的，容器会对它们进行不同的处理。作为 ApplicationContext 的特殊启动阶段的一部分，它们直接引用的所有 BeanPostProcessor 实例和 bean 都在启动时实例化。接下来，所有 BeanPostProcessor 实例都以排序方式注册，并应用于容器中的所有其他 bean。因为 AOP 自动代理是作为 BeanPostProcessor 本身实现的，所以 BeanPostProcessor 实例和它们直接引用的 bean 都不符合自动代理的条件，因此没有编入方法。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simply return the instantiated bean as-is</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/lang</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/lang/spring-lang.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">"messenger"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">script-source</span>=<span class="string">"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple Is Just So Dreamy."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    when the above bean (messenger) is instantiated, this custom</span></span><br><span class="line"><span class="comment">    BeanPostProcessor implementation will output the fact to the system console</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"scripting.InstantiationTracingBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"scripting/beans.xml"</span>);</span><br><span class="line">        Messenger messenger = (Messenger) ctx.getBean(<span class="string">"messenger"</span>);</span><br><span class="line">        System.out.println(messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bean&apos;sensenger&apos;创建：org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></td></tr></table></figure>

<p>将回调接口或注释与自定义 BeanPostProcessor 实现结合使用是扩展 Spring IoC 容器的常用方法。一个例子是 Spring 的 RequiredAnnotationBeanPostProcessor —— 一个 Spring 提供的 BeanPostProcessor 实现，它保证用 <code>@Required</code>（或者其他自定义的）注释标记的 bean 上的属性一定有值注入。</p>
<h2 id="使用-BeanFactoryPostProcessor-定制配置项元数据"><a href="#使用-BeanFactoryPostProcessor-定制配置项元数据" class="headerlink" title="使用 BeanFactoryPostProcessor 定制配置项元数据"></a>使用 BeanFactoryPostProcessor 定制配置项元数据</h2><p>我们看到的下一个扩展点是 org.springframework.beans.factory.config.BeanFactoryPostProcessor。此接口的语义类似于 BeanPostProcessor 的语义，但有一个主要区别：BeanFactoryPostProcessor 对 bean 配置元数据进行操作。也就是说，Spring IoC 容器允许 BeanFactoryPostProcessor 读取配置元数据，并可能在容器实例化除 BeanFactoryPostProcessor 实例之外的任何 bean 之前更改它。</p>
<p>您可以配置多个 BeanFactoryPostProcessor 实例，并且可以通过设置 order 属性来控制这些 BeanFactoryPostProcessor 实例的运行顺序。但是，如果 BeanFactoryPostProcessor 实现 Ordered 接口，则只能设置此属性。如果编写自己的 BeanFactoryPostProcessor，则应考虑实现 Ordered 接口。有关更多详细信息，请参阅 BeanFactoryPostProcessor 和 Ordered 接口的 javadoc。</p>
<p>如果要更改实际的 bean 实例（即，从配置项元数据创建的对象），则需要使用 BeanPostProcessor（前面在使用 BeanPostProcessor 定制 Bean 中进行了描述）。虽然技术上可以在 BeanFactoryPostProcessor 中使用 bean 实例（例如，通过使用 <code>BeanFactory.getBean()</code>），但这样做会导致过早的 bean 实例化，从而违反标准的容器生命周期。这可能会导致负面影响，例如绕过 bean 后期处理。</p>
<p>此外，BeanFactoryPostProcessor 实例的范围是每个容器的范围。仅当您使用容器层次结构时，这才有意义。如果在一个容器中定义 BeanFactoryPostProcessor，则它仅应用于该容器中的 bean 定义。一个容器中的 Bean 定义不会被另一个容器中的 BeanFactoryPostProcessor 实例后处理，即使两个容器都是同一层次结构的一部分。</p>
<p>BeanFactoryPostProcessor 在 ApplicationContext 中声明时自动执行，以便将更改应用于定义容器的配置元数据。Spring 包含许多预定义的 bean 工厂后处理器，例如 PropertyOverrideConfigurer 和 PropertyPlaceholderConfigurer。您还可以使用自定义 BeanFactoryPostProcessor —— 例如，注册自定义属性编辑器。</p>
<p>ApplicationContext 自动检测部署到其中的任何实现 BeanFactoryPostProcessor 接口的 bean。它在适当的时候使用这些 bean 作为 bean factory post-processor。您可以像配置其他 bean 一样配置这些 post-processor bean。</p>
<h3 id="示例：类名替换器-PropertyPlaceholderConfigurer"><a href="#示例：类名替换器-PropertyPlaceholderConfigurer" class="headerlink" title="示例：类名替换器 PropertyPlaceholderConfigurer"></a>示例：类名替换器 PropertyPlaceholderConfigurer</h3><p>您可以使用 PropertyPlaceholderConfigurer 将 bean 定义中的属性值分离到外部 Java Properties 文件中。这样做可以使部署应用程序的人员自定义不同环境的属性，例如数据库 URL 和密码，而不会出现修改主 XML 定义文件或容器文件的复杂性或风险。</p>
<p>下面的基于 XML 的配置元数据片段，其中 DataSource 定义了占位符值：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/something/jdbc.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该示例显示了从外部属性文件配置的属性。在运行时，PropertyPlaceholderConfigurer 应用于替换 DataSource 的某些属性的元数据。要替换的值被指定为 <code>${property-name}</code> 形式的占位符，它遵循 Ant 和 log4j 以及 JSP EL 样式。</p>
<p>实际值来自标准 Java Properties 格式的另一个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>

<p>然后 <code>${jdbc.username}</code> 字符串在运行时将替换为值’sa’，其他占位符值也是类似。PropertyPlaceholderConfigurer 检查 bean 定义的大多数属性和属性中的占位符。此外，您可以自定义占位符前缀和后缀。</p>
<p>使用 Spring 2.5 中引入的 context 命名空间，您可以使用专用配置元素配置属性占位符。 您可以在 location 属性中以逗号分隔列表的形式提供一个或多个位置，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:com/something/jdbc.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>PropertyPlaceholderConfigurer 不仅在您指定的属性文件中查找属性。 默认情况下，如果它在指定的属性文件中找不到属性，它还会检查 Java System 属性。 您可以通过使用以下三个受支持的整数值之一设置 configurer 的 systemPropertiesMode 属性来自定义此行为：</p>
<ul>
<li>never （0）：从不检查系统属性。</li>
<li>fallback（1）：如果在指定的属性文件中无法解析，则检查系统属性。这是默认值。</li>
<li>override（2）：在尝试指定的属性文件之前，首先检查系统属性。这使系统属性可以覆盖任何其他属性源。</li>
</ul>
<p>有关 <a href="https://docs.spring.io/spring-framework/docs/5.1.8.RELEASE/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html" target="_blank" rel="noopener">PropertyPlaceholderConfigurer</a> 更多信息，请参阅 javadoc。</p>
<p>另，你甚至可以使用 PropertyPlaceholderConfigurer 替换类名称，这在您必须在运行时选择特定实现类时有时很有用。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/something/strategy.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>custom.strategy.class=com.something.DefaultStrategy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceStrategy"</span> <span class="attr">class</span>=<span class="string">"$&#123;custom.strategy.class&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果在运行时无法将类解析为有效类， 在即将创建 bean 时，bean 的解析将失败。对于非懒加载的 bean，这会发生在 ApplicationContext 的 <code>preInstantiateSingletons()</code> 阶段期间。</p>
<h3 id="示例：PropertyOverrideConfigurer"><a href="#示例：PropertyOverrideConfigurer" class="headerlink" title="示例：PropertyOverrideConfigurer"></a>示例：PropertyOverrideConfigurer</h3><p>PropertyOverrideConfigurer 是另一个 bean 工厂后处理器，类似于 PropertyPlaceholderConfigurer，但与后者不同，原始定义可以具有默认值，或者根本不具有 bean 属性的值。如果重写的 Properties 文件没有某个 bean 属性的条目，则使用默认的上下文定义。</p>
<p>需要注意的是，bean 定义不会感知到被覆盖，因此无法从 XML 定义文件中立即看出正在使用覆盖配置器。 如果多个 PropertyOverrideConfigurer 实例为同一个 bean 属性定义了不同的值，那么根据覆盖机制，最后一个实例将生效。</p>
<p>属性文件配置行采用以下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanName.property=value</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql:mydb</span><br></pre></td></tr></table></figure>

<p>复合属性名称也是支持的，只要路径的每个组件（重写的最终属性除外）都已经非空（可能由构造函数初始化）。在下面的示例中，tom bean 的 fred 属性的 bob 属性的 sammy 属性设置为 123：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tom.fred.bob.sammy = 123</span><br></pre></td></tr></table></figure>

<p>使用 Spring 2.5 中引入的 context 命名空间，可以使用专用配置元素配置属性覆盖，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"classpath:override.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-FactoryBean-自定义实例化逻辑"><a href="#使用-FactoryBean-自定义实例化逻辑" class="headerlink" title="使用 FactoryBean 自定义实例化逻辑"></a>使用 FactoryBean 自定义实例化逻辑</h3><p>你可以为本身为工厂的对象实现 org.springframework.beans.factory.FactoryBean 接口。</p>
<p>FactoryBean 接口在 Spring IoC 容器实例化逻辑中是可拔插的。如果 bean 的初始化代码相对复杂，更适合以 Java 代码表达，而不是（可能）冗长的 XML，那么我们可以创建自己的 FactoryBean，在该类中编写复杂的初始化，然后将自定义 FactoryBean 插入容器中。</p>
<p>FactoryBean 接口有三个方法：</p>
<ul>
<li><p><code>Object getObject()</code>：返回此工厂创建的对象的实例。可以共享实例，具体取决于此工厂是返回单例还是原型。</p>
</li>
<li><p><code>boolean isSingleton()</code>：如果此 FactoryBean 返回单例，则返回 true，否则返回 false。</p>
</li>
<li><p><code>Class getObjectType()</code>：返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 null。</p>
</li>
</ul>
<p>FactoryBean 概念和接口被用在 Spring Framework 中的许多位置。Spring 提供了 50 多个 FactoryBean 接口的实现。</p>
<p>如果需要向容器询问实际的 FactoryBean 实例本身，那么在调用 ApplicationContext 的 <code>getBean()</code> 方法时需要加上＆符号作为 bean 的 id 前缀。比如，对于 id 为 myBean 的 FactoryBean，在容器上调用 <code>getBean(&quot;myBean&quot;)</code> 将返回 FactoryBean 的产品，调用 getBean（“＆myBean”）将返回 FactoryBean 实例本身。</p>
<h2 id="基于注解的容器配置"><a href="#基于注解的容器配置" class="headerlink" title="基于注解的容器配置"></a>基于注解的容器配置</h2><p>这里有一个讨论，配置 Spring 的注解是否比 XML 更好？</p>
<p>注解在其声明中提供了大量上下文，从而可以使配置更短更简洁。而 XML 可以在不触及源代码或重新编译它们的情况下连接组件。<br>有些人更喜欢将注入靠近源，也有人认为有注解的类不再是 POJO，而且配置变得分散且难以控制。</p>
<p>无论选择如何，Spring 都可以兼顾两种风格，甚至可以将它们混合在一起。值得指出的是，通过其 JavaConfig 选项，Spring 允许以非侵入方式使用注释，而无需触及目标组件源代码，并且在工具方面，Spring Tool Suite 支持所有配置样式。</p>
<p>基于注释的配置提供了 XML 设置的替代方案，该配置依赖于字节码元数据来连接组件而不是角括号声明。开发人员不是使用 XML 来描述 bean 连接，而是通过在相关的类，方法或字段声明上使用注释将配置移动到组件类本身。如示例中所述：RequiredAnnotationBeanPostProcessor，将 BeanPostProcessor 与注释结合使用是扩展 Spring IoC 容器的常用方法。例如，Spring 2.0 引入了使用 <code>@Required</code> 注释强制执行所需属性的可能性。 Spring 2.5 使得有可能采用相同的通用方法来驱动 Spring 的依赖注入。从本质上讲，<code>@Autowired</code> 注释提供的功能与自动装配协作者中描述的相同，但具有更细粒度的控制和更广泛的适用性。Spring 2.5 还增加了对 JSR-250 注释的支持，例如 <code>@PostConstruct</code> 和 <code>@PreDestroy</code>。Spring 3.0 增加了对 javax.inject 包中包含的 JSR-330（Java 的依赖注入）注释的支持，例如 <code>@Inject</code> 和 <code>@Named</code>。有关这些注释，详见下文。</p>
<p><em>注:注解注入在 XML 注入之前执行。因此，对于同事通过这两种方法注入的属性，XML 配置会覆盖注解的配置。</em></p>
<p>和之前一样，可以将它们注册为单独的 bean 定义，但也可以通过在基于 XML 的 Spring 配置中包含以下标记来隐式注册它们（请注意包含 context 命名空间）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（隐式注册的 post-processors 包括 AutowiredAnnotationBeanPostProcessor， CommonAnnotationBeanPostProcessor， PersistenceAnnotationBeanPostProcessor，和前面提到的 RequiredAnnotationBeanPostProcessor。）</p>
<p><code>&lt;context:annotation-config/&gt;</code> 仅在定义它的同一应用程序上下文中查找 bean 上的注释。这意味着，如果将 <code>&lt;context:annotation-config/&gt;</code> 放在 DispatcherServlet 的 WebApplicationContext 中，它只检查控制器中有 <code>@Autowired</code>注解的 bean，而不检查您的服务。有关更多信息，请参阅 DispatcherServlet。</p>
<h3 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h3><p>@Required 注释可以用于 bean 属性 setter 方法，如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解表示被修饰的 bean 属性必须在配置时通过 bean 定义中的显式属性值，或通过 autowiring 装配。 如果被修饰的 bean 属性没有被填充，容器就会抛出异常，以后避免以后抛出 NullPointerException 等。不过最好还是将断言放入 bean 类本身（比如 init 方法内），这样如果在容器外部使用类，这样做也会强制执行那些必需的引用和值。</p>
<p><em>注：<code>@Required</code> 注释从 Spring Framework 5.1 开始正式弃用，最好使用构造函数注入所需的设置（或者自定义实现 <code>InitializingBean.afterPropertiesSet()</code> 以及 bean 属性的 setter 方法）。</em></p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>在本节所包含的示例中，可以使用 JSR 330 的@Inject 注释代替 Spring 的@Autowired 注释。</p>
<p>@Autowired 注解可以用于构造函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring Framework 4.3 开始，如果目标 bean 只定义了一个构造函数入口，则不再需要在这样的构造函数上使用@Autowired 注释。但是，如果有多个构造器可用，则必须注释至少一个构造器以告诉容器使用哪一个。</p>
<p>@Autowired 注解也可用于“传统” setter 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至是具有任意名称和多个参数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></span><br><span class="line"><span class="function"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以应用于字段，甚至可以将它与构造函数混合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注：确保目标组件（例如，MovieCatalog 或 CustomerPreferenceDao）始终按照用于@Autowired 注释注入点的类型声明。否则，由于在运行时未找到类型匹配，注入可能会失败。</em></p>
<p><em>对于通过类路径扫描找到的 XML 定义的 bean 或组件类，容器通常预先知道具体类型。但是，对于 <code>@Bean</code> 工厂方法，您需要确保声明的返回类型足够准确。对于实现多个接口的组件或可能由其实现类型引用的组件，请考虑在工厂方法上声明最具体的返回类型（至少与引用 bean 的注入点所需的特定类型一致）。</em></p>
<p>甚至可以用于数组，ApplicationContext 会提供符合类型的所有 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乃至 Collection 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果希望数组或列表中的项按特定顺序排序，可以实现 <code>org.springframework.core.Ordered</code> 接口或使用 <code>@Order</code> 或标准 <code>@Priority</code> 注解。否则，它们的顺序遵循容器中相应目标 bean 定义的注册顺序。</p>
<p>您可以在目标类级别和 <code>@Bean</code> 方法上声明 <code>@Order</code> 注解，可能是通过单个 bean 定义（在多个定义使用相同 bean 类的情况下）。<code>@Order</code> 值可能影响注入时的优先级，但要注意这并不会影响启动的顺序，这是由依赖关系和 <code>@DependsOn</code> 声明正交决定的。</p>
<p>请注意，标准的 <code>javax.annotation.Priority</code> 注释在 <code>@Bean</code> 级别不可用，因为它无法在方法上声明。它的语义可以通过 <code>@Order</code> 值或是指定 <code>@Primary</code> 在同类型的某一个 bean 上实现。</p>
</blockquote>
<p>即使是 Map，只要 key 类型是 String，也可以被自动装配。Map 值包含所有期望类型的 bean，并且键包含相应的 bean 名称，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，当给定注入点没有匹配的候选 bean 时，自动装配会失败。对于声明的数组，集合或映射，至少需要一个匹配元素。</p>
<p>默认情况下 <code>@Autowired</code> 注解的方法和字段是必须的依赖项。我们也可以通过修改 required 参数来改为非必要，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，如果依赖项（可能是多个参数依赖项中的某一个）无法注入，那么这个被注解的方法都完全不会被调用（比如上文的 setMovieFinder）。</p>
<p>注入构造函数和工厂方法参数是一种特殊情况，因为 <code>@Autowired</code> 上的 <code>required</code> 标志具有一些不同的含义，因为 Spring 的构造函数解析算法可能要处理多个构造函数。默认情况下构造函数和工厂方法参数需要保证有效，但在单构造函数场景中有一些特殊规则，例如，如果多元素注入点（数组，集合，Map）没有匹配的 bean 可用，则解析为空(empty)的实例。这样所有的依赖关系都可以在同一个多参的构造函数中声明，比如可以声明为一个没有 <code>@Autowired</code> 注解的公共构造函数。</p>
<blockquote>
<p>每个类只能标记一个带 required 注解的构造函数，但可以标注多个非 required 注解的构造函数。在这种情况下，每个构造函数都是可选的，Spring 会使用满足依赖性的“最贪心”（具有最多参数的构造函数）的构造函数。构造函数解析算法与具有重载构造函数的非注释类相同，只是将候选者缩小到带注释的构造函数。</p>
<p>建议使用 <code>@Autowired</code> 的 <code>required</code> 属性而不是 setter 方法的 <code>@Required</code> 注释。<code>required</code> 属性表示该属性不是自动装配所必需的。如果无法自动装配，则会忽略该属性。另一方面，<code>@Required</code> 更强大，因为它要求容器必须通过任意容器支持的方式设置属性。如果未定义任何值，则会引发相应的异常。</p>
</blockquote>
<p>另外，Java 8 提供了 java.util.Optional 特性来解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring Framework 5.0 开始，还可以使用 <code>@Nullable</code> 注释（任何包中的任何类型的注释 - 比如 JSR-305 中的<code>javax.annotation.Nullable</code> ）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(@Nullable MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以将 <code>@Autowired</code> 用于众所周知的可解析依赖项的接口：BeanFactory，ApplicationContext，Environment，ResourceLoader，ApplicationEventPublisher 和 MessageSource。 这些接口及其扩展接口（如 ConfigurableApplicationContext 或 ResourcePatternResolver）将自动解析，无需特殊设置。 以下示例自动装配 ApplicationContext 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Autowired</code>，<code>@Inject</code>，<code>@Value</code> 和 <code>@Resource</code> 注解由 BeanPostProcessor 实现处理。 这意味着我们不能在自己的 BeanPostProcessor 或 BeanFactoryPostProcessor 类型中应用这些注释。必须使用 XML 或 Spring @Bean 方法显式地“连接”这些类型。</p>
<h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>由于按类型自动装配可能会导致多个候选项，因此通常需要对选择过程进行更多控制。实现这一目标的一种方法是使用 Spring 的 <code>@Primary</code> 注释。<code>@Primary</code> 表示当多个 bean 可以自动装配到单值依赖项时，应该优先选择特定的 bean。如果候选项中只存在一个 primary 的 bean，那么它就是自动装配的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">firstMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">secondMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MovieRecommender 将会自动装配 firstMovieCatalog</p>
<h3 id="限定符微调自动装配"><a href="#限定符微调自动装配" class="headerlink" title="限定符微调自动装配"></a>限定符微调自动装配</h3><p><code>@Primary</code> 可以确定一个主要候选者。当您需要更准确控制选择过程时，可以使用 Spring 的 <code>@Qualifier</code> 注释。您可以将限定符值与特定参数相关联，缩小类型匹配集，以便为每个参数选择特定的 bean。有个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"main"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(@Qualifier(<span class="string">"main"</span>)</span> MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="function">            CustomerPreferenceDao customerPreferenceDao) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为降级，bean 名称被视为默认 qualifier 的值。因此，您可以使用 bean 的 id 得到相同的匹配结果。但是，虽然您可以使用此约定来按名称引用特定 bean，限定符值在类型匹配集中只是具有缩小的语义，它们在语义上不表示对唯一 bean id 的引用。良好的限定符值是 main 或 EMEA 或 persistent，类似这些，不同于自动生成的 bean id。</p>
<p>限定符也适用于类型化集合，比如前面的 <code>Set&lt;MovieCatalog&gt;</code>。在这种情况下，根据声明的限定符，所有匹配的 bean 都作为集合注入。这意味着限定符不必是唯一的，它们只是一个过滤条件。例如，您可以使用相同的限定符值 <code>action</code> 定义多个 MovieCatalog bean，所有这些 bean 都注入到使用 <code>@Qualifier(&quot;action&quot;)</code> 注解的 <code>Set&lt;MovieCatalog&gt;</code> 中。</p>
<blockquote>
<p>在类型匹配候选项中，根据目标 bean 名称选择限定符值，在注入点不需要 <code>@Qualifier</code> 注释。如果没有其他解析指示符（例如限定符或主要标记），则对于非唯一依赖性情况，Spring 会将注入点名称（即字段名称或参数名称）与目标 bean 名称进行匹配，然后选择同名的候选人，如果有的话。</p>
<p>也就是说，如果您打算按名称表达注释驱动的注入，请不要主要使用 <code>@Autowired</code>，即使它能够在类型匹配候选项中通过 bean 名称进行选择。相反，使用 JSR-250 <code>@Resource</code> 注释，该注释在语义上定义为通过其唯一名称标识特定目标组件，声明的类型与匹配过程无关。 <code>@Autowired</code> 具有相当不同的语义：在按类型选择候选 bean 之后，仅在那些类型选择的候选项中考虑指定的字符串限定符值（例如，将 <code>account</code> 限定符与标记有相同限定符标签的 bean 匹配）。</p>
<p>对于自身定义为集合，Map 或数组类型的 bean，<code>@Resource</code> 是一个很好的解决方案，通过唯一名称引用特定的集合或数组 bean。也就是说，从 4.3 版本开始，只要元素类型信息保存在 <code>@Bean</code> 返回类型签名或集合继承层次结构中，您就可以通过 Spring 的 <code>@Autowired</code> 类型匹配算法匹配 Map 和数组类型。在这种情况下，您可以使用限定符值在相同类型的集合中进行选择，如上一段所述。</p>
<p>从 4.3 开始，<code>@Autowired</code> 还会考虑自引用注入（即，引用回到当前注入的 bean）。请注意，自我注入是一种后备。对其他组件的常规依赖性始终具有优先权。从这个意义上说，自我引用并不参与常规的候选人选择，因此从不是主要的。相反，它们总是最低优先级。在实践中，您应该仅使用自引用作为最后的手段（例如，通过 bean 的事务代理调用同一实例上的其他方法）。考虑在这种情况下将受影响的方法分解为单独的委托 bean。或者，您可以使用 <code>@Resource</code>，它可以通过其唯一名称获取代理回到当前 bean。</p>
<p><code>@Autowired</code> 适用于字段，构造函数和多参数方法，允许在参数级别缩小限定符注释。相比之下，<code>@Resource</code> 仅支持字段和具有单个参数的 bean 属性 setter 方法。因此，如果注射目标是构造函数或多参数方法，则应该使用限定符。</p>
</blockquote>
<p>我们可以创建自己的自定义限定符注释，需要定义注释并在定义中提供 <code>@Qualifier</code> 注释，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Genre &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Genre</span>(<span class="string">"Action"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComedyCatalog</span><span class="params">(@Genre(<span class="string">"Comedy"</span>)</span> MovieCatalog comedyCatalog) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，您可以提供候选 bean 定义的信息。 您可以将 <code>&lt;qualifier/&gt;</code> 标记添加为 <code>&lt;bean/&gt;</code> 标记的子元素，然后指定与自定义限定符注释匹配的类型和值。 类型与注释的完全限定类名匹配。或者，为方便起见，如果不存在冲突名称的风险，您可以使用短类名称。以下示例演示了这两种方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"Genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"example.Genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Genre</span>(<span class="string">"Action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个后文会细讲。</p>
<p>在某些情况下，使用没有值的注释可能就足够了。当注释用于更通用的目的并且可以应用于多种不同类型的依赖项时，这可能很有用。例如，您可以提供可在没有 Internet 连接时搜索的脱机目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Offline &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Offline</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog offlineCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以定义除简单值属性之外或代替简单值属性接受命名属性的自定义限定符注释。如果随后在要自动装配的字段或参数上指定了多个属性值，则 bean 定义必须匹配所有此类属性值才能被视为自动装配候选：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">genre</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Format <span class="title">format</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Action"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Comedy"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.DVD, genre=<span class="string">"Action"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.BLURAY, genre=<span class="string">"Comedy"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型微调自动装配"><a href="#泛型微调自动装配" class="headerlink" title="泛型微调自动装配"></a>泛型微调自动装配</h3><p>除了<code>@Qualifier</code>注释之外，您还可以使用 Java 泛型类型作为隐式的限定形式。例如，假设您具有以下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设前面的 bean 实现了一个通用接口（即 <code>Store&lt;String&gt;</code> 和 <code>Store&lt;Integer&gt;</code>），你可以 <code>@Autowire</code> Store 接口，并将泛型用作限定符，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span></span><br></pre></td></tr></table></figure>

<p>通用限定符也适用于自动装配列表，Map 实例和数组。以下示例自动装配通用 List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span></span><br><span class="line"><span class="comment">// Store&lt;String&gt; beans will not appear in this list</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h3 id="使用-CustomAutowireConfigurer"><a href="#使用-CustomAutowireConfigurer" class="headerlink" title="使用 CustomAutowireConfigurer"></a>使用 CustomAutowireConfigurer</h3><p>CustomAutowireConfigurer 是一个 BeanFactoryPostProcessor，它允许注册自己的自定义限定符注释类型，即使它们没有使用 Spring 的 <code>@Qualifier</code> 注释进行注释。 以下示例显示如何使用 CustomAutowireConfigurer：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customAutowireConfigurer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.CustomAutowireConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customQualifierTypes"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example.CustomQualifier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>AutowireCandidateResolver 通过以下方式确定 autowire 候选者：</p>
<ul>
<li><p>每个 bean 定义的 autowire-candidate 值</p>
</li>
<li><p><code>&lt;beans/&gt;</code>元素上可用的任何 default-autowire 候选模式</p>
</li>
<li><p>存在 <code>@Qualifier</code> 注释以及使用 CustomAutowireConfigurer 注册的任何自定义注释</p>
</li>
</ul>
<p>当多个 bean 有资格作为 autowire 候选者时，“primary”的确定如下：当候选者中刚好只有一个 bean 定义的 primary 属性设置为 true，就选择它。</p>
<h3 id="使用-Resource-注入"><a href="#使用-Resource-注入" class="headerlink" title="使用 @Resource 注入"></a>使用 @Resource 注入</h3><p>Spring 还通过对字段或 bean 属性 setter 方法使用 JSR-250 <code>@Resource</code> 注释（javax.annotation.Resource）来支持注入。这是 Java EE 中的常见模式：例如，在 JSF 管理的 bean 和 JAX-WS 端点中。Spring 也支持 Spring 管理对象的模式。</p>
<p><code>@Resource</code> 采用名称属性。默认情况下，Spring 将该值解释为要注入的 bean 名称。换句话说，它遵循按名称语义，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"myMovieFinder"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未明确指定名称，则默认名称是从字段名称或 setter 方法派生的。如果是字段，则采用字段名称。在 setter 方法的情况下，它采用 bean 属性名称。下面的例子将把 movieFinder bean 注入其 setter 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释中的 name 由 ApplicationContext 解析为 bean 名称，由 CommonAnnotationBeanPostProcessor 拿到该名称。如果显式配置 Spring 的 SimpleJndiBeanFactory，则可以通过 JNDI 解析名称。但是，我们建议您依赖于默认行为并使用 Spring 的 JNDI 查找功能来保证间接级别。</p>
</blockquote>
<p>在某些特殊情况下 <code>@Resource</code> 不指定明确的名称，与 <code>@Autowired</code> 类似，<code>@Resource</code> 会不看名称，使用主要类型匹配，这些情况包括以下类：BeanFactory， ApplicationContext，ResourceLoader，ApplicationEventPublisher 和 MessageSource 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-PostConstruct-和-PreDestroy"><a href="#使用-PostConstruct-和-PreDestroy" class="headerlink" title="使用 @PostConstruct 和 @PreDestroy"></a>使用 @PostConstruct 和 @PreDestroy</h3><p>CommonAnnotationBeanPostProcessor 不仅识别 <code>@Resource</code> 注释，还识别 JSR-250 生命周期注释：<code>javax.annotation.PostConstruct</code> 和<code>javax.annotation.PreDestroy</code>。在 Spring 2.5 中引入，对这些注释的支持提供了<a href="#初始化回调">初始化回调</a>和<a href="#销毁回调">销毁回调</a>中描述的生命周期回调机制的替代方法。假如 CommonAnnotationBeanPostProcessor 在 ApplicationContext 中注册，那么带有这些注释的方法会在相应的 Spring 生命周期接口方法或显式声明的回调方法的同时被调用。在以下示例中，缓存在初始化时预填充并在销毁时清除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// populates the movie cache upon initialization...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// clears the movie cache upon destruction...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关组合各种生命周期机制的效果的详细信息，参见上文<a href="#组合生命周期机制">组合生命周期机制</a>。</p>
<blockquote>
<p>与 <code>@Resource</code> 一样，<code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注释类型是 JDK 6 到 8 的标准 Java 库的一部分。但是，整个 javax.annotation 包与 JDK 9 中的核心 Java 模块分离，最终在 JDK 11 中删除。如果需要，现在需要通过 Maven Central 获取 javax.annotation-api 组件，并添加到应用程序的类路径中。</p>
</blockquote>
<h2 id="类路径扫描和托管组件"><a href="#类路径扫描和托管组件" class="headerlink" title="类路径扫描和托管组件"></a>类路径扫描和托管组件</h2><p>本章中的大多数示例都使用 XML 来指定在 Spring 容器中生成每个 BeanDefinition 的配置。 上一节（基于注释的容器配置）演示了如何通过源级注释提供大量配置元数据。但是，即使在这些示例中，基本 bean 定义也在 XML 文件中显式定义，而注释仅驱动依赖项注入。本节介绍通过扫描类路径隐式检测候选组件的选项。候选组件是与筛选条件匹配的类，并且具有向容器注册的相应 bean 定义。这消除了使用 XML 执行 bean 注册的需要。相反，您可以使用注释（比如<code>@Component</code>），AspectJ 类型表达式或您自己的自定义筛选条件来选择哪些类具有向容器注册的 bean 定义。</p>
<blockquote>
<p>从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能是核心 Spring Framework 的一部分。这使您可以使用 Java 而不是使用传统的 XML 文件来定义 bean。看看的@Configuration，@Bean， @Import，和@DependsOn 注释有关如何使用这些新功能的例子。</p>
</blockquote>
<h3 id="Component-和更多的-Stereotype-注释"><a href="#Component-和更多的-Stereotype-注释" class="headerlink" title="@Component 和更多的 Stereotype 注释"></a>@Component 和更多的 Stereotype 注释</h3><p><code>@Repository</code> 注解是实现存储库的角色或构造型（也称为数据访问对象或 DAO）的任何类的标记。 该标记的用途包括自动翻译异常，详见“异常翻译”。</p>
<p>Spring 提供了进一步的构造型注释：<code>@Component</code>，<code>@Service</code> 和 <code>@Controller</code>。<code>@Component</code> 是任何 Spring 托管组件的通用构造型。 <code>@Repository</code>，<code>@Service</code> 和<code>@Controller</code> 是 <code>@Component</code> 的特化，用于更具体的用例（分别在持久层，服务层和表示层中）。因此，您可以使用 <code>@Component</code> 来注释组件类，但是通过使用 <code>@Repository</code>，<code>@Service</code> 或 <code>@Controller</code> 来注释组件类，您的类更适合于通过工具进行处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 <code>@Repository</code>，<code>@Service</code> 和 <code>@Controller</code> 在 Spring 框架的将来版本中也可以带有其他语义。因此，如果在服务层使用 <code>@Component</code> 或 <code>@Service</code> 之间进行选择，则 <code>@Service</code> 显然是更好的选择。同样，如前所述，<code>@Repository</code> 已被支持作为持久层中自动异常转换的标记。</p>
<h3 id="使用元注释和组合注释"><a href="#使用元注释和组合注释" class="headerlink" title="使用元注释和组合注释"></a>使用元注释和组合注释</h3><p>Spring 提供的许多注释都可以在您自己的代码中用作元注释。元注释是可以应用于另一个注释的注释。例如，前面提到的 <code>@Service</code> 注释使用 <code>@Component</code> 进行元注释，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Service</code> 的处理方式与 <code>@Component</code> 相同。</p>
<p>您还可以组合元注释来创建“组合注释”。 例如，Spring MVC 中的 <code>@RestController</code> 批注由 <code>@Controller</code> 和 <code>@ResponseBody</code> 组成。</p>
<p>此外，组合注释可以选择从元注释中重新声明属性，以允许自定义。当您只希望公开元注释属性的子集时，此功能特别有用。例如，Spring 的 <code>@SessionScope</code>注释将作用域名称硬编码为会话，但仍允许自定义 proxyMode。以下清单显示了 <code>SessionScope</code> 批注的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_SESSION)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SessionScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for &#123;<span class="doctag">@link</span> Scope#proxyMode&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Defaults to &#123;<span class="doctag">@link</span> ScopedProxyMode#TARGET_CLASS&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = Scope.class)</span><br><span class="line">    <span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionScopedService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以覆盖 proxyMode 的值，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope</span>(proxyMode = ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionScopedUserService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动检测类并注册-Bean-定义"><a href="#自动检测类并注册-Bean-定义" class="headerlink" title="自动检测类并注册 Bean 定义"></a>自动检测类并注册 Bean 定义</h3><p>Spring 可以自动检测构造型类，并向 ApplicationContext 注册相应的 BeanDefinition 实例。 例如，以下两个类别有资格进行这种自动检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要自动检测这些类并注册相应的 bean，您需要添加 @ComponentScan 到@Configuration 类中，其中 basePackages 属性是两个类的公共父包。（或者，您可以指定一个逗号分隔，分号分隔或空格分隔的列表，其中包括每个类的父包。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为简便起见，前面的示例可能使用了 注释的 value 属性（即 <code>@ComponentScan(&quot;org.example&quot;)</code> ）。</p>
</blockquote>
<blockquote>
<p>扫描类路径包需要在类路径中存在相应的目录条目。使用 Ant 构建 JAR 时，请确保未激活 JAR 任务的仅文件开关。此外，在某些环境中，可能不会基于安全策略公开类路径目录，例如，在 JDK 1.7.0_45 及更高版本上的独立应用程序（这需要在清单中设置“受信任的库”-请参阅 <a href="https://stackoverflow.com/Questions/19394570/java-jre-7u45-breaks-classloader-getresources）。" target="_blank" rel="noopener">https://stackoverflow.com/Questions/19394570/java-jre-7u45-breaks-classloader-getresources）。</a><br>在 JDK 9 的模块路径（Jigsaw）上，Spring 的类路径扫描通常可以按预期进行。但是，请确保将组件类导出到 module-info 描述符中。如果您期望 Spring 调用您的类的非公共成员，请确保它们是“打开的”（也就是说，它们使用 opens 声明而不是描述符中的 exports 声明 module-info）。</p>
</blockquote>
<p>此外，当您使用 component-scan 元素时，AutowiredAnnotationBeanPostProcessor 和 CommonAnnotationBeanPostProcessor 都隐式包括在内。这意味着将自动检测这两个组件并将它们连接在一起，而这一切都不需要 XML 中提供的任何 bean 配置元数据。</p>
<blockquote>
<p>您可以通过将注释配置属性包括为 false 来禁用 AutowiredAnnotationBeanPostProcessor 和 CommonAnnotationBeanPostProcessor 的注册。</p>
</blockquote>
<h3 id="使用过滤器自定义扫描"><a href="#使用过滤器自定义扫描" class="headerlink" title="使用过滤器自定义扫描"></a>使用过滤器自定义扫描</h3><p>默认情况下，只有使用 <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code> 进行注释的类或使用 <code>@Component</code> 进行注释的自定义注释是可以被检测到的候选组件。但是，您可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为 <code>@ComponentScan</code> 批注的 includeFilters 或 excludeFilters 参数（或作为 component-scan 元素的 include-filter 或 exclude-filter 子元素）。每个过滤器元素都需要 type 和 expression 属性。 下表描述了过滤选项：</p>
<table>
<thead>
<tr>
<th>过滤器类型</th>
<th>范例表达</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>注释（默认）</td>
<td>org.example.SomeAnnotation</td>
<td>在目标组件的类型级别上存在的注释。</td>
</tr>
<tr>
<td>分配</td>
<td>org.example.SomeClass</td>
<td>目标组件可分配给（扩展或实现）的类（或接口）。</td>
</tr>
<tr>
<td>AspectJ</td>
<td>org.example..*Service+</td>
<td>目标组件要匹配的 AspectJ 类型表达式。</td>
</tr>
<tr>
<td>正则表达式</td>
<td>org.example.Default.*</td>
<td>要与目标组件类名称匹配的正则表达式。</td>
</tr>
<tr>
<td>自定义</td>
<td>org.example.MyTypeFilter</td>
<td>org.springframework.core.type.TypeFilter 接口的自定义实现。</td>
</tr>
</tbody></table>
<p>以下示例显示了忽略所有 <code>@Repository</code> 注释并改为使用“存根”存储库的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>,</span><br><span class="line">        includeFilters = <span class="meta">@Filter</span>(type = FilterType.REGEX, pattern = <span class="string">".*Stub.*Repository"</span>),</span><br><span class="line">        excludeFilters = <span class="meta">@Filter</span>(Repository.class))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以通过在注释上设置 <code>useDefaultFilters = false</code> 或通过将 <code>use-default-filters=“false”</code> 作为 <code>&lt;component-scan/&gt;</code> 元素的属性来禁用默认过滤器。这将禁用对<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code> 或 <code>@Configuration</code> 注释的类的自动检测。</p>
<h3 id="在组件中定义-Bean-元数据"><a href="#在组件中定义-Bean-元数据" class="headerlink" title="在组件中定义 Bean 元数据"></a>在组件中定义 Bean 元数据</h3><p>Spring 组件还可以将 bean 定义元数据贡献给容器。您可以 <code>@Bean</code> 使用与在带 <code>@Configuration</code> 注释的类中定义 Bean 元数据相同的注释来执行此操作。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"public"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"publicInstance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Component method implementation omitted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一类是 Spring 组件，在其 <code>doWork()</code> 方法中具有特定于应用程序的代码。 但是，它也提供了一个具有工厂方法的 bean 定义，该工厂方法引用了方法 <code>publicInstance()</code>。<code>@Bean</code> 批注标识工厂方法和其他 bean 定义属性，例如通过 <code>@Qualifier</code> 批注的限定符。可以指定其他的方法级别注释比如 <code>@Scope</code>，<code>@Lazy</code> 和自定义限定符注释。</p>
<blockquote>
<p>除了用于组件初始化的角色外，您还可以将 <code>@Lazy</code> 批注放置在标有 <code>@Autowired</code> 或 <code>@Inject</code> 的注入点上。在这种情况下，它导致了惰性解析代理的注入。</p>
</blockquote>
<p>如前所述，除了支持自动装配的字段和方法，还支持自动装配@Bean 方法。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"public"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"publicInstance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use of a custom qualifier and autowiring of method parameters</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TestBean <span class="title">protectedInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"public"</span>)</span> TestBean spouse,</span></span><br><span class="line"><span class="function">            @<span class="title">Value</span><span class="params">(<span class="string">"#&#123;privateInstance.age&#125;"</span>)</span> String country) </span>&#123;</span><br><span class="line">        TestBean tb = <span class="keyword">new</span> TestBean(<span class="string">"protectedInstance"</span>, <span class="number">1</span>);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        <span class="keyword">return</span> tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TestBean <span class="title">privateInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"privateInstance"</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@RequestScope</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">requestScopedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"requestScopedInstance"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例将 String 方法参数国家/地区自动连线到另一个名为 privateInstance 的 bean 上 age 属性的值。Spring Expression Language 元素通过符号 <code>＃{&lt;expression&gt;}</code> 定义属性的值。对于 <code>@Value</code> 批注，表达式解析程序已预先配置为在解析表达式文本时查找 bean 名称。</p>
<p>从 Spring Framework 4.3 开始，您还可以声明类型为 InjectionPoint 的工厂方法参数（或更具体的子类：DependencyDescriptor），以访问触发当前 bean 创建的请求注入点。请注意，这仅适用于实际创建的 Bean 实例，不适用于注入现有实例。因此，此功能对原型范围的 bean 最有意义。对于其他作用域，factory 方法仅在给定作用域中看到触发创建新 bean 实例的注入点（例如，触发创建惰性单例 bean 的依赖项）。 在这种情况下，可以将提供的注入点元数据与语义一起使用。 以下示例显示了如何使用 InjectionPoint：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">prototypeInstance</span><span class="params">(InjectionPoint injectionPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"prototypeInstance for "</span> + injectionPoint.getMember());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常规 Spring 组件中的 <code>@Bean</code> 方法的处理方式与 Spring <code>@Configuration</code> 类中的 <code>@Bean</code> 方法不同。区别在于，<code>@Component</code> 类没有使用 CGLIB 来拦截方法和字段的调用。 CGLIB 代理是一种调用 <code>@Configuration</code> 类中 <code>@Bean</code> 方法中的方法或字段的方法，用于创建 Bean 元数据引用以协作对象。此类方法不是使用常规 Java 语义调用的，而是通过容器进行的，以提供通常的生命周期管理和 Spring Bean 的代理，即使通过 <code>@Bean</code> 方法的编程调用引用其他 Bean 时也是如此。相反，在普通 <code>@Component</code> 类内的 <code>@Bean</code> 方法中调用方法或字段具有标准 Java 语义，而无需特殊的 CGLIB 处理或其他约束。</p>
<blockquote>
<p>您可以将 <code>@Bean</code> 方法声明为静态方法，从而允许在不将其包含配置类创建为实例的情况下调用它们。在定义后处理器 Bean（例如 BeanFactoryPostProcessor 或 BeanPostProcessor 类型）时，这特别有意义，因为此类 Bean 在容器生命周期的早期进行了初始化，并且应避免在那时触发配置的其他部分。</p>
<p>由于技术限制，对静态 <code>@Bean</code> 方法的调用永远不会被容器拦截，即使在 <code>@Configuration</code> 类中也是如此（如本节前面所述），由于技术限制：CGLIB 子类只能覆盖非静态方法。结果，直接调用另一个 <code>@Bean</code> 方法具有标准的 Java 语义，从而导致直接从工厂方法本身直接返回一个独立的实例。</p>
<p>@Bean 方法的 Java 语言可见性不会对 Spring 容器中的最终 bean 定义产生直接影响。您可以在非 <code>@Configuration</code> 类中自由声明自己的工厂方法，也可以在任何地方声明静态方法。但是，<code>@Configuration</code> 类中的常规 <code>@Bean</code> 方法必须是可重写的——即，不得将它们声明为 private 或 final。</p>
<p>还可以在给定组件或配置类的基类上以及在由组件或配置类实现的接口中声明的 Java 8 默认方法上发现 <code>@Bean</code> 方法。这为组合复杂的配置安排提供了很大的灵活性，从 Spring 4.2 开始，通过 Java 8 默认方法甚至可以进行多重继承。</p>
<p>最后，一个类可以为同一个 bean 保留多个 <code>@Bean</code> 方法，这取决于在运行时可用的依赖关系，从而可以使用多个工厂方法。这与在其他配置方案中选择“最贪婪”的构造函数或工厂方法的算法相同：在构造时选择具有最大可满足依赖关系数量的变量，类似于容器在多个 <code>@Autowired</code> 构造函数之间进行选择的方式。</p>
</blockquote>
<h3 id="命名自动检测的组件"><a href="#命名自动检测的组件" class="headerlink" title="命名自动检测的组件"></a>命名自动检测的组件</h3><p>在扫描过程中自动检测到组件时，其 bean 名称由该扫描程序已知的 BeanNameGenerator 策略生成。 默认情况下，任何包含名称值的 Spring 构造型注释（<code>@Component</code>，<code>@Repository</code>，<code>@Service</code> 和 <code>@Controller</code>）都会将该名称提供给相应的 bean 定义。</p>
<p>如果这样的注释不包含名称，value 或者不包含任何其他检测到的组件（例如，通过自定义过滤器发现的组件），则缺省 bean 名称生成器将返回未大写的非限定类名称。例如，如果检测到以下组件类，则名称为 myMovieLister 和 movieFinderImpl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"myMovieLister"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果您不想依赖默认的 Bean 命名策略，则可以提供自定义 Bean 命名策略。首先，实现 BeanNameGenerator 接口，并确保包括默认的无参构造函数。然后，在配置扫描器时提供完全限定的类名，如以下示例注释和 Bean 定义所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, nameGenerator = MyNameGenerator.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name-generator</span>=<span class="string">"org.example.MyNameGenerator"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作为一般规则，每当其他组件可能对其进行显式引用时，请考虑使用注释指定名称。另一方面，只要容器负责接线，自动生成的名称就足够了。</p>
<h3 id="提供自动检测组件的范围"><a href="#提供自动检测组件的范围" class="headerlink" title="提供自动检测组件的范围"></a>提供自动检测组件的范围</h3><p>通常，与 Spring 管理的组件一样，自动检测到的组件的默认且最常见的作用域是单例。 但是，有时您需要使用@Scope 批注指定的其他范围。 您可以在注释中提供范围的名称，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Scope</code> 注释仅在具体的 bean 类（对于带注释的组件）或工厂方法（对于 <code>@Bean</code> 方法）上进行内省。 与 XML bean 定义相反，没有 bean 定义继承的概念，并且在类级别的继承层次结构与元数据目的无关。</p>
<p>有关特定于 Web 的范围的详细信息，例如 Spring 上下文中的“request”或“session”，请参见 Request，Session，Application 和 WebSocket Scope。与这些作用域的预构建批注一样，您也可以使用 Spring 的元注释方法来组成自己的作用域注释：例如，用@Scope(“prototype”)，进行元注释的自定义注释，也可能会声明自定义作用域代理模式。</p>
<blockquote>
<p>要提供用于范围解析的自定义策略，而不是依赖于基于注释的方法，可以实现该 ScopeMetadataResolver 接口。确保包括默认的无参数构造函数。然后，可以在配置扫描程序时提供完全限定的类名，如以下注释和 Bean 定义示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, scopeResolver = MyScopeResolver.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">scope-resolver</span>=<span class="string">"org.example.MyScopeResolver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用某些非单作用域时，可能有必要为作用域对象生成代理。在范围 Bean 中将推理描述为依赖项。为此，在 component-scan 元素上可以使用 scoped-proxy 属性。三个可能的值是：no，interfaces，和 targetClass。例如，以下配置生成标准的 JDK 动态代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, scopedProxy = ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">scoped-proxy</span>=<span class="string">"interfaces"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="提供带有注释的限定符元数据"><a href="#提供带有注释的限定符元数据" class="headerlink" title="提供带有注释的限定符元数据"></a>提供带有注释的限定符元数据</h3><p>在@Qualifier 注释中讨论与预选赛微调基于注解的自动连接。该部分中的示例演示了如何使用@Qualifier 注释和自定义限定符注释在解析自动装配候选时提供细粒度的控制。由于这些示例基于 XML Bean 定义，因此通过使用 XML 中的元素的 qualifier 或 meta 子元素，在候选 Bean 定义上提供了限定符元数据 bean。当依靠类路径扫描来自动检测组件时，可以在候选类上为限定符元数据提供类型级别的注释。下面的三个示例演示了此技术：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"Action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Genre</span>(<span class="string">"Action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Offline</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与大多数基于注释的替代方法一样，请记住，注释元数据绑定到类定义本身，而 XML 的使用允许相同类型的多个 bean 提供其限定符元数据的变体，因为该元数据是按-instance 而不是按类。</p>
</blockquote>
<h3 id="生成候选组件的索引"><a href="#生成候选组件的索引" class="headerlink" title="生成候选组件的索引"></a>生成候选组件的索引</h3><p>尽管类路径扫描非常快，但可以通过在编译时创建静态候选列表来提高大型应用程序的启动性能。在这种模式下，作为组件扫描目标的所有模块都必须使用此机制。</p>
<blockquote>
<p>您现有的 <code>@ComponentScan</code> 或 <code>&lt;context:component-scan&gt;</code> 指令必须保持原样，以请求上下文扫描某些软件包中的候选对象。当 ApplicationContext 检测到这样的索引时，它将自动使用它而不是扫描类路径。</p>
</blockquote>
<p>要生成索引，请向每个包含组件的模块添加附加依赖关系，这些组件是组件扫描指令的目标。以下示例显示了如何使用 Maven 进行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于 Gradle 4.5 和更早版本，应在 <code>compileOnly</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">"org.springframework:spring-context-indexer:5.1.8.RELEASE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Gradle 4.6 及更高版本，应在 <code>annotationProcessor</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    annotationProcessor <span class="string">"org.springframework:spring-context-indexer:5.1.8.RELEASE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程将生成一个 <code>META-INF/spring.components</code> 包含在 jar 文件中的文件。</p>
<blockquote>
<p>在 IDE 中使用此模式时，<code>spring-context-indexer</code> 必须将其注册为注释处理器，以确保在更新候选组件时索引是最新的。</p>
<p><code>META-INF/spring.components</code>在类路径上找到 <code>a</code> 时，索引将自动启用。如果某个索引对于某些库（或用例）部分可用，但无法为整个应用程序构建，则可以通过将设置 <code>spring.index.ignore</code>为 <code>true</code>，来回退到常规的类路径安排（好像根本没有索引）属性或 <code>spring.properties</code> 类路径根目录下的文件中。</p>
</blockquote>
<h2 id="使用-JSR-330-标准注释"><a href="#使用-JSR-330-标准注释" class="headerlink" title="使用 JSR 330 标准注释"></a>使用 JSR 330 标准注释</h2><p>从 Spring 3.0 开始，Spring 提供对 JSR-330 标准注释（依赖注入）的支持。这些注释的扫描方式与 Spring 注释的扫描方式相同。要使用它们，您需要在类路径中有相关的 jar。</p>
<blockquote>
<p>如果使用 Maven，<code>javax.inject</code> 则可以在标准 Maven 存储库（<a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/）中找到该工件。您可以将以下依赖项添加到文件" target="_blank" rel="noopener">https://repo1.maven.org/maven2/javax/inject/javax.inject/1/）中找到该工件。您可以将以下依赖项添加到文件</a> pom.xml 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="与-Inject-和的依赖注入-Named"><a href="#与-Inject-和的依赖注入-Named" class="headerlink" title="与 @Inject 和的依赖注入 @Named"></a>与 @Inject 和的依赖注入 @Named</h2><p>除了 <code>@Autowired</code>，您可以使用 <code>@javax.inject.Inject</code> 以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMovies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder.findMovies(...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与一样 <code>@Autowired</code>，您可以 <code>@Inject</code> 在字段级别，方法级别和构造函数参数级别使用。此外，您可以将注入点声明为 <code>Provider</code>，以允许按需访问范围更短的 bean，或者通过 <code>Provider.get()</code> 调用延迟访问其他 bean 。以下示例提供了先前示例的变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Provider&lt;MovieFinder&gt; movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(Provider&lt;MovieFinder&gt; movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMovies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder.get().findMovies(...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要为应该注入的依赖项使用限定名称，则应使用 <code>@Named</code> 批注，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(@Named(<span class="string">"main"</span>)</span> MovieFinder movieFinder) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与一样 <code>@Autowired</code>，<code>@Inject</code> 也可以与 <code>java.util.Optional</code> 或一起使用<code>@Nullable</code>。这在这里更为适用，因为 <code>@Inject</code> 它没有 <code>required</code> 属性。以下示例展示了如何使用 <code>@Inject</code> 和 <code>@Nullable</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(@Nullable MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Named-和-ManagedBean：-Component-注释的标准等效项"><a href="#Named-和-ManagedBean：-Component-注释的标准等效项" class="headerlink" title="@Named 和 @ManagedBean：@Component 注释的标准等效项"></a>@Named 和 @ManagedBean：@Component 注释的标准等效项</h3><p>代替@Component，您可以使用@javax.inject.Named 或 javax.annotation.ManagedBean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span>(<span class="string">"movieListener"</span>)  <span class="comment">// @ManagedBean("movieListener") could be used as well</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>@Component</code> 不指定组件名称的情况下使用非常常见。<code>@Named</code> 可以类似的方式使用，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>@Named</code>或 <code>@ManagedBean</code> 时，可以使用与使用 Spring 注释完全相同的方式来使用组件扫描，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与相比@Component，JSR-330 @Named 和 JSR-250 ManagedBean 注释是不可组合的。您应该使用 Spring 的构造型模型来构建自定义组件注释。</p>
</blockquote>
<h3 id="JSR-330-标准注释的局限性"><a href="#JSR-330-标准注释的局限性" class="headerlink" title="JSR-330 标准注释的局限性"></a>JSR-330 标准注释的局限性</h3><p>当使用标准注释时，您应该知道某些重要功能不可用，如下表所示：</p>
<p>表 6. Spring 组件模型元素与 JSR-330 变体</p>
<table>
<thead>
<tr>
<th>Spring</th>
<th>javax.inject.*</th>
<th>javax.inject 限制/注释</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>@Inject</td>
<td>@Inject 没有“必填”属性。可以与 Java 8 一起使用 Optional。</td>
</tr>
<tr>
<td>@Component</td>
<td>@Named / @ManagedBean</td>
<td>JSR-330 不提供可组合的模型，仅提供一种识别命名组件的方法。</td>
</tr>
<tr>
<td>@Scope(“singleton”)</td>
<td>@Singleton</td>
<td>JSR-330 的默认范围类似于 Spring 的 prototype。但是，为了使其与 Spring 的默认默认值保持一致，默认情况下，在 Spring 容器中声明的 JSR-330 bean 是 a singleton。为了使用之外的范围 singleton，您应该使用 Spring 的@Scope 注释。<code>javax.inject</code> 还提供了 @Scope 批注。不过，此仅用于创建自己的注释。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>@Qualifier / @Named</td>
<td>javax.inject.Qualifier 只是用于构建自定义限定符的元注释。具体的 String 限定词（例如@Qualifier 带有值的 Spring 的限定词）可以通过关联 javax.inject.Named。</td>
</tr>
<tr>
<td>@Value</td>
<td>-</td>
<td>没有等效</td>
</tr>
<tr>
<td>@Required</td>
<td>-</td>
<td>没有等效</td>
</tr>
<tr>
<td>@Lazy</td>
<td>-</td>
<td>没有等效</td>
</tr>
<tr>
<td>ObjectFactory</td>
<td>Provider</td>
<td>javax.inject.Provider 是 Spring 的直接替代方法 ObjectFactory，只是 get()方法名称较短。它也可以与 Spring @Autowired 或非注释构造函数和 setter 方法结合使用。</td>
</tr>
</tbody></table>
<h2 id="基于-Java-的容器配置"><a href="#基于-Java-的容器配置" class="headerlink" title="基于 Java 的容器配置"></a>基于 Java 的容器配置</h2><p>本节介绍如何在 Java 代码中使用注释来配置 Spring 容器。它包括以下主题：</p>
<ul>
<li>基本概念：<code>@Bean</code> 和 <code>@Configuration</code></li>
<li>使用实例化 Spring 容器 AnnotationConfigApplicationContext</li>
<li>使用@Bean 注释</li>
<li>使用@Configuration 注释</li>
<li>组成基于 Java 的配置</li>
<li>Bean 定义配置文件</li>
<li>PropertySource 抽象化</li>
<li>运用 @PropertySource</li>
<li>声明中的占位符解析</li>
</ul>
<h3 id="基本概念：-Bean-和-Configuration"><a href="#基本概念：-Bean-和-Configuration" class="headerlink" title="基本概念：@Bean 和 @Configuration"></a>基本概念：<code>@Bean</code> 和 <code>@Configuration</code></h3><p>Spring 的新 Java 配置支持中的主要构件是 <code>@Configuration</code> 注释的类和 <code>@Bean</code> 注释的方法。</p>
<p><code>@Bean</code>批注用于指示方法实例化，配置和初始化要由 Spring IoC 容器管理的新对象。 对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code> XML 配置的人来说，<code>@Bean</code> 注释与 <code>&lt;bean/&gt;</code>元素具有相同的作用。 您可以将 <code>@Bean</code> 批注方法与任何 Spring <code>@Component</code> 一起使用。 但是，它们最常与 <code>@Configuration</code> bean 一起使用。</p>
<p>用注释类 <code>@Configuration</code> 表示其主要目的是作为 Bean 定义的来源。此外，<code>@Configuration</code> 类允许通过调用 <code>@Bean</code> 同一类中的其他方法来定义 Bean 之间的依赖关系。最简单的 <code>@Configuration</code> 类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一 <code>AppConfig</code> 类等效于以下 Spring <code>&lt;beans/&gt;</code> XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"com.acme.services.MyServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>完整的 <code>@Configuration</code> 与“精简” <code>@Bean</code> 模式？</p>
<p>如果在未使用 <code>@Configuration</code> 注释的类中声明 <code>@Bean</code> 方法，则将它们称为以“精简”模式进行处理。在 <code>@Component</code> 或是甚至在简单的旧类中声明的 Bean 方法被认为是“精简版”，其中包含类的主要目的不同，而 <code>@Bean</code> 方法在那里具有某种优势。例如，服务组件可以通过每个适用组件类上的其他 <code>@Bean</code> 方法将管理视图公开给容器。在这种情况下，<code>@Bean</code> 方法是一种通用的工厂方法机制。</p>
<p>与完整的 <code>@Configuration</code> 不同，精简 <code>@Bean</code> 方法无法声明 Bean 之间的依赖关系。取而代之的是，它们在其包含组件的内部状态上进行操作，并且还可以根据其可能声明的参数进行操作。因此，此类 <code>@Bean</code> 方法不应调用其他 <code>@Bean</code> 方法。实际上，每个此类方法仅是用于特定 bean 引用的工厂方法，而没有任何特殊的运行时语义。这里的积极副作用是，不必在运行时应用 CGLIB 子类，因此在类设计方面没有任何限制（即，包含类可能是 final 修饰之类的）。</p>
<p>在常见情况下，<code>@Bean</code> 方法将在 <code>@Configuration</code> 类中声明，以确保始终使用“完全”模式，因此跨方法引用将重定向到容器的生命周期管理。这样可以防止通过常规 Java 调用意外地调用同一 <code>@Bean</code> 方法，从而有助于减少在“精简”模式下运行时难以追查的细微错误。</p>
</blockquote>
<p>以下各节将详细讨论 <code>@Bean</code> 和 <code>@Configuration</code> 批注。 但是，首先，我们介绍了使用基于 Java 的配置来创建 spring 容器的各种方法。</p>
<h3 id="使用实例化-Spring-容器-AnnotationConfigApplicationContext"><a href="#使用实例化-Spring-容器-AnnotationConfigApplicationContext" class="headerlink" title="使用实例化 Spring 容器 AnnotationConfigApplicationContext"></a>使用实例化 Spring 容器 AnnotationConfigApplicationContext</h3><p>以下各节介绍了 Spring 3.0 中引入的 Spring 的 AnnotationConfigApplicationContext。这种通用的 ApplicationContext 实现不仅能够接受 <code>@Configuration</code> 类作为输入，而且还可以接受普通的 <code>@Component</code> 类和带有 JSR-330 元数据注释的类。</p>
<p>当提供 <code>@Configuration</code> 类作为输入时，<code>@Configuration</code> 类本身将注册为 Bean 定义，并且该类中所有已声明的 <code>@Bean</code> 方法也将注册为 Bean 定义。</p>
<p>提供 <code>@Component</code> 和 JSR-330 类时，它们将注册为 bean 定义，并且假定在必要时在这些类中使用了诸如 <code>@Autowired</code> 或 <code>@Inject</code> 之类的 DI 元数据。</p>
<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>与实例化 ClassPathXmlApplicationContext 时将 Spring XML 文件用作输入的方式几乎相同，您可以在实例化 AnnotationConfigApplicationContext 时将 <code>@Configuration</code> 类用作输入。如下面的示例所示，这允许完全不使用 XML 来使用 Spring 容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述，AnnotationConfigApplicationContext 不限于仅与 <code>@Configuration</code> 类一起使用。 可以将任何 <code>@Component</code> 或 JSR-330 带注释的类作为输入提供给构造函数，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的示例假定 MyServiceImpl，Dependency1 和 Dependency2 使用 Spring 依赖项注入注释，例如 <code>@Autowired</code>。</p>
<h4 id="通过使用-register-Class-lt-gt-…​-以编程方式构建容器"><a href="#通过使用-register-Class-lt-gt-…​-以编程方式构建容器" class="headerlink" title="通过使用 register(Class&lt;?&gt;…​) 以编程方式构建容器"></a>通过使用 register(Class&lt;?&gt;…​) 以编程方式构建容器</h4><p>您可以使用无参构造函数实例化 AnnotationConfigApplicationContext，然后使用 register() 方法对其进行配置。以编程方式构建 AnnotationConfigApplicationContext 时，此方法特别有用。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-scan-String…​-启用组件扫描"><a href="#使用-scan-String…​-启用组件扫描" class="headerlink" title="使用 scan(String…​) 启用组件扫描"></a>使用 scan(String…​) 启用组件扫描</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.acme"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.scan(<span class="string">"com.acme"</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>@Configuration</code> 类带有 <code>@Component</code> 元注解，因此是组件扫描的候选对象。在前面的示例中，假定 <code>AppConfig</code> 在 <code>com.acme</code> 包（或下面的任何包）中声明，那么在调用 <code>scan()</code> 时，<code>@Configuration</code> 类被检测到并注册，但不会注册其中的 <code>@Bean</code>。直到调用 <code>refresh()</code> 方法，其所有 <code>@Bean</code> 方法才都被处理并注册为容器内的 Bean 定义。</p>
<h4 id="支持-Web-应用程序的-AnnotationConfigWebApplicationContext"><a href="#支持-Web-应用程序的-AnnotationConfigWebApplicationContext" class="headerlink" title="支持 Web 应用程序的 AnnotationConfigWebApplicationContext"></a>支持 Web 应用程序的 AnnotationConfigWebApplicationContext</h4><p>AnnotationConfigWebApplicationContext = WebApplicationContext + AnnotationConfigApplicationContext，这个实现可以配置 Spring 的 <code>ContextLoaderListener</code> servlet 侦听器, Spring MVC 的 <code>DispatcherServlet</code> 等。以下 web.xml 代码片段配置了典型的 Spring MVC Web 应用程序 (注意 <code>contextClass</code> context-param and init-param 的使用):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">        instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">        fully-qualified @Configuration classes. Fully-qualified packages may also be</span></span><br><span class="line"><span class="comment">        specified for component-scanning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">            instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">            and fully-qualified @Configuration classes --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Bean-注解"><a href="#使用-Bean-注解" class="headerlink" title="使用 @Bean 注解"></a>使用 @Bean 注解</h3><p>@Bean 是方法级别的注解，类似 XML 中的 <code>&lt;bean/&gt;</code> 元素。同时支持提供 <code>&lt;bean/&gt;</code> 的属性，例如：init-method、destroy-method、autowiring。</p>
<p>你可以使用在有 <code>@Configuration</code> 或 <code>@Component</code> 注解的类内使用 <code>@Bean</code> 注释。</p>
<h4 id="声明一个-bean"><a href="#声明一个-bean" class="headerlink" title="声明一个 bean"></a>声明一个 bean</h4><p>要声明一个 bean，可以对方法进行 @Bean 注解。您可以使用此方法在 ApplicationContext 指定为该方法的返回值的类型内注册 Bean 定义。默认情况下，bean 名称与方法名称相同。以下示例显示了@Bean 方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferServiceImpl <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的配置与下面的 Spring XML 完全等效：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个声明都使一个名为 transferService 的 bean 在 ApplicationContext 中可用，并绑定到类型为 TransferServiceImpl 的对象实例，如以下文本镜像所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferService -&gt; com.acme.TransferServiceImpl</span><br></pre></td></tr></table></figure>

<p>您还可以使用接口（或基类）返回类型声明@Bean 方法，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这将高级类型预测的可见性限制为指定的接口类型（TransferService）。然后，使用仅一次使容器知道的完整类型（TransferServiceImpl），就可以实例化受影响的单例 bean。非惰性单例 bean 根据其声明顺序实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试按非声明类型进行匹配（例如@Autowired TransferServiceImpl，仅 transferService 在实例化 bean 后才解析）。</p>
<p>如果您通过声明的服务接口一致地引用类型，则@Bean 返回类型可以安全地加入该设计决策。但是，对于实现多个接口的组件或由其实现类型潜在引用的组件，声明可能的最具体的返回类型（至少与引用您的 bean 的注入点所要求的具体类型一样）更为安全。</p>
<h4 id="Bean-依赖"><a href="#Bean-依赖" class="headerlink" title="Bean 依赖"></a>Bean 依赖</h4><p>带@Bean 注释的方法可以具有任意数量的参数，这些参数描述构建该 bean 所需的依赖关系。例如，如果我们 TransferService 需要一个 AccountRepository，我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析机制与基于构造函数的依赖注入几乎相同。</p>
<h4 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h4><p>用@Bean 注释定义的任何类都支持常规的生命周期回调，并且可以使用 JSR-250 中的@PostConstruct 和@PreDestroy 注释。有关更多详细信息，请参见 JSR-250 注释。</p>
<p>常规 Spring 生命周期回调也得到完全支持。如果 bean 实现 InitializingBean，DisposableBean 或 Lifecycle，则容器将调用它们各自的方法。</p>
<p>也完全支持标准*Aware 接口集（例如 BeanFactoryAware， BeanNameAware， MessageSourceAware， ApplicationContextAware 等）。</p>
<p>该@Bean 注释支持指定任意初始化和销毁回调方法，就像 Spring XML 中的 init-method 和 destroy-method 属性的 bean 元素，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// initialization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// destruction logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"cleanup"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，使用 Java config 定义的具有公开关闭或停止方法的 bean 将自动加入销毁回调。如果你有一个公开的关闭或停止方法，但是你不希望在容器关闭时被调用，只需将@Bean（destroyMethod =””）添加到你的 bean 定义中即可禁用默认（推测）模式。 默认情况下，您可能希望通过 JNDI 获取资源，因为它的生命周期在应用程序之外进行管理。特别地，请确保始终为 DataSource 执行此操作，因为它已知在 Java EE 应用程序服务器上有问题。</p>
<p>默认情况下，您可能要对通过 JNDI 获取的资源执行此操作，因为其生命周期是在应用程序外部进行管理的。特别是，请确保始终对进行操作 DataSource，因为这在 Java EE 应用程序服务器上是有问题的。</p>
<p>以下示例显示了如何防止对的自动销毁回调 DataSource：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (DataSource) jndiTemplate.lookup(<span class="string">"MyDS"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，通过@Bean 方法，通常会选择使用编程来进行 JNDI 查找：要么使用 Spring 的 JndiTemplate/JndiLocatorDelegate 帮助类，要么直接使用 JNDI InitialContext，但不能使用 JndiObjectFactoryBean 变体来强制将返回类型声明为 FactoryBean 类型以代替目标的实际类型，它将使得在其他@Bean 方法中更难用于交叉引用调用这些在此引用提供资源的方法。<br>当然上面的 BeanOne 例子中，在构造期间直接调用 init()方法同样有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanOne beanOne = <span class="keyword">new</span> BeanOne();</span><br><span class="line">        beanOne.init();</span><br><span class="line">        <span class="keyword">return</span> beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您直接在 Java 中工作时，您可以对对象执行任何您喜欢的操作，并不总是需要依赖容器生命周期。</p>
<h4 id="指定-bean-的作用域"><a href="#指定-bean-的作用域" class="headerlink" title="指定 bean 的作用域"></a>指定 bean 的作用域</h4><h5 id="使用-Scope-注解"><a href="#使用-Scope-注解" class="headerlink" title="使用@Scope 注解"></a>使用@Scope 注解</h5><p>你可以指定@Bean 注解定义的 bean 应具有的特定作用域。你可以使用 Bean 作用域章节中的任何标准作用域。</p>
<p>默认的作用域是单例，但是你可以用@Scope 注解重写作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encryptor <span class="title">encryptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Scope-和-scope-代理"><a href="#Scope-和-scope-代理" class="headerlink" title="@Scope 和 scope 代理"></a>@Scope 和 scope 代理</h5><p>Spring 提供了一个通过范围代理来处理范围依赖的便捷方法。使用 XML 配置创建此类代理的最简单方法是元素。使用@Scope 注解配置 Java 中的 bean 提供了与 proxyMode 属性相似的支持。默认是没有代理（ScopedProxyMode.NO），但您可以指定 ScopedProxyMode.TARGET_CLASS 或 ScopedProxyMode.INTERFACES。</p>
<p>如果你使用 Java 将 XML 参考文档（请参阅上述链接）到范围的@Bean 中移植范围限定的代理示例，则它将如下所示<br>如果你将 XML 参考文档的 scoped 代理示例转化为 Java @Bean，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPreferences <span class="title">userPreferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Service <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserService service = <span class="keyword">new</span> SimpleUserService();</span><br><span class="line">    <span class="comment">// a reference to the proxied userPreferences bean</span></span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-Bean-命名"><a href="#自定义-Bean-命名" class="headerlink" title="自定义 Bean 命名"></a>自定义 Bean 命名</h4><p>默认情况下，配置类使用@Bean 方法的名称作为结果 bean 的名称。但是，可以使用 name 属性覆盖此功能，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"myThing"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean-别名"><a href="#Bean-别名" class="headerlink" title="Bean 别名"></a>Bean 别名</h4><p>如前文命名 bean 中所讨论的，有时希望为单个 Bean 提供多个名称，否则会导致 Bean 混淆。 为此 name，@Bean 注释的属性接受 String 数组。以下示例显示了如何为 bean 设置多个别名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(&#123;<span class="string">"dataSource"</span>, <span class="string">"subsystemA-dataSource"</span>, <span class="string">"subsystemB-dataSource"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean-描述"><a href="#Bean-描述" class="headerlink" title="Bean 描述"></a>Bean 描述</h4><p>有时，提供有关 bean 的更详细的文本描述会很有帮助。当出于监视目的而暴露（可能通过 JMX）bean 时，这特别有用。</p>
<p>要将说明添加到@Bean，可以使用 @Description 批注，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"Provides a basic example of a bean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-Configuration-注解"><a href="#使用-Configuration-注解" class="headerlink" title="使用 @Configuration 注解"></a>使用 <code>@Configuration</code> 注解</h3><p><code>@Configuration</code> 是类级别的注释，指示对象是 Bean 定义的源。 <code>@Configuration</code> 类通过公共 <code>@Bean</code> 注释方法声明 bean。 对 <code>@Configuration</code> 类的 <code>@Bean</code> 方法的调用也可以用于定义 Bean 之间的依赖关系。 有关一般性介绍，请参见[基本概念：<code>@Bean</code> 和 <code>@Configuration</code>](&lt;#基本概念：<code>@Bean</code>\ 和\ <code>@Configuration</code>&gt;)。</p>
<h4 id="注入-bean-间的依赖关系"><a href="#注入-bean-间的依赖关系" class="headerlink" title="注入 bean 间的依赖关系"></a>注入 bean 间的依赖关系</h4><p>当 bean 相互依赖时，表示依赖关系就像让一个 bean 方法调用另一个依赖一样简单，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne(beanTwo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仅当 <code>@Bean</code> 在 <code>@Configuration</code> 类中声明该方法时，此声明 bean 间依赖关系的方法才有效。您不能使用普通 <code>@Component</code> 类声明 bean 间的依赖关系。</p>
</blockquote>
<h4 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h4><p>如前所述，<a href="https://halelu.github.io/2019/07/spring-1/#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5">查找方法注入</a>是一项高级功能，您应该很少使用。在单例作用域的 bean 对原型作用域的 bean 有依赖性的情况下，这很有用。将 Java 用于这种类型的配置为实现这种模式提供了自然的方法。以下示例显示如何使用查找方法注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 Java 配置，可以创建一个覆盖 <code>CommandManager</code> 抽象 <code>createCommand()</code> 方法的子类，该方法将以某种方式查找新的（原型）命令对象。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> AsyncCommand <span class="title">asyncCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncCommand command = <span class="keyword">new</span> AsyncCommand();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommandManager <span class="title">commandManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with createCommand()</span></span><br><span class="line">    <span class="comment">// overridden to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有关基于-Java-的配置在内部如何工作的更多信息"><a href="#有关基于-Java-的配置在内部如何工作的更多信息" class="headerlink" title="有关基于 Java 的配置在内部如何工作的更多信息"></a>有关基于 Java 的配置在内部如何工作的更多信息</h4><p>考虑以下示例，该示例显示了一个带 <code>@Bean</code> 注释的方法被调用两次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">clientService1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">clientService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientDao <span class="title">clientDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clientDao()</code> 在 <code>clientService1()</code> 中被调用一次，并在 <code>clientService2()</code> 中被调用一次。由于此方法会创建一个 <code>ClientDaoImpl</code> 的新实例并返回它，因此通常希望有两个实例（每个服务一个）。那肯定是有问题的：在 Spring 中，实例化的 bean 默认情况下具有单例作用域。这就是神奇之处所在：所有 <code>@Configuration</code> 类在启动时都使用 CGLIB 进行了子类化。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器中是否有任何缓存（作用域）的 bean。</p>
<blockquote>
<p>根据 bean 的作用域，行为可能有所不同。我们在这里只谈论单例。</p>
</blockquote>
<blockquote>
<p>从 Spring 3.2 开始，不再需要将 CGLIB 添加到您的类路径中，因为 CGLIB 类已经被重新打包 <code>org.springframework.cglib</code> 并直接包含在 spring-core JAR 中。</p>
</blockquote>
<blockquote>
<p>由于 CGLIB 在启动时会动态添加功能，因此存在一些限制。特别是，配置类不能是 final。但是，从 4.3 版本开始，配置类上允许使用任何构造函数，包括 <code>@Autowired</code> 对默认注入使用或单个非默认构造函数声明。</p>
<p>如果您希望避免 CGLIB 施加的限制，请考虑 <code>@Bean</code> 在非 <code>@Configuration</code> 类上声明您的方法（例如，在普通 <code>@Component</code> 类上声明）。那么 <code>@Bean</code> 就不会截获方法之间的跨方法调用，因此您必须专门依赖那里的构造函数或方法级别的依赖项注入。</p>
</blockquote>
<h3 id="组成基于-Java-的配置"><a href="#组成基于-Java-的配置" class="headerlink" title="组成基于 Java 的配置"></a>组成基于 Java 的配置</h3><p>Spring 的基于 Java 的配置功能使您可以编写批注，这可以降低配置的复杂性。</p>
<h4 id="使用-Import-注释"><a href="#使用-Import-注释" class="headerlink" title="使用 @Import 注释"></a>使用 <code>@Import</code> 注释</h4><p>就像 <code>&lt;import/&gt;</code> 在 Spring XML 文件中使用该元素来帮助模块化配置一样，<code>@Import</code> 注释允许 <code>@Bean</code> 从另一个配置类加载定义，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigA.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，无需同时指定两者 <code>ConfigA.class</code> 和 <code>ConfigB.class</code> 实例化上下文，只需 <code>ConfigB</code> 显式提供，如以下示例所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">    A a = ctx.getBean(A.class);</span><br><span class="line">    B b = ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法简化了容器的实例化，因为只需要处理一个类，而无需在构造过程中记住大量潜在的 <code>@Configuration</code> 类。</p>
<p>从 Spring Framework 4.2 开始，<code>@Import</code> 还支持对常规组件类的引用，类似于 <code>AnnotationConfigApplicationContext.register</code> 方法。如果要通过使用一些配置类作为入口点来显式定义所有组件，从而避免组件扫描，则此功能特别有用。</p>
<h5 id="注入对导入-Bean-定义的依赖"><a href="#注入对导入-Bean-定义的依赖" class="headerlink" title="注入对导入@Bean 定义的依赖"></a>注入对导入@Bean 定义的依赖</h5><p>前面的示例有效，但过于简单。在大多数实际情况下，Bean 在配置类之间相互依赖。使用 XML 时，这不是问题，因为不涉及编译器，并且您可以声明 <code>ref=&quot;someBean&quot;</code> 并信任 Spring 在容器初始化期间对其进行处理。使用 <code>@Configuration</code> 类时，Java 编译器会在配置模型上施加约束，因为对其他 bean 的引用必须是有效的 Java 语法。</p>
<p>幸运的是，解决这个问题很简单。正如我们已经讨论的那样，一个 <code>@Bean</code> 方法可以具有任意数量的描述 Bean 依赖关系的参数。考虑以下具有多个 <code>@Configuration</code> 类的更真实的场景，每个类都取决于其他类中声明的 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有另一种方法可以达到相同的结果。 请记住，<code>@Configuration</code> 类最终仅是容器中的另一个 bean：这意味着它们可以利用 <code>@Autowired</code> 和 <code>@Value</code> 注入以及与任何其他 bean 相同的其他功能。</p>
<blockquote>
<p>确保以这种方式注入的依赖项只是最简单的一种。 <code>@Configuration</code> 类是在上下文初始化期间非常早地处理的，并且强制以这种方式注入依赖项可能导致意外的早期初始化。 如上例所示，尽可能使用基于参数的注入。</p>
<p>另外，通过 <code>@Bean</code> 使用 <code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 定义时要特别小心。 通常应将这些声明为静态 <code>@Bean</code> 方法，从而不触发其包含的配置类的实例化。 否则，<code>@Autowired</code> 和 <code>@Value</code> 可能不适用于配置类本身，因为该 bean 实例的创建可能比 <code>AutowiredAnnotationBeanPostProcessor</code> 要早。</p>
</blockquote>
<p>以下示例说明如何将一个 bean 自动连接到另一个 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryConfig</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仅从 Spring Framework 4.3 开始支持 <code>@Configuration</code> 类中的构造方法注入。还要注意，如果目标 bean 仅定义了一个构造函数，那么无需指定 <code>@Autowired</code> 。</p>
</blockquote>
<h5 id="便于浏览的完全合格的导入-bean"><a href="#便于浏览的完全合格的导入-bean" class="headerlink" title="便于浏览的完全合格的导入 bean"></a>便于浏览的完全合格的导入 bean</h5><p>在前面的场景中，使用 <code>@Autowired</code> 效果很好，并提供了所需的模块化，但是要确切确定声明自动装配的 Bean 定义的位置仍然有些模棱两可。例如，当开发人员查看时 ServiceConfig，您如何确切知道该 <code>@Autowired AccountRepository</code> bean 的声明位置？它在代码中不是明确的，这可能很好。请记住， Spring Tools for Eclipse 提供了可以渲染图形的工具，这些图形显示了所有接线的方式，这可能就是您所需要的。另外，您的 Java IDE 可以轻松找到该 AccountRepository 类型的所有声明和使用，并快速向您显示<code>@Bean</code> 返回该类型的方法的位置。</p>
<p>如果这种歧义是不可接受的，并且您希望从 IDE 内部直接从一个 <code>@Configuration</code> 类导航到另一个类，请考虑自动装配配置类本身。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepositoryConfig repositoryConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// navigate 'through' the config class to the @Bean method!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，在哪里定义了 <code>AccountRepository</code> 是完全显式的。但是，<code>ServiceConfig</code> 现在与 <code>RepositoryConfig</code> 紧密耦合。那是权衡。通过使用基于接口或基于抽象类的 <code>@Configuration</code> 类，可以在某种程度上缓解这种紧密耦合。考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepositoryConfig repositoryConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">AccountRepository <span class="title">accountRepository</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfig</span> <span class="keyword">implements</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, DefaultRepositoryConfig.class&#125;)  <span class="comment">// import the concrete config!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>ServiceConfig</code> 就具体而言松散耦合 <code>DefaultRepositoryConfig</code>，并且内置的 IDE 工具仍然有用：您可以轻松地获得实现的类型层次结构 <code>RepositoryConfig</code>。通过这种方式，导航 <code>@Configuration</code> 类及其依赖项与导航基于接口的代码的通常过程没有什么不同。</p>
<p>如果要影响某些 Bean 的启动创建顺序，请考虑将其中一些声明为 <code>@Lazy</code>（用于首次访问而不是在启动时创建）或声明为 <code>@DependsOn</code> 某些其他 Bean（确保在当前 Bean 之前创建特定的其他 Bean），后者的直接依赖意味着什么）。</p>
<h4 id="有条件地包含-Configuration-类或-Bean-方法"><a href="#有条件地包含-Configuration-类或-Bean-方法" class="headerlink" title="有条件地包含 @Configuration 类或 @Bean 方法"></a>有条件地包含 <code>@Configuration</code> 类或 <code>@Bean</code> 方法</h4><p>根据某些系统状态，有条件地启用或禁用完整的 <code>@Configuration</code> 类甚至单个 <code>@Bean</code> 方法通常很有用。一个常见的示例是仅在 Spring 环境中启用了特定配置文件后，才使用<code>@Profile</code> 批注来激活 Bean（有关详细信息，请参见后文 Bean 定义配置文件）。</p>
<p><code>@Profile</code> 批注实际上是通过使用更灵活的称为 <code>@Conditional</code> 的批注来实现的。 <code>@Conditional</code> 批注指示在注册 <code>@Bean</code> 之前应参考的特定 <code>org.springframework.context.annotation.Condition</code> 实现。</p>
<p><code>Condition</code> 接口的实现提供了一个 <code>matches(…)</code> 方法，该方法返回 <code>true</code> 或 <code>false</code>。例如，以下清单显示了用于 <code>@Profile</code> 的实际 <code>Condition</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read the @Profile annotation attributes</span></span><br><span class="line">    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object value : attrs.get(<span class="string">"value"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(((String[]) value))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关 <code>@Conditional</code> 更多详细信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/5.3.0-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html" target="_blank" rel="noopener">javadoc</a>。</p>
<h4 id="结合-Java-和-XML-配置"><a href="#结合-Java-和-XML-配置" class="headerlink" title="结合 Java 和 XML 配置"></a>结合 Java 和 XML 配置</h4><p>Spring 的 <code>@Configuration</code> 类支持并非旨在 100％ 完全替代 Spring XML。 某些工具（例如 Spring XML 名称空间）仍然是配置容器的理想方法。 在使用 XML 方便或有必要的情况下，您可以选择：使用“以 XML 为中心”的方式实例化容器，比如 <code>ClassPathXmlApplicationContext</code> ，或使用“以 Java 中心”的方式实例化容器，也就是使用 <code>AnnotationConfigApplicationContext</code> 和 <code>@ImportResource</code> 批注来根据需要导入 XML。</p>
<h5 id="以-XML-为中心的-Configuration-类使用"><a href="#以-XML-为中心的-Configuration-类使用" class="headerlink" title="以 XML 为中心的 @Configuration 类使用"></a>以 XML 为中心的 <code>@Configuration</code> 类使用</h5><p>最好从 XML 引导 Spring 容器并以 ad-hoc 方式包含 <code>@Configuration</code> 类。 例如，在使用 Spring XML 的大型现有代码库中，根据需要创建 <code>@Configuration</code> 类并从现有 XML 文件中将它们包含在内会变得更加容易。 在本节的后面，我们将介绍在这种“以 XML 为中心”的情况下使用 <code>@Configuration</code> 类的选项。</p>
<h6 id="将-Configuration-类声明为纯-Spring-lt-bean-gt-元素"><a href="#将-Configuration-类声明为纯-Spring-lt-bean-gt-元素" class="headerlink" title="将 @Configuration 类声明为纯 Spring &lt;bean/&gt; 元素"></a>将 <code>@Configuration</code> 类声明为纯 Spring <code>&lt;bean/&gt;</code> 元素</h6><p>请记住，<code>@Configuration</code> 类最终是容器中的 bean 定义。在本系列示例中，我们创建一个名为 <code>AppConfig</code> 的 <code>@Configuration</code> 类， 并将其包含在<code>system-test-config.xml</code> 中作为 <code>&lt;bean/&gt;</code> 定义。因为 <code>&lt;context:annotation-config/&gt;</code> 已打开，所以容器会识别 <code>@Configuration</code> 注释并正确处理 <code>AppConfig</code> 中声明的 <code>@Bean</code> 方法。</p>
<p>以下示例显示了 Java 中的普通配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了示例 <code>system-test-config.xml</code> 文件的一部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.acme.AppConfig"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下示例显示了一个可能的 <code>jdbc.properties</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:hsqldb:hsql://localhost/xdb</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/com/acme/system-test-config.xml"</span>);</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>system-test-config.xml</code> 文件中，<code>AppConfig</code> <code>&lt;bean/&gt;</code> 没有声明 <code>id</code> 元素。尽管申明一下是可以接受的，但由于没有其他 bean 引用过它，因此这是不必要的，并且不太可能通过名称从容器中显式获取。同样，<code>DataSource</code> 仅按类型自动对 Bean 进行接线，因此也并不严格要求 <code>id</code> 定义。</p>
</blockquote>
<h6 id="使用-lt-context：component-scan-gt-拾取-Configuration-类"><a href="#使用-lt-context：component-scan-gt-拾取-Configuration-类" class="headerlink" title="使用 &lt;context：component-scan/&gt;拾取 @Configuration 类"></a>使用 <code>&lt;context：component-scan/&gt;</code>拾取 <code>@Configuration</code> 类</h6><p>因为 <code>@Configuration</code> 用 <code>@Component</code> 进行元注释，所以 <code>@Configuration</code> 注释的类自动成为组件扫描的候选对象。使用与先前示例中描述的场景相同的场景，我们可以重新定义 <code>system-test-config.xml</code> 以利用组件扫描的优势。请注意，在这种情况下，我们无需显式声明 <code>&lt;context：annotation-config/&gt;</code>，因为 <code>&lt;context：component-scan/&gt;</code> 可启用相同的功能。</p>
<p>以下示例显示了修改后的 <code>system-test-config.xml</code> 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.acme"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Configuration-以类为中心的-XML-与-ImportResource"><a href="#Configuration-以类为中心的-XML-与-ImportResource" class="headerlink" title="@Configuration 以类为中心的 XML 与 @ImportResource"></a><code>@Configuration</code> 以类为中心的 XML 与 <code>@ImportResource</code></h5><p>在 <code>@Configuration</code> 类是配置容器的主要机制的应用程序中，仍然有必要至少使用一些 XML。在这些情况下，您可以使用 <code>@ImportResource</code> 并仅定义所需的 XML。这样做实现了一种“以 Java 为中心”的方法来配置容器，并将 XML 保持在最低限度。以下示例（包括配置类，定义 Bean 的 XML 文件，属性文件和主类）显示了如何使用 <code>@ImportResource</code> 批注来实现按需使用 XML 的以 Java 为中心的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:/com/acme/properties-config.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>properties-config.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>jdbc.properties：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:hsqldb:hsql://localhost/xdb</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环境抽象"><a href="#环境抽象" class="headerlink" title="环境抽象"></a>环境抽象</h2><p><code>Environment</code> 接口是集成在容器中的抽象，它对应用程序环境的两个关键方面进行建模：概要文件（profiles）和属性（properties）。</p>
<p>profile 是仅在给定概要文件处于活动状态时才向容器注册的 Bean 定义的命名逻辑组。可以将 Bean 通过 XML 定义还或注释方式分配给 profile。与 profile 相关的 <code>Environment</code> 对象的作用是确定当前哪些 profile（如果有）处于活动状态，以及默认情况下哪些 profile（如果有）应处于活动状态。</p>
<p>properties 在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：属性文件，JVM 系统属性，系统环境变量，JNDI，Servlet 上下文参数，ad-hoc <code>Properties</code> 对象，<code>Map</code> 对象等。<code>Environment</code> 对象与 properties 相关的作用是为用户提供方便的服务接口，用于配置属性源并从中解析属性。</p>
<h3 id="Bean-定义配置文件（profiles）"><a href="#Bean-定义配置文件（profiles）" class="headerlink" title="Bean 定义配置文件（profiles）"></a>Bean 定义配置文件（profiles）</h3><p>Bean 定义配置文件在核心容器中提供了一种机制，该机制允许在不同环境中注册不同的 Bean。“环境”一词对不同的用户可能具有不同的含义，并且此功能可以帮助解决许多用例，包括：</p>
<ul>
<li>在开发中针对内存中的数据源进行工作，而不是在进行 QA 或生产时从 JNDI 查找相同的数据源。</li>
<li>仅在将应用程序部署到性能环境中时注册监视相关的基础设施。</li>
<li>为客户 A 和客户 B 部署注册 bean 的自定义实现。</li>
</ul>
<p>考虑实际应用中需要使用的第一个用例 <code>DataSource</code>。在测试环境中，配置可能类似于以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">        .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">        .addScript(<span class="string">"my-schema.sql"</span>)</span><br><span class="line">        .addScript(<span class="string">"my-test-data.sql"</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，假设该应用程序的数据源已在生产应用程序服务器的 JNDI 目录中注册，请考虑如何将该应用程序部署到 QA 或生产环境中。 现在，我们的 <code>dataSource</code> bean 看起来像下面的清单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题是如何根据当前环境在使用这两种变体之间进行切换。 随着时间的流逝，Spring 用户已经设计出多种方法来完成此任务，通常依赖于系统环境变量和包含 <code>${placeholder}</code> 令牌的 XML <code>&lt;import/&gt;</code>语句的组合，这些语句根据值解析为正确的配置文件路径环境变量。 Bean 定义配置文件是一个核心容器功能，可提供此问题的解决方案。</p>
<p>如果我们概括前面特定于环境的 Bean 定义示例中所示的用例，那么最终需要在某些上下文中而不是在其他上下文中注册某些 Bean 定义。 您可能会说您要在情况 A 中注册一个特定的 bean 定义配置文件，在情况 B 中注册一个不同的配置文件。我们首先更新配置以反映这种需求。</p>
<h4 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用 @Profile"></a>使用 <code>@Profile</code></h4><p>@Profile 批注可让您指示一个或多个指定的配置文件处于活动状态时有资格注册的组件。 使用前面的示例，我们可以如下重写 dataSource 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"development"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandaloneDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JndiDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如前所述，对于 <code>@Bean</code> 方法，通常选择使用程序化 JNDI 查找，方法是使用 Spring 的 <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> 帮助器或前面展示的直接 JNDI <code>InitialContext</code> 用法，而不是 <code>JndiObjectFactoryBean</code> 变体，这将迫使您将返回类型声明为 <code>FactoryBean</code> 类型。</p>
</blockquote>
<p>配置文件字符串可以包含简单的配置文件名称（例如 <code>production</code>）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑（例如 <code>production &amp; us-east</code>）。概要文件表达式中支持以下运算符：</p>
<ul>
<li><code>!</code>: 非</li>
<li><code>&amp;</code>: 与</li>
<li><code>|</code>: 或</li>
</ul>
<blockquote>
<p>您不能在不使用括号的情况下混合使用 <code>&amp;</code> 和 <code>|</code> 运算符。例如，<code>production &amp; us-east | eu-central</code> 不是有效的表达式。它必须表示为 <code>production &amp; (us-east | eu-central)</code>。</p>
</blockquote>
<p>您可以将其<code>@Profile</code>用作元注释，以创建自定义的组合注释。以下示例定义了一个自定义 <code>@Production</code> 批注，您可以将其用作替代品 <code>@Profile(&quot;production&quot;)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Production &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果用 <code>@Configuration</code> 标记了一个类，则除非一个或多个指定的配置文件处于活动状态，否则将忽略与该类关联的 <code>@Profile</code> 所有 <code>@Bean</code> 方法和 <code>@Import</code> 注释。如果一个 <code>@Component</code> 或 <code>@Configuration</code> 类标记有 <code>@Profile({&quot;p1&quot;, &quot;p2&quot;})</code>，则除非已激活配置文件“p1”或“p2”，否则该类不会注册或处理。如果给定的配置文件以 非 运算符（<code>!</code>）为前缀，则仅在该配置文件不活动时才注册带注释的元素。例如，给定<code>@Profile({&quot;p1&quot;, &quot;!p2&quot;})</code>，如果配置文件“p1”处于活动状态或配置文件“p2”未处于活动状态，则会进行注册。</p>
</blockquote>
<p><code>@Profile</code> 也可以在方法级别声明为仅包括配置类的一个特定 Bean（例如，特定 Bean 的替代变体），如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">standaloneDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>@Bean</code> 方法上使用 <code>@Profile</code> 时，可能会出现特殊情况：对于具有 <code>@Bean</code> 相同 Java 方法名称的重载方法（类似于构造函数重载），<code>@Profile</code> 需要在所有重载方法上一致声明条件。如果条件不一致，则仅重载方法中第一个声明的条件有效。因此，<code>@Profile</code> 不能用于选择具有特定参数签名的重载方法。在创建时，相同 bean 的所有工厂方法之间的解析都遵循 Spring 的构造函数解析算法。</p>
<p>如果要使用不同的概要文件条件定义备用 bean，<code>@Bean</code> name 属性需要使用不同的 Java 方法名称来指向相同的 bean 名称，如前面的示例所示。如果参数签名都相同（例如，所有变体都具有无参工厂方法），则这是首先在有效 Java 类中表示这种排列的唯一方法（因为只能有一个特定名称和参数签名的方法）。</p>
</blockquote>
<h4 id="XML-Bean-定义配置文件"><a href="#XML-Bean-定义配置文件" class="headerlink" title="XML Bean 定义配置文件"></a>XML Bean 定义配置文件</h4><p>XML 对应项是元素的 profile 属性 <code>&lt;beans&gt;</code> 。我们前面的示例配置可以用两个 XML 文件重写，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以避免<code>&lt;beans/&gt;</code>在同一文件中拆分和嵌套元素，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other bean definitions --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-bean.xsd</code> 已被限制为仅允许这些元素作为文件中的最后一个元素。这应该有助于提供灵活性，而不会引起 XML 文件混乱。</p>
<blockquote>
<p>XML 对应项不支持前面描述的配置文件表达式。但是，可以通过使用<code>!</code>运算符来取消配置文件。也可以通过嵌套配置文件来应用逻辑“与”，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">&gt;     xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">&gt;     xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span><br><span class="line">&gt;     xmlns:jee=<span class="string">"http://www.springframework.org/schema/jee"</span></span><br><span class="line">&gt;     xsi:schemaLocation=<span class="string">"..."</span>&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     &lt;!-- other bean definitions --&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     &lt;beans profile=<span class="string">"production"</span>&gt;</span><br><span class="line">&gt;         &lt;beans profile=<span class="string">"us-east"</span>&gt;</span><br><span class="line">&gt;             &lt;jee:jndi-lookup id=<span class="string">"dataSource"</span> jndi-name=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span><br><span class="line">&gt;         &lt;/beans&gt;</span><br><span class="line">&gt;     &lt;/beans&gt;</span><br><span class="line">&gt; &lt;/beans&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在前面的示例中，如果 <code>production</code> 和 <code>us-east</code> profiles 都处于活动状态，则将显示 <code>dataSource</code> bean。</p>
</blockquote>
<h4 id="激活-profile"><a href="#激活-profile" class="headerlink" title="激活 profile"></a>激活 profile</h4><p>现在我们已经更新了配置，我们仍然需要指示 Spring 哪个配置文件处于活动状态。如果我们现在启动示例应用程序，则会看到 <code>NoSuchBeanDefinitionException</code> 抛出的错误，因为容器找不到名为 <code>dataSource</code> 的 Spring bean。</p>
<p>可以通过多种方式来激活配置文件，但最直接的方法是针对可通过 <code>ApplicationContext</code> 获得的 <code>Environment</code> API 以编程方式进行配置。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"development"</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure>

<p>另外，您还可以通过 <code>spring.profiles.active</code> 属性声明性地激活配置文件，可以通过系统环境变量，JVM 系统属性，<code>web.xml</code> 中的 servlet 上下文参数 或甚至作为 JNDI 中的条目来指定配置文件 （请参见 [<code>PropertySource</code> 抽象化](&lt;#<code>PropertySource</code>\ 抽象化&gt;)）。在集成测试中，可以通过使用 <code>spring-test</code> 模块中的 <code>@ActiveProfiles</code> 注释来声明活动配置文件 （请参阅<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles" target="_blank" rel="noopener">环境配置文件的上下文配置</a>）。</p>
<p>请注意，profile 不是“非此即彼”的。您可以一次激活多个配置文件。通过编程，您可以为 <code>setActiveProfiles()</code> 方法提供多个配置文件名称，该方法接受 <code>String…</code>​ 变长参数。以下示例激活多个配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"profile1"</span>, <span class="string">"profile2"</span>);</span><br></pre></td></tr></table></figure>

<p>以声明方式，<code>spring.profiles.active</code> 可以接受以逗号分隔的配置文件名称列表，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=&quot;profile1,profile2&quot;</span><br></pre></td></tr></table></figure>

<h4 id="默认-profile"><a href="#默认-profile" class="headerlink" title="默认 profile"></a>默认 profile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"default"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有配置文件处于活动状态，则将创建上面的<code>dataSource</code>。您可以看到这是为一个或多个 bean 提供默认定义的一种方法。如果启用了任何配置文件，则默认配置文件将不适用。</p>
<p>您可以通过<code>Environment</code>上的<code>setDefaultProfiles()</code>，或者声明 <code>spring.profiles.default</code> 属性，来更改默认的配置文件的名称，。</p>
<h3 id="PropertySource-抽象"><a href="#PropertySource-抽象" class="headerlink" title="PropertySource 抽象"></a><code>PropertySource</code> 抽象</h3><p>Spring 的 <code>Environment</code> 抽象提供了对属性源可配置层次结构的搜索操作。考虑以下清单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">Environment env = ctx.getEnvironment();</span><br><span class="line"><span class="keyword">boolean</span> containsMyProperty = env.containsProperty(<span class="string">"my-property"</span>);</span><br><span class="line">System.out.println(<span class="string">"Does my environment contain the 'my-property' property? "</span> + containsMyProperty);</span><br></pre></td></tr></table></figure>

<p>在前面的代码片段中，我们看到了一种高级方式来询问 Spring 是否为当前环境定义了 <code>my-property</code> 属性。 为了解决这个问题，<code>Environment</code> 对象在一组 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/PropertySource.html" target="_blank" rel="noopener"><code>PropertySource</code></a> 对象上执行搜索。 <code>PropertySource</code> 是对键-值对源的简单抽象，Spring 的 <code>StandardEnvironment</code> 配置了两个 <code>PropertySource</code> 对象——一个代表 JVM 系统属性的集合（<code>System.getProperties()</code>），另一个代表系统环境变量的集合（<code>System.getenv()</code>）。</p>
<blockquote>
<p>这些默认属性源存在于 <code>StandardEnvironment</code> 中，供在独立应用程序中使用。<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html" target="_blank" rel="noopener"><code>StandardServletEnvironment</code></a> 用其他默认属性源（包括 <code>servlet</code> 配置和 <code>servlet</code> 上下文参数）填充。它可以有选择地启用 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jndi/JndiPropertySource.html" target="_blank" rel="noopener"><code>JndiPropertySource</code></a>。有关详细信息，请参见 javadoc。</p>
</blockquote>
<p>具体来说，当您使用<code>StandardEnvironment</code>时，<code>env.containsProperty(&quot;my-property&quot;)</code> 如果运行时存在 <code>my-property</code> 系统属性或 <code>my-property</code> 环境变量，则对的调用将返回 true 。</p>
<blockquote>
<p>执行的搜索是分层的。默认情况下，系统属性优先于环境变量。因此，如果<code>my-property</code>在调用期间在两个地方同时设置了 <code>env.getProperty(&quot;my-property&quot;)</code> 该属性，则系统属性值将“获胜”并返回。请注意，属性值不会合并，而是会被前面的条目完全覆盖。</p>
<p>对于常规 <code>StandardServletEnvironment</code>，完整层次结构如下，最高优先级条目位于顶部：</p>
<ol>
<li>ServletConfig 参数（如果适用，例如在 <code>DispatcherServlet</code> 上下文的情况下）</li>
<li>ServletContext 参数（<code>web.xml</code> 的 <code>context-param</code> 条目）</li>
<li>JNDI 环境变量（<code>java:comp/env/</code> 条目）</li>
<li>JVM 系统属性（-D 命令行参数）</li>
<li>JVM 系统环境（操作系统环境变量）</li>
</ol>
</blockquote>
<p>最重要的是，整个机制是可配置的。也许您有一个要集成到此搜索中的自定义属性源。为此，请实现并实例化自己的 <code>PropertySource</code> 实例并将其添加到 <code>Environment</code> 的 <code>PropertySourcescurrent</code> 集合中。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">MutablePropertySources sources = ctx.getEnvironment().getPropertySources();</span><br><span class="line">sources.addFirst(<span class="keyword">new</span> MyPropertySource());</span><br></pre></td></tr></table></figure>

<p>在前面的代码中，<code>MyPropertySource</code> 已在搜索中添加了最高优先级。如果它包含一个<code>my-property</code> 属性，则检测并返回该属性，超越其他 <code>PropertySource</code> 中的<code>my-property</code> 属性 。<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/MutablePropertySources.html" target="_blank" rel="noopener"><code>MutablePropertySources</code></a> API 公开了许多方法，这些方法允许对属性源集进行精确操作。</p>
<h3 id="使用-PropertySource"><a href="#使用-PropertySource" class="headerlink" title="使用 @PropertySource"></a>使用 @PropertySource</h3><p><code>@PropertySource</code> 注解提供了一种添加<code>PropertySource</code> 到 Spring 的<code>Environment</code> 的便利和声明性的机制。</p>
<p>给定一个名为 <code>app.properties</code> 的文件，包含键-值对 <code>testbean.name=myTestBean</code>，下面的 <code>@Configuration</code> 类使用 <code>@PropertySource</code>，其方式是对 <code>testBean.getName()</code> 的调用返回 <code>myTestBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/myco/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestBean testBean = <span class="keyword">new</span> TestBean();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">"testbean.name"</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@PropertySource</code> 资源位置中存在的任何 <code>${…}</code> 占位符都是根据已经针对该环境注册的一组属性源来解析的，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestBean testBean = <span class="keyword">new</span> TestBean();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">"testbean.name"</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 <code>my.placeholder</code> 存在于已注册的属性源之一（例如，系统属性或环境变量）中，则占位符将解析为相应的值。如果不是，则 <code>default/path</code> 用作默认值。如果未指定默认值并且无法解析属性，则抛出 <code>IllegalArgumentException</code>。</p>
<p>根据 Java 8 的约定， <code>@PropertySource</code> 注释是可重复的。但是，所有此类<code>@PropertySource</code> 批注都需要在同一级别上声明，可以直接在配置类上声明，也可以在同一自定义批注中声明为元批注。不建议将直接注释和元注释混合使用，因为直接注释会覆盖元注释。</p>
<h3 id="声明中的占位符解析"><a href="#声明中的占位符解析" class="headerlink" title="声明中的占位符解析"></a>声明中的占位符解析</h3><p>从历史上看，元素中占位符的值只能根据 JVM 系统属性或环境变量来解析。这已不再是这种情况。由于 <code>Environment</code> 抽象是在整个容器中集成的，因此很容易通过它路由占位符的解析。这意味着您可以按照自己喜欢的任何方式配置解析过程。您可以更改搜索系统属性和环境变量的优先级，也可以完全删除它们。您还可以根据需要将自己的属性源添加到混合中。</p>
<p>具体而言，无论该 customer 属性在何处定义，只要该属性在 <code>Environment</code> 可用，以下语句均有效：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"com/bank/service/$&#123;customer&#125;-config.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注册一个-LoadTimeWeaver"><a href="#注册一个-LoadTimeWeaver" class="headerlink" title="注册一个 LoadTimeWeaver"></a>注册一个 <code>LoadTimeWeaver</code></h2><p>Spring 使用 <code>LoadTimeWeaver</code> 在将类加载到 Java 虚拟机（JVM）中时对其进行动态转换。</p>
<p>要启用加载时编织（load-time weaving），可以将 <code>@EnableLoadTimeWeaving</code> 添加到您的 <code>@Configuration</code> 类之一，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableLoadTimeWeaving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，对于 XML 配置，可以使用 context:load-time-weaver 元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为 <code>ApplicationContext</code> 配置后，该 <code>ApplicationContext</code> 中的任何 bean 都可以实现 <code>LoadTimeWeaverAware</code>，从而接收对加载时 weaver 实例的引用。 与 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#orm-jpa" target="_blank" rel="noopener">Spring 的 JPA 支持</a>结合使用时，该功能特别有用，因为在 JPA 类转换中可能需要进行加载时编织。 有关更多详细信息，请查阅 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html" target="_blank" rel="noopener"><code>LocalContainerEntityManagerFactoryBean</code></a> javadoc。 有关 AspectJ 加载时编织的更多信息，请参见 Spring 框架中的 AspectJ 加载时编织。</p>
<h2 id="ApplicationContext-的其他功能"><a href="#ApplicationContext-的其他功能" class="headerlink" title="ApplicationContext 的其他功能"></a>ApplicationContext 的其他功能</h2><p>如本章介绍中所讨论的，<code>org.springframework.beans.factory</code> 包提供了用于管理和操纵 bean 的基本功能，包括以编程方式。<code>org.springframework.context</code> 包添加了 <code>ApplicationContext</code> 接口，该接口扩展了 <code>BeanFactory</code> 接口，此外还扩展了其他接口以提供更多面向应用程序框架的样式的附加功能。许多人以完全声明性的方式使用 <code>ApplicationContext</code>，甚至没有以编程方式创建它，而是依靠诸如 <code>ContextLoader</code> 之类的支持类来自动实例化 <code>ApplicationContext</code> 作为 Java EE Web 应用程序正常启动过程的一部分。</p>
<p>为了以更加面向框架的方式增强 <code>BeanFactory</code> 的功能，上下文包还提供以下功能：</p>
<p>通过 <code>MessageSource</code> 界面访问 i18n 样式的消息。</p>
<p>通过 <code>ResourceLoader</code> 接口访问资源，例如 URL 和文件。</p>
<p>通过使用 <code>ApplicationEventPublisher</code> 接口，将事件发布到实现 <code>ApplicationListener</code> 接口的 bean。</p>
<p>加载多个（分层）上下文，使每个上下文都通过 <code>HierarchicalBeanFactory</code> 接口集中在一个特定层上，例如应用程序的 Web 层。</p>
<h3 id="使用-MessageSource-实现国际化"><a href="#使用-MessageSource-实现国际化" class="headerlink" title="使用 MessageSource 实现国际化"></a>使用 MessageSource 实现国际化</h3><p><code>ApplicationContext</code> 接口扩展了一个称为 <code>MessageSource</code> 的接口，因此提供了国际化（“i18n”）功能。Spring 还提供了 <code>HierarchicalMessageSource</code> 接口，该接口可以分层解析消息。这些接口一起提供了 Spring 影响消息解析的基础。 这些接口上定义的方法包括：</p>
<ul>
<li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从 <code>MessageSource</code> 检索消息的基本方法。如果找不到针对指定语言环境的消息，则使用默认消息。使用标准库提供的 MessageFormat 功能，传入的所有参数都将成为替换值。</li>
<li><code>String getMessage(String code, Object[] args, Locale loc)</code>：与先前的方法基本相同，但有一个区别：无法指定默认消息。如果找不到该消息，则抛出 <code>NoSuchMessageException。</code></li>
<li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面方法中使用的所有属性也都包装在一个名为 <code>MessageSourceResolvable</code> 的类中，您可以在此方法中使用该类。</li>
</ul>
<p>加载 <code>ApplicationContext</code> 时，它将自动搜索在上下文中定义的 <code>MessageSource</code> bean。Bean 的 name 必须是 <code>messageSource</code>。如果找到了这样的 bean，则对先前方法的所有调用都将委派给消息源。 如果找不到消息源，则 <code>ApplicationContext</code> 尝试查找包含同名 bean 的父级。如果找到了，它将使用该 bean 作为 <code>MessageSource</code>。如果 <code>ApplicationContext</code> 找不到任何消息源，则将实例化一个空的 <code>DelegatingMessageSource</code>，以便能够接受对上述方法的调用。</p>
<p>Spring 提供了两个 <code>MessageSource</code> 实现，即 <code>ResourceBundleMessageSource</code> 和 <code>StaticMessageSource</code>。两者都实现 <code>HierarchicalMessageSource</code> 以便进行嵌套消息传递。 <code>StaticMessageSource</code> 很少使用，但是提供了将消息添加到源中的编程方式。下面的示例显示 <code>ResourceBundleMessageSource</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basenames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>format<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>exceptions<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>windows<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该示例假设您在类路径中定义了三个资源包，分别称为 format，exceptions 和 windows。解析消息的任何请求都通过 JDK 标准的通过 <code>ResourceBundle</code> 对象解析消息的方式来处理。就本示例而言，假定上述两个资源束文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in format.properties</span><br><span class="line">message=Alligators rock!</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in exceptions.properties</span><br><span class="line">argument.required=The &#123;0&#125; argument is required.</span><br></pre></td></tr></table></figure>

<p>下一个示例显示了执行 <code>MessageSource</code> 功能的程序。请记住，所有 <code>ApplicationContext</code> 实现也是 <code>MessageSource</code> 实现，因此可以转换为 <code>MessageSource</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    String message = resources.getMessage(<span class="string">"message"</span>, <span class="keyword">null</span>, <span class="string">"Default"</span>, Locale.ENGLISH);</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alligators rock!</span><br></pre></td></tr></table></figure>

<p>总而言之，<code>MessageSource</code> 是在名为 <code>beans.xml</code> 的文件中定义的，该文件位于类路径的根目录下。 <code>messageSource</code> bean 定义通过其 <code>basenames</code> 属性引用了许多资源包。列表中传递给 <code>basenames</code> 属性的三个文件在类路径的根目录下以文件形式存在，分别称为 <code>format.properties</code>，<code>exceptions.properties</code> 和 <code>windows.properties</code>。</p>
<p>下一个示例显示了传递给消息查找的参数。这些参数将转换为 <code>String</code> 对象，并插入到查找消息中的占位符中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this MessageSource is being used in a web application --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"exceptions"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- lets inject the above MessageSource into this POJO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"example"</span> <span class="attr">class</span>=<span class="string">"com.something.Example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messages"</span> <span class="attr">ref</span>=<span class="string">"messageSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageSource messages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessages</span><span class="params">(MessageSource messages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="keyword">this</span>.messages.getMessage(<span class="string">"argument.required"</span>,</span><br><span class="line">            <span class="keyword">new</span> Object [] &#123;<span class="string">"userDao"</span>&#125;, <span class="string">"Required"</span>, Locale.ENGLISH);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>execute()</code> 方法调用的结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The userDao argument is required.</span><br></pre></td></tr></table></figure>

<p>关于国际化(“i18n”)，Spring 的各种 <code>MessageSource</code> 实现遵循与标准 JDK <code>ResourceBundle</code> 相同的语言环境解析和后备规则。简而言之，继续前面定义的示例 <code>messageSource</code>，如果要针对英国（en-GB）语言环境解析消息，则可以分别创建名为 <code>format_en_GB.properties</code>，<code>exceptions_en_GB.properties</code> 和 <code>windows_en_GB.properties</code> 的文件。</p>
<p>通常，语言环境解析由应用程序的周围环境管理。在以下示例中，手动指定了针对其解析（英国）消息的语言环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in exceptions_en_GB.properties</span><br><span class="line">argument.required=Ebagum lad, the &apos;&apos;&#123;0&#125;&apos;&apos; argument is required, I say, required.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">    MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    String message = resources.getMessage(<span class="string">"argument.required"</span>,</span><br><span class="line">        <span class="keyword">new</span> Object [] &#123;<span class="string">"userDao"</span>&#125;, <span class="string">"Required"</span>, Locale.UK);</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述程序的结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ebagum lad, the &apos;userDao&apos; argument is required, I say, required.</span><br></pre></td></tr></table></figure>

<p>您还可以使用 <code>MessageSourceAware</code> 接口获取对已定义的任何 <code>MessageSource</code> 的引用。 创建和配置 bean 时，在 <code>ApplicationContext</code> 中实现 <code>MessageSourceAware</code> 接口的所有 bean 都会与应用程序上下文的 <code>MessageSource</code> 一起注入。</p>
<blockquote>
<p>作为 <code>ResourceBundleMessageSource</code> 的替代，Spring 提供了 <code>ReloadableResourceBundleMessageSource</code> 类。 此变体支持相同的包文件格式，但比基于标准 JDK 的 <code>ResourceBundleMessageSource</code> 实现更灵活。特别是，它允许从任何 Spring 资源位置（不仅从类路径）读取文件，并且支持捆绑属性文件的热重载（同时在它们之间有效地进行缓存）。有关详细信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html" target="_blank" rel="noopener"><code>ReloadableResourceBundleMessageSource</code> javadoc</a>。</p>
</blockquote>
<h3 id="标准和自定义事件"><a href="#标准和自定义事件" class="headerlink" title="标准和自定义事件"></a>标准和自定义事件</h3><p>通过 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口提供 <code>ApplicationContext</code> 中的事件处理。 如果将实现 <code>ApplicationListener</code> 接口的 bean 部署到上下文中，则每次将 <code>ApplicationEvent</code> 发布到 <code>ApplicationContext</code> 时，都会通知该 bean。 本质上，这是标准的 Observer 设计模式。</p>
<blockquote>
<p>从 Spring 4.2 开始，事件基础结构得到了显着改进，并提供了基于注释的模型以及发布任意事件（即不一定从 ApplicationEvent 扩展的对象）的功能。发布此类对象后，我们会为您包装一个事件。</p>
</blockquote>
<p>下表描述了 Spring 提供的标准事件：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ContextRefreshedEvent</code></td>
<td>在初始化或刷新 <code>ApplicationContext</code> 时发布（例如，通过使用 <code>ConfigurableApplicationContext</code> 接口上的 <code>refresh()</code> 方法）。 在这里，“已初始化”是指所有 Bean 均已加载，检测到并激活了后处理器 Bean，已预先实例化单例并且可以使用 <code>ApplicationContext</code> 对象。 只要尚未关闭上下文，只要选定的 <code>ApplicationContext</code> 实际上支持这种“热”刷新，就可以多次触发刷新。例如，<code>XmlWebApplicationContext</code> 支持热刷新，但 <code>GenericApplicationContext</code> 不支持。</td>
</tr>
<tr>
<td><code>ContextStartedEvent</code></td>
<td>在 <code>ConfigurableApplicationContext</code> 接口上使用 <code>start()</code> 方法启动 <code>ApplicationContext</code> 时发布。在这里，“已启动”表示所有 Lifecycle bean 都收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动 Bean，但也可以用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。</td>
</tr>
<tr>
<td><code>ContextStoppedEvent</code></td>
<td>通过使用 <code>ConfigurableApplicationContext</code> 接口上的 <code>stop()</code> 方法停止 <code>ApplicationContext</code> 时发布。 在这里，“已停止”表示所有 <code>Lifecycle</code> bean 都收到一个明确的停止信号。 停止的上下文可以通过 <code>start()</code> 调用重新启动。</td>
</tr>
<tr>
<td><code>ContextClosedEvent</code></td>
<td>通过使用 <code>ConfigurableApplicationContext</code> 接口上的 <code>close()</code> 方法或通过 JVM 关闭钩子关闭 <code>ApplicationContext</code> 时发布。 在这里，“已关闭”意味着所有单例 bean 将被销毁。 关闭上下文后，它将达到使用寿命，无法刷新或重新启动。</td>
</tr>
<tr>
<td><code>RequestHandledEvent</code></td>
<td>一个特定于 Web 的事件，告诉所有 Bean HTTP 请求已得到服务。请求完成后，将发布此事件。此事件仅适用于使用 Spring 的 <code>DispatcherServlet</code> 的 Web 应用程序。</td>
</tr>
<tr>
<td><code>ServletRequestHandledEvent</code></td>
<td><code>RequestHandledEvent</code> 的子类，用于添加特定于 Servlet 的上下文信息。</td>
</tr>
</tbody></table>
<p>您还可以创建和发布自己的自定义事件。以下示例显示了一个简单的类，该类扩展了 Spring 的 <code>ApplicationEvent</code> 基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlackListEvent</span><span class="params">(Object source, String address, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accessor and other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要发布自定义的 <code>ApplicationEvent</code>，请在 <code>publishEvent()</code> 上调用方法 <code>ApplicationEventPublisher</code>。通常，这是通过创建一个实现 <code>ApplicationEventPublisherAware</code> 并注册为 Spring bean 的类来完成的。以下示例显示了此类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlackList</span><span class="params">(List&lt;String&gt; blackList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blackList = blackList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = publisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blackList.contains(address)) &#123;</span><br><span class="line">            publisher.publishEvent(<span class="keyword">new</span> BlackListEvent(<span class="keyword">this</span>, address, content));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// send email...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置时，Spring 容器检测到 <code>EmailService</code> 实现了 <code>ApplicationEventPublisherAware</code> 并自动调用 <code>setApplicationEventPublisher()</code>。实际上，传入的参数是 Spring 容器本身。您正在通过其 <code>ApplicationEventPublisher</code> 接口与应用程序上下文进行交互。</p>
<p>要接收自定义 <code>ApplicationEvent</code>，可以创建一个实现 <code>ApplicationListener</code> 的类并将其注册为 Spring Bean。 以下示例显示了此类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListNotifier</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">BlackListEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotificationAddress</span><span class="params">(String notificationAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notificationAddress = notificationAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>ApplicationListener</code> 通常使用您的自定义事件的类型（上一示例中的 <code>BlackListEvent</code>）进行参数化。这意味着 <code>onApplicationEvent()</code> 方法可以保持类型安全，从而避免了任何向下转换的需求。您可以根据需要注册任意数量的事件侦听器，但是请注意，默认情况下，事件侦听器会同步接收事件。这意味着 <code>publishEvent()</code> 方法将阻塞，直到所有侦听器都已完成对事件的处理为止。这种同步和单线程方法的一个优点是，当侦听器接收到事件时，如果有可用的事务上下文，它将在发布者的事务上下文内部进行操作。如果有必要采用其他发布事件的策略，请参阅 Spring 的 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html" target="_blank" rel="noopener"><code>ApplicationEventMulticaster</code> 接口的 javadoc</a> 和配置选项的 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html" target="_blank" rel="noopener"><code>SimpleApplicationEventMulticaster</code> 实现</a>。</p>
<p>以下示例显示了用于注册和配置上述每个类的 Bean 定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emailService"</span> <span class="attr">class</span>=<span class="string">"example.EmailService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blackList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.spammer@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.hacker@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>john.doe@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blackListNotifier"</span> <span class="attr">class</span>=<span class="string">"example.BlackListNotifier"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"notificationAddress"</span> <span class="attr">value</span>=<span class="string">"blacklist@example.org"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总而言之，当调用 <code>emailService</code> bean 的 <code>sendEmail()</code> 方法时，如果有任何电子邮件应列入黑名单，则将发布 <code>BlackListEvent</code> 类型的自定义事件。 <code>blackListNotifier</code> bean 被注册为 <code>ApplicationListener</code> 并接收 <code>BlackListEvent</code>，这时它可以通知适当的参与者。</p>
<blockquote>
<p>Spring 的事件机制旨在在同一应用程序上下文内在 Spring bean 之间进行简单的通信。 但是，对于更复杂的企业集成需求，单独维护的 Spring Integration 项目为基于著名的 Spring 编程模型构建轻量级，面向模式，事件驱动的架构提供了完整的支持。</p>
</blockquote>
<h4 id="基于注释的事件侦听器"><a href="#基于注释的事件侦听器" class="headerlink" title="基于注释的事件侦听器"></a>基于注释的事件侦听器</h4><p>从 Spring 4.2 开始，您可以使用 <code>@EventListener</code> 注释在托管 Bean 的任何公共方法上注册事件侦听器。<code>BlackListNotifier</code> 可改写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListNotifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotificationAddress</span><span class="params">(String notificationAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notificationAddress = notificationAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法签名再次声明其侦听的事件类型，但是这次使用灵活的名称，并且没有实现特定的侦听器接口。只要实际事件类型在其实现层次结构中解析您的通用参数，也可以通过通用类型来缩小事件类型。</p>
<p>如果您的方法应该侦听多个事件，或者您要完全不使用任何参数来定义它，则事件类型也可以在注释本身上指定。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleContextStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过使用定义 SpEL 表达式的注释的 <code>condition</code> 属性来添加其他运行时过滤，该注释应匹配以针对特定事件实际调用该方法。</p>
<p>以下示例显示了仅当事件的 <code>content</code> 属性等于 <code>my-event</code> 时，才可以重写我们的通知程序以进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(condition = <span class="string">"#blEvent.content == 'my-event'"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent blEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 SpEL 表达式都会根据专用上下文进行求值。 下表列出了可用于上下文的项目，以便您可以将它们用于条件事件处理：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位置</th>
<th>描述</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>事件</td>
<td>根对象</td>
<td>实际的 <code>ApplicationEvent</code>。</td>
<td><code>#root.event</code> 或 <code>event</code></td>
</tr>
<tr>
<td>参数数组</td>
<td>根对象</td>
<td>用于调用方法的参数（作为对象数组）。</td>
<td><code>#root.args</code> 或 <code>args</code>; <code>args[0]</code>访问第一个参数，等等。</td>
</tr>
<tr>
<td><em>参数名称</em></td>
<td>求值上下文</td>
<td>任何方法参数的名称。如果由于某种原因这些名称不可用（例如，由于在编译的字节码中没有调试信息），则也可以使用<code>#a&lt;#arg&gt;</code>语法（其中<code>&lt;#arg&gt;</code>代表参数索引（从 0 开始）。</td>
<td><code>#blEvent</code> 或 <code>#a0</code>（您也可以使用 <code>#p0</code> 或 <code>#p&lt;#arg&gt;</code> 参数符号作为别名</td>
</tr>
</tbody></table>
<p>请注意，即使您的方法签名实际上引用了已发布的任意对象，<code>root.event</code> 也使您可以访问基础事件。</p>
<p>如果由于处理一个事件而需要发布另一个事件，则可以更改方法签名以返回应发布的事件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListUpdateEvent <span class="title">handleBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress and</span></span><br><span class="line">    <span class="comment">// then publish a ListUpdateEvent...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异步侦听器不支持此功能。</p>
</blockquote>
<p>此新方法为上述方法处理的每个 <code>BlackListEvent</code> 发布一个新的 <code>ListUpdateEvent</code>。如果您需要发布多个事件，则可以返回事件的 <code>Collection</code>。</p>
<h4 id="异步侦听器"><a href="#异步侦听器" class="headerlink" title="异步侦听器"></a>异步侦听器</h4><p>如果希望特定的侦听器异步处理事件，则可以重用常规的 <code>@Async</code> 支持。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BlackListEvent is processed in a separate thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用异步事件时，请注意以下限制：</p>
<p>如果异步事件侦听器引发 <code>Exception</code>，则不会将其传播到调用方。有关更多详细信息，请参见 <code>AsyncUncaughtExceptionHandler</code>。</p>
<p>异步事件侦听器方法无法通过返回值来发布后续事件。如果您需要发布另一个事件作为处理的结果，请注入 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html" target="_blank" rel="noopener"><code>ApplicationEventPublisher</code></a> 以手动发布事件。</p>
<h4 id="侦听器排序"><a href="#侦听器排序" class="headerlink" title="侦听器排序"></a>侦听器排序</h4><p>如果需要先调用一个侦听器，则可以将 <code>@Order</code> 注释添加到方法声明中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">42</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一般事件"><a href="#一般事件" class="headerlink" title="一般事件"></a>一般事件</h4><p>您还可以使用泛型来进一步定义事件的结构。考虑使用 <code>EntityCreatedEvent&lt;T&gt;</code>，其中 T 是已创建的实际实体的类型。例如，您可以创建以下侦听器定义以仅接收 <code>Person</code> 的 <code>EntityCreatedEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPersonCreated</span><span class="params">(EntityCreatedEvent&lt;Person&gt; event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于类型擦除，只有在触发的事件解析了事件侦听器所依据的通用参数（即 <code>class PersonCreatedEvent extends EntityCreatedEvent&lt;Person&gt; {…}</code>）时，此方法才起作用。</p>
<p>在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很乏味（就像前面示例中的事件一样）。 在这种情况下，您可以实现 <code>ResolvableTypeProvider</code> 来指导框架超出运行时环境提供的范围。以下事件显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityCreatedEvent</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> <span class="keyword">implements</span> <span class="title">ResolvableTypeProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EntityCreatedEvent</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResolvableType <span class="title">getResolvableType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这不仅适用于 <code>ApplicationEvent</code>，而且适用于您作为事件发送的任何任意对象。</p>
</blockquote>
<h3 id="方便地访问低级资源"><a href="#方便地访问低级资源" class="headerlink" title="方便地访问低级资源"></a>方便地访问低级资源</h3><p>为了获得最佳用法和对应用程序上下文的理解，您应该熟悉 Spring 的 <code>Resource</code> 抽象，如参考资料所述。</p>
<p>应用程序上下文是 <code>ResourceLoader</code>，可用于加载 <code>Resource</code> 对象。<code>Resource</code> 本质上是 JDK <code>java.net.URL</code> 类的功能更丰富的版本。实际上，资源的实现在适当的地方包装了 <code>java.net.URL</code> 的实例。资源可以以透明的方式从几乎任何位置获取低级资源，包括从类路径、文件系统位置、可使用标准 URL 描述的任何位置以及一些其他变体。如果资源位置字符串是没有任何特殊前缀的简单路径，则这些资源的来源是特定的，并且适合于实际的应用程序上下文类型。</p>
<p>您可以配置部署到应用程序上下文中的 bean，以实现特殊的回调接口 <code>ResourceLoaderAware</code>，以便在初始化时自动调用，并将应用程序上下文本身作为 <code>ResourceLoader</code> 传入。您还可以公开 <code>Resource</code> 类型的属性，以用于访问静态资源。它们像其他任何属性一样注入其中。您可以将那些 <code>Resource</code> 属性指定为简单的 String 路径，并在部署 bean 时依靠从这些文本字符串到实际 <code>Resource</code> 对象的自动转换。</p>
<p>提供给 <code>ApplicationContext</code> 构造函数的一个或多个位置路径实际上是资源字符串，并且根据特定的上下文实现以简单的形式对其进行适当处理。例如，<code>ClassPathXmlApplicationContext</code> 将简单的位置路径视为类路径位置。您也可以使用带有特殊前缀的位置路径（资源字符串）来强制从类路径或 URL 中加载定义，而不管实际的上下文类型如何。</p>
<h3 id="Web-应用程序的便捷-ApplicationContext-实例化"><a href="#Web-应用程序的便捷-ApplicationContext-实例化" class="headerlink" title="Web 应用程序的便捷 ApplicationContext 实例化"></a>Web 应用程序的便捷 ApplicationContext 实例化</h3><p>您可以使用例如 <code>ContextLoader</code> 声明性地创建 <code>ApplicationContext</code> 实例。 当然，您还可以使用 <code>ApplicationContext</code> 实现之一以编程方式创建 <code>ApplicationContext</code> 实例。</p>
<p>您可以使用 <code>ApplicationContext</code> 来注册一个 <code>ContextLoaderListener</code>，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>侦听器检查 <code>contextConfigLocation</code> 参数。 如果参数不存在，那么侦听器将使用 <code>/WEB-INF/applicationContext.xml</code> 作为默认值。 当参数确实存在时，侦听器将使用预定义的定界符（逗号，分号和空格）来分隔 String，并将这些值用作搜索应用程序上下文的位置。此外还支持蚂 Ant 风格的路径模式。示例包括 <code>/WEB-INF/*Context.xml</code>（适用于所有名称以 <code>Context.xml</code> 结尾且位于 <code>WEB-INF</code> 目录中的文件）和 <code>/WEB-INF/**/*Context.xml</code>（适用于所有此类在 <code>WEB-INF</code> 的任何子目录中的文件）。</p>
<h3 id="将-Spring-ApplicationContext-部署为-Java-EE-RAR-文件"><a href="#将-Spring-ApplicationContext-部署为-Java-EE-RAR-文件" class="headerlink" title="将 Spring ApplicationContext 部署为 Java EE RAR 文件"></a>将 Spring <code>ApplicationContext</code> 部署为 Java EE RAR 文件</h3><p>可以将 Spring <code>ApplicationContext</code> 部署为 RAR 文件，并将上下文及其所有必需的 bean 类和库 JAR 封装在 Java EE RAR 部署单元中。这等效于引导独立的 <code>ApplicationContext</code>（仅托管在 Java EE 环境中）能够访问 Java EE 服务器功能。 RAR 部署是部署无头 WAR 文件的方案的一种更自然的选择——实际上，这种 WAR 文件没有任何 HTTP 入口点，仅用于在 Java EE 环境中引导 Spring <code>ApplicationContext</code>。</p>
<p>对于不需要 HTTP 入口点而仅由消息端点和计划的作业组成的应用程序上下文，RAR 部署是理想的选择。在这样的上下文中，Bean 可以使用应用程序服务器资源，例如 JTA 事务管理器和 JNDI 绑定的 JDBC <code>DataSource</code> 实例以及 JMS <code>ConnectionFactory</code> 实例，并且还可以在平台的 JMX 服务器上注册-通过 Spring 的标准事务管理以及 JNDI 和 JMX 支持工具。应用程序组件还可以通过 Spring 的 <code>TaskExecutor</code> 抽象与应用程序服务器的 JCA <code>WorkManager</code> 进行交互。</p>
<p>有关 RAR 部署中涉及的配置详细信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html" target="_blank" rel="noopener"><code>SpringContextResourceAdapter</code> 类的 javadoc</a>。</p>
<p>对于将 Spring ApplicationContext 作为 Java EE RAR 文件的简单部署：</p>
<ol>
<li><p>将所有应用程序类打包到 RAR 文件（这是具有不同文件扩展名的标准 JAR 文件）中。将所有必需的库 JAR 添加到 RAR 归档文件的根目录中。添加一个 <code>META-INF/ra.xml</code> 部署描述符（如 javadoc 中的 <code>SpringContextResourceAdapter</code> 所示）和相应的 Spring XML bean 定义文件（通常为 <code>META-INF/applicationContext.xml</code>）。</p>
</li>
<li><p>将生成的 RAR 文件拖放到应用程序服务器的部署目录中。</p>
</li>
</ol>
<blockquote>
<p>此类 RAR 部署单元通常是独立的。它们不会将组件暴露给外界，甚至不会暴露给同一应用程序的其他模块。与基于 RAR 的 <code>ApplicationContext</code> 的交互通常是通过与其他模块共享的 JMS 目标进行的。例如，基于 RAR 的 <code>ApplicationContext</code> 还可以安排一些作业或对文件系统（或类似文件）中的新文件做出反应。如果需要允许来自外部的同步访问，则可以（例如）导出 RMI 端点，该端点可以由同一台计算机上的其他应用程序模块使用。</p>
</blockquote>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p><code>BeanFactory</code> API 为 Spring 的 IoC 功能提供了基础。它的特定合同主要用于与 Spring 的其他部分以及相关的第三方框架集成，并且它的 <code>DefaultListableBeanFactory</code> 实现是更高级别的 <code>GenericApplicationContext</code> 容器中的关键委托。</p>
<p><code>BeanFactory</code> 和相关接口（例如 <code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>）是其他框架组件的重要集成点。通过不需要任何注释，甚至不需要反射，它们可以在容器及其组件之间进行非常有效的交互。应用程序级 Bean 可以使用相同的回调接口，但通常更喜欢通过注释或通过编程配置进行声明式依赖注入。</p>
<p>请注意，核心 <code>BeanFactory</code> API 级别及其 <code>DefaultListableBeanFactory</code> 实现不对配置格式或要使用的任何组件注释进行假设。所有这些风味都是通过扩展（例如 <code>XmlBeanDefinitionReader</code> 和 <code>AutowiredAnnotationBeanPostProcessor</code>）引入的，并以核心元数据表示形式对共享 <code>BeanDefinition</code> 对象进行操作。这就是使 Spring 的容器如此灵活和可扩展的本质。</p>
<h3 id="BeanFactory-还是-ApplicationContext？"><a href="#BeanFactory-还是-ApplicationContext？" class="headerlink" title="BeanFactory 还是 ApplicationContext？"></a><code>BeanFactory</code> 还是 <code>ApplicationContext</code>？</h3><p>本节说明 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 容器级别之间的区别以及对引导的影响。</p>
<p>除非有充分的理由，否则应使用 <code>ApplicationContext</code>，除非将 <code>GenericApplicationContext</code> 及其子类 <code>AnnotationConfigApplicationContext</code> 作为自定义引导的常见实现，否则应使用 <code>ApplicationContext</code>。这些是用于所有常见目的的 Spring 核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册 Bean 定义和带注释的类，以及（从 5.0 版本开始）注册功能性 Bean 定义。</p>
<p>因为 <code>ApplicationContext</code> 包含 <code>BeanFactory</code> 的所有功能，所以通常建议在普通 <code>BeanFactory</code> 上使用，除非需要完全控制 Bean 处理的方案。在 <code>ApplicationContext</code>（例如 <code>GenericApplicationContext</code> 实现）中，按照约定（即，按 Bean 名称或 Bean 类型（尤其是后处理器））检测到几种 Bean，而普通的 <code>DefaultListableBeanFactory</code> 不知道任何特殊的 Bean。</p>
<p>对于许多扩展的容器功能，例如注释处理和 AOP 代理，<code>BeanPostProcessor</code> 扩展点是必不可少的。如果仅使用普通的 <code>DefaultListableBeanFactory</code>，则默认情况下不会检测到此类后处理器并将其激活。这种情况可能会造成混淆，因为您的 bean 配置实际上并没有错。而是在这种情况下，需要通过其他设置完全引导容器。</p>
<p>下表列出了 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 接口和实现所提供的功能。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>Bean 实例化/接线</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>集成生命周期管理</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>自动 BeanPostProcessor 注册</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>自动 BeanFactoryPostProcessor 注册</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>方便的 MessageSource 访问（用于国际化）</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>内置 ApplicationEvent 发布机制</td>
<td>没有</td>
<td>是</td>
</tr>
</tbody></table>
<p>要向 <code>DefaultListableBeanFactory</code> 显式注册 Bean 后处理器，需要以编程方式调用 <code>addBeanPostProcessor</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">// populate the factory with bean definitions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now register any needed BeanPostProcessor instances</span></span><br><span class="line">factory.addBeanPostProcessor(<span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor());</span><br><span class="line">factory.addBeanPostProcessor(<span class="keyword">new</span> MyBeanPostProcessor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// now start using the factory</span></span><br></pre></td></tr></table></figure>

<p>要将 <code>BeanFactoryPostProcessor</code> 应用于普通的 <code>DefaultListableBeanFactory</code>，您需要调用其 <code>postProcessBeanFactory</code> 方法，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(<span class="keyword">new</span> FileSystemResource(<span class="string">"beans.xml"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// bring in some property values from a Properties file</span></span><br><span class="line">PropertySourcesPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">cfg.setLocation(<span class="keyword">new</span> FileSystemResource(<span class="string">"jdbc.properties"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// now actually do the replacement</span></span><br><span class="line">cfg.postProcessBeanFactory(factory);</span><br></pre></td></tr></table></figure>

<p>在这两种情况下，显式的注册步骤都是不方便的，这就是为什么在 Spring 支持的应用程序中，各种 <code>ApplicationContext</code> 变量比普通的 <code>DefaultListableBeanFactory</code> 更为可取的原因，尤其是在典型企业设置中依赖 <code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 实例来扩展容器功能时。</p>
<blockquote>
<p><code>AnnotationConfigApplicationContext</code> 已注册了所有常见的注释后处理器，并且可以通过配置注释（例如 <code>@EnableTransactionManagement</code>）在幕后引入其他处理器。 在 Spring 基于注释的配置模型的抽象级别上，bean 后处理器的概念仅是内部容器详细信息。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring进阶 - IoC容器(1)]]></title>
      <url>https://HaleLu.github.io/2020/02/spring-1/</url>
      <content type="html"><![CDATA[<p>本系列基于 Spring Framework 文档深入探究 Spring 的使用姿势及原理。</p>
<p>一些简单概念略过不讲，希望阅读这篇文章的你对 Spring 有一定了解。</p>
<p>本文讲第一部分——IoC 容器、bean 概述、依赖注入和 bean 的作用域。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Framework 的 IoC 容器主要在 org.springframework.beans 和 org.springframework.context 这两个包里，BeanFactory 接口提供了更高级的注册机制能够管理任意类型的对象。 ApplicationContext 接口继承了 BeanFactory 接口，并添加了更易与 Spring AOP 集成的特性、消息资源管理（用于国际化）、事件发布、应用层特定上下文（例如用于 web 应用的 WebApplicationContext）。简而言之，BeanFactory 提供了注册框架和基础功能，ApplicationContext 增加了更多企业级应用的特定功能。本章重点讲 ApplicationContext，关于 BeanFactory 详见下文。</p>
<h2 id="容器概论"><a href="#容器概论" class="headerlink" title="容器概论"></a>容器概论</h2><p>ApplicationContext 接口表示 Spring 的 IoC 容器，它负责实例化(instantiate)、配置和组装 beans。ApplicationContext 通过从 XML、注解或是代码得知哪些类需要被加载、以何种方式加载、依赖关系是什么。</p>
<p>Spring 提供了一些 ApplicationContext 的实现，常见的例如 ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext，都是通过 XML 配置来实现的。大多数场景下，用户代码并不需要自己实例化出一个 Spring IoC 容器，可以通过一个简单的 web.xml 便可实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下图简要展示了 Spring IoC 容器的工作原理，你的 POJOs 结合配置项元数据，这样，ApplicationContext 创建并初始化后，你就拥有了一个配置完全且可运行的系统/应用。</p>
<p><img src="./container-magic.png" alt="Spring IoC"></p>
<h3 id="配置项元数据-Configuration-Metadata"><a href="#配置项元数据-Configuration-Metadata" class="headerlink" title="配置项元数据(Configuration Metadata)"></a>配置项元数据(Configuration Metadata)</h3><p>上文说了，Spring IoC 容器使用配置项元数据的形式配置，支持传统的 XML 格式，从 Spring 2.5 开始支持基于注解的配置项元数据，从 3.0 开始，Spring JavaConfig 提供的很多特性使你可以通过一些类来定义 beans，包括 @Configuration、 @Bean、@Import 以及 @DependsOn 等注解。</p>
<p>Spring 配置项包含一个或多个容器管理的 bean 定义(definition)。在 XML 中使用<code>&lt;beans/&gt;</code>中的<code>&lt;bean/&gt;</code>标签，代码方式则在<code>@Configuration</code>注解的类中使用<code>@Bean</code>注解的方法。通常我们用其定义服务层对象、DAOs、展示对象、基础设置对象（例如一些框架工厂类）等等。通常在容器中不注册细粒度的域对象，因为这通常是 DAOs 的责任，应当又业务逻辑创建和加载这些对象。不过，你可以使用 Spring 的 AspectJ 集成来注册在 IoC 容器控制之外创建的对象。详见下文。</p>
<p>以下是一个典型的 XML 配置项元数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>See Dependencies for more information.</p>
<h3 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a>实例化容器</h3><p>我们可以从各种外部资源（本地文件系统、Java <code>CLASSPATH</code>等）指定 ApplicationContext 构造时使用的资源文件。官方文档此处给了一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>services.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"itemDao"</span> <span class="attr">ref</span>=<span class="string">"itemDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>daos.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从其他 XML 文件导入 beans</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"services.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"resources/messageSource.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"/resources/themeSource.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>namespace 也提供了 import、context 和 util 等功能，此处不再详细解释说明。</p>
<p><em>注：虽然可以使用<code>../</code>这样的相对路径，但是不推荐，这可能会导致引用了应用之外的文件，例如<code>classpath:../services.xml</code></em></p>
<h3 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h3><p>ApplicationContext 是一个高级工厂，其维护了不同 beans 的注册项和他们的依赖。通过使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>你可以获取到这些 bean 的实例。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">PetStoreService service = context.getBean(<span class="string">"petStore"</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>

<p>有一种最灵活的方式是<code>GenericApplicationContext</code>结合 reader 委托，以 XmlBeanDefinitionReader 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p>你可以混合使用不同的 reader 委托到同一个<code>ApplicationContext</code>上，以便从不同的源注册 bean。</p>
<p>尽管提供了 getBean 方法来获取 bean，ApplicationContext 也提供了一些其他方法来获取，但是事实上应用程序代码不应当通过这些 Spring API 来获取 bean。</p>
<h2 id="Bean-概论"><a href="#Bean-概论" class="headerlink" title="Bean 概论"></a>Bean 概论</h2><p>一个 IoC 容器管理一个或多个 bean，这些 bean 根据你提供给容器的配置项元数据来构建。</p>
<p>在容器内部，这些 bean 定义以<code>BeanDefinition</code>对象的形式存在，它通常包含以下元数据：</p>
<ul>
<li>指定包的类名：通常是 bean 的实现类</li>
<li>Bean 的配置方式：定义 bean 在容器中的行为，包括作用域(scope)、生命周期回调(lifecycle callbacks)等</li>
<li>对其他 bean 的引用：这些引用也被称为 bean 的合作/依赖项</li>
<li>在新创建对象中的其他配置设置：比如对于管理连接池的 bean 而言可以包括连接池的大小、最大连接数等</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td>[实例化](&lt;#bean\ 的实例化&gt;)</td>
</tr>
<tr>
<td>Name</td>
<td>[命名](&lt;#bean\ 的命名&gt;)</td>
</tr>
<tr>
<td>Scope</td>
<td>作用域</td>
</tr>
<tr>
<td>Constructor arguments</td>
<td><a href="#依赖">依赖注入</a></td>
</tr>
<tr>
<td>Properties</td>
<td><a href="#依赖">依赖注入</a></td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>自动注入合作项</td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td>懒加载</td>
</tr>
<tr>
<td>Initialization method</td>
<td>初始化回调</td>
</tr>
<tr>
<td>Destruction method</td>
<td>销毁回调</td>
</tr>
</tbody></table>
<p>除了 bean 定义说明了怎样创建一个指定的 bean，ApplicationContext 也允许注册用户在容器外创建好的对象。通过 ApplicationContext 下 BeanFactory 的<code>getBeanFactory()</code>方法可以拿到 BeanFactory 的默认 DefaultListableBeanFactory 实现。DefaultListableBeanFactory 支持通过<code>registerSingleton(...)</code>和<code>registerBeanDefinition(..)</code>方法注册 bean。当然，通常我们只使用常规 bean 定义元数据。</p>
<p><em>注：我们应当尽早注册 bean 元数据和人工指定的单例，这样才能保证容器实例化时正确注入他们。尽管某种程度上支持重写已经存在的元数据和单例，但是运行时注册新的 bean（同时有并行访问工厂）官方并不支持，这可能导致并行获取异常以及容器的状态异常等。</em></p>
<h3 id="bean-的命名"><a href="#bean-的命名" class="headerlink" title="bean 的命名"></a>bean 的命名</h3><p>每个 bean 都有一个或多个标识符，标识符在容器内必须唯一。通常 bean 只有一个标识符，但有时有些 bean 也需要别名(aliase)。</p>
<blockquote>
<h3 id="bean-命名公约"><a href="#bean-命名公约" class="headerlink" title="bean 命名公约"></a>bean 命名公约</h3><p>公约使用标准 Java 公约的实例字段命名规则。bean 名称以小写字母开头，驼峰命名，例如<code>accountManager</code>、<code>accountService</code>、<code>userDao</code>、<code>loginController</code>等。</p>
<p>一致的命名风格可以使你的配置项更容易阅读和理解，并且如果你使用 AOP 的话，在为一系列以命名关联的 bean 配置 advice 时会很有帮助。</p>
</blockquote>
<p>你可以使用 name 指定名称，alias 指定别名，此处过于简单不展开细讲。</p>
<h3 id="bean-的实例化"><a href="#bean-的实例化" class="headerlink" title="bean 的实例化"></a>bean 的实例化</h3><p>bean 定义本质上是如何创建一个或多个对象的方法的定义，当容器需要拿一个 bean 时它会寻找这个定义并使用定义里保存的配置项元数据创建（或获取）一个实际的对象。通常情况下，bean 需要指定 class（除非工厂方法和 bean 定义继承）。我们通常有两种方式指定 class：</p>
<ul>
<li>通常情况下，容器直接通过反射取到其构造函数，相当于 new 出一个对象放进容器；</li>
<li>少数情况下，容器调用静态工厂方法创建对象，这个静态工厂方法返回的对象可能和 class 相同，也可能完全不同。</li>
</ul>
<blockquote>
<p><em>内部类名</em></p>
<p>如果你想配置一个静态内部类的 bean，你需要使用内部类的二进制名称；</p>
<p>比如在 com.example 包中有一个 SomeThing 类，SomeThing 类下有一个 OtherThing 静态内部类，那么这个 bean 定义的 class 应当是 <code>com.example.SomeThing$OtherThing</code>。使用 <code>$</code> 符号分隔内外的类名。</p>
</blockquote>
<h4 id="使用构造器实例化"><a href="#使用构造器实例化" class="headerlink" title="使用构造器实例化"></a>使用构造器实例化</h4><p>当我们通过构造方法创建 bean 时，所有普通类都可以使用并与 Spring 兼容。也就是说，开发的类不需要实现任何特定接口或以特定方式编码。 只需指定 bean 类就足够了。但是，根据为该特定 bean 使用的 IoC 类型，我们可能需要一个默认无参构造函数。</p>
<p>Spring IoC 容器几乎可以管理你希望它管理的任何类。 它不仅可以管理真正的 JavaBeans。大多数情况下我们更喜欢实际只有一个默认无参构造函数的 JavaBeans，提供一些适当的 setter 和 getter。当然你也可以在容器中指定其他外部的非 bean 风格的类。例如，如果你需要使用完全不符合 JavaBean 规范的旧连接池，Spring 也可以对其进行管理。</p>
<p>至于为构造函数提供参数的机制以及如何在构造对象后设置对象实例属性的，详见下文的依赖注入。</p>
<h4 id="使用静态工厂方法实例化"><a href="#使用静态工厂方法实例化" class="headerlink" title="使用静态工厂方法实例化"></a>使用静态工厂方法实例化</h4><p>定义使用静态工厂方法创建的 bean 时，需要使用 class 属性指定包含静态工厂方法的类并使用 factory-method 指定对应的工厂方法。此工厂方法（可以有参数）会创建一个对象，容器会把它当做构造函数创建的对象。这种 bean 定义的一个用途是在老式代码中调用静态工厂。</p>
<p>举例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"examples.ClientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用实例的工厂方法实例化"><a href="#使用实例的工厂方法实例化" class="headerlink" title="使用实例的工厂方法实例化"></a>使用实例的工厂方法实例化</h4><p>与通过静态工厂方法实例化类似，使用实例工厂方法进行实例化会从容器调用现有 bean 的非静态方法来创建新 bean。 要使用此机制，请将 class 属性保留为空，并在 factory-bean 属性中指定当前（或父级或祖先）容器中 bean 的名称，该容器包含要调用以创建对象的实例方法。 使用 factory-method 属性设置工厂方法本身的名称。 以下示例显示如何配置此类 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，一个工厂类可以有多个工厂方法。</p>
<p><em>注：在 Spring 文档中，“工厂 bean”是指在 Spring 容器中配置并通过实例或静态工厂方法创建对象的 bean。 相比之下，FactoryBean（注意大小写）是指特定于 Spring 的 FactoryBean。</em></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>典型的企业应用程序不会只包含单个对象（或 Spring 说法中的 bean）。即使是最简单的应用程序也有一些对象可以协同工作，以呈现最终用户所看到的连贯应用程序。这节讲如何定义多个独立的 bean 定义，以及对象协作实现目标的完全实现的应用程序。</p>
<h3 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入(DI)"></a>依赖注入(DI)</h3><p>依赖注入主要有两种方式：<a href="#基于构造函数的依赖注入">基于构造函数</a>和[基于 Setter](&lt;#基于\ Setter\ 的依赖注入&gt;)。</p>
<h4 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h4><p>基于构造函数的 DI 由容器调用具有多个参数的构造函数来完成，每个参数表示一个依赖项。这跟调用具有相同参数的静态工厂方法来构造 bean 是等效的，下面的解释同样适用于静态工厂方法。举个简单的 POJO 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数参数解析"><a href="#构造函数参数解析" class="headerlink" title="构造函数参数解析"></a>构造函数参数解析</h5><p>容器会通过参数的类型与 bean 进行匹配，如果 bean 定义的构造函数参数中不存在歧义，那么在 bean 实例化时，这些参数按照定义中构造函数参数的顺序提供给对应的构造函数。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThingOne</span><span class="params">(ThingTwo thingTwo, ThingThree thingThree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如 ThingTwo 和 ThingThree 类没有继承上的关联，也就是不存在歧义，那么以下的配置就可以了，不需要在 <code>&lt;constructor-arg/&gt;</code> 元素中显式指定构造函数参数下标或类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingOne"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"beanTwo"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"beanThree"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanTwo"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingTwo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanThree"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingThree"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当使用简单类型时，例如 <code>&lt;value&gt;true&lt;/value&gt;</code>，Spring 无法确定值的类型，因此无法在没有帮助的情况下按类型进行匹配。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></span><br><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数参数类型匹配"><a href="#构造函数参数类型匹配" class="headerlink" title="构造函数参数类型匹配"></a>构造函数参数类型匹配</h5><p>为解决前面的问题，需要使用 type 属性显式指定构造函数参数的类型，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="构造函数参数下标"><a href="#构造函数参数下标" class="headerlink" title="构造函数参数下标"></a>构造函数参数下标</h5><p>可以使用 index 属性显式指定构造函数参数的下标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了解决多个简单值的歧义之外，指定索引还可以解决构造函数具有相同类型的多参数的歧义。</p>
<p><em>注：下标从 0 开始。</em></p>
<h5 id="构造函数参数名称"><a href="#构造函数参数名称" class="headerlink" title="构造函数参数名称"></a>构造函数参数名称</h5><p>还可以使用构造函数参数名称进行值消歧：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ultimateAnswer"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但这种方式只在 debug 模式下有效（release 模式会改变参数名），或者使用 <code>@ConstructorProperties</code> 注解指定参数名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConstructorProperties</span>(&#123;<span class="string">"years"</span>, <span class="string">"ultimateAnswer"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于-Setter-的依赖注入"><a href="#基于-Setter-的依赖注入" class="headerlink" title="基于 Setter 的依赖注入"></a>基于 Setter 的依赖注入</h4><p>基于 Setter 的依赖注入指在调用无参数构造函数或无参静态工厂方法来实例化 bean 之后，容器调用 setter 方法注入 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationContext</code>不仅支持基于构造函数和基于 Setter 的依赖注入，甚至支持两者同时使用。如果使用了 Setter 注意添加 @Required 注解使得 bean 必须被注入。</p>
<p>Spring 团队通常提倡构造函数注入，因为它允许我们将应用程序组件实现为不可变对象，并确保所需的依赖项不是 null。值得一提的是，如果构造函数有太多的参数参数说明该类可能有太多的责任，最好拆分责任以更好地分离关注点。</p>
<p>Setter 注入应主要仅用于可在类中指定合理默认值的可选依赖项。否则，必须在代码使用依赖项的任何位置执行非空检查。setter 注入的一个好处是 setter 方法使该类的对象可以在以后重新配置或重新注入。JMX 最常用这种模式。</p>
<h4 id="依赖性解决过程"><a href="#依赖性解决过程" class="headerlink" title="依赖性解决过程"></a>依赖性解决过程</h4><p>容器执行 bean 依赖性解析，如下所示：</p>
<ul>
<li><code>ApplicationContext</code> 创建和初始化所有 bean 的配置项元数据。配置项元数据可以由 XML，Java 代码或注解指定。</li>
<li>对于每个 bean，它的依赖关系以属性，构造函数参数或静态工厂方法的参数的形式表示。当创建 bean 时，这些依赖项会被提供给 bean。</li>
<li>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。</li>
<li>作为值的每个属性或构造函数参数都从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 能够转换成字符串格式提供给所有内置类型的值，例如 int， long，String，boolean 等。</li>
</ul>
<p>Spring 容器在创建容器时验证每个 bean 的配置，但是直到实际创建 bean 的时候才会设置这些 bean 属性。创建时容器会创建单例作用域且需要预加载（默认）的 Bean，其他的仅在请求时才创建 bean。创建 bean 时可能会构造一张 bean 的图，因为 bean 的依赖及其依赖的依赖（等等）都需要创建和分配。这些依赖项之间的不匹配可能较晚才会被发现 —— 也就是第一次创建受影响的 bean 时。</p>
<blockquote>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>使用构造函数注入时可能出现无法解析循环依赖关系的情况。</p>
<p>例如：类 A 通过构造函数注入类 B 的实例，而类 B 通过构造函数注入类 A 的实例。如果将 A 类和 B 类的 bean 配置为相互注入，则 Spring IoC 容器会在运行时检测到此循环引用，并抛出一个 BeanCurrentlyInCreationException。</p>
<p>一种可能的解决方案是改用 setter 方式注入。换句话说，尽管不推荐，但可以使用 setter 注入配置循环依赖项。</p>
<p>与典型情况（没有循环依赖）不同，bean A 和 bean B 之间的循环依赖强制其中一个 bean 在完全初始化之前被注入另一个 bean（类似鸡与蛋的场景）。</p>
</blockquote>
<p>你通常可以相信 Spring 没有问题。容器会在加载时检测配置问题，例如对不存在的 bean 和循环依赖关系的引用。当实际创建 bean 时，Spring 会尽可能晚地设置属性并解析依赖关系。这意味着如果创建该对象或其中一个依赖项时出现问题（比如 bean 因缺失或无效属性而抛出异常）那么在请求对象时，正确加载的 Spring 容器才会抛出异常。这可能会导致无法及时暴露一些配置的问题，这就是默认情况下 ApplicationContext 需要预加载单例 bean 的原因。以一些前期时间和内存为代价，ApplicationContext 会在创建时就发现配置问题。当然我们也可以指定 bean 懒加载来代替预加载。</p>
<p>如果不存在循环依赖关系，当一个或多个协作 bean 被注入依赖 bean 时，每个协作 bean 在被注入依赖 bean 之前被初始化。这意味着，如果 bean A 依赖于 bean B，那么 Spring IoC 容器在调用 bean A 上的 setter 方法之前需要初始化 bean B。也就是说，bean 会被实例化（如果它不是预先实例化的单例），设置依赖项，相关的生命周期方法（如配置的 init 方法 或 InitializingBean 回调方法）也会被调用。静态工厂方法也是一样。</p>
<h3 id="依赖关系和配置的详细说明"><a href="#依赖关系和配置的详细说明" class="headerlink" title="依赖关系和配置的详细说明"></a>依赖关系和配置的详细说明</h3><p>bean 属性和构造函数参数可以是其他 bean 的引用，也可以是内联定义的值，因此 Spring 的 XML 配置 <code>&lt;property/&gt;</code> 和 <code>&lt;constructor-arg/&gt;</code> 支持以下类型。</p>
<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p><code>&lt;property /&gt;</code> 元素的 value 属性将属性或构造函数参数指定为人类可读的字符串表示形式。 Spring 的转换服务用于将这些值从 String 转换为属性或参数的实际类型。 以下示例显示了要设置的各种值：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"masterkaoli"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下示例使用 p-namespace 进行更简洁的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:url</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:username</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:password</span>=<span class="string">"masterkaoli"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以配置 java.util.Properties 实例，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappings"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 容器通过使用 JavaBeans 机制将 <code>&lt;value/&gt;</code> 元素内的文本转换为 java.util.Properties 实例 PropertyEditor。这是一个很好的快捷方式，也是 Spring 团队支持 <code>&lt;value/&gt;</code> 在 value 属性样式上使用嵌套元素的少数几个地方之一。</p>
<h5 id="idref-标签"><a href="#idref-标签" class="headerlink" title="idref 标签"></a>idref 标签</h5><p>idref 标签只是一种防错方法，可以将容器中另一个 bean 的 id（字符串值 - 而不是引用）传递给 <code>&lt;constructor-arg/&gt;</code> 或 <code>&lt;property/&gt;</code> 标签。如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theClientBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"theTargetBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面的 bean 定义代码段与以下代码段完全等效（在运行时）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"client"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span> <span class="attr">value</span>=<span class="string">"theTargetBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一种形式优于第二种形式，因为使用 idref 标记允许容器在部署时验证引用的命名 bean 实际存在。 第二种形式不会对传递给客户端 bean 的 targetName 属性的值执行验证，只有当客户端 bean 实际被实例化时才会发现错误（很可能是致命的错误）。 如果客户端 bean 是原型(prototype) bean，那就只能在部署容器后很长时间才能发现错误并抛出异常。</p>
<p><em>注：4.0 beans XSD 中不再支持 idref 元素的 local 属性，因为它不再提供常规 bean 引用的值。 升级到 4.0 架构时，需要将现有的 idref 本地引用更改为 idref bean。</em></p>
<h4 id="其他-bean-的引用"><a href="#其他-bean-的引用" class="headerlink" title="其他 bean 的引用"></a>其他 bean 的引用</h4><p>bean 属性的值需要和目标 bean 的 id 或 name 相同：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"someBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 parent 属性指定目标 bean 会创建对当前容器的父容器中的 bean 的引用。 parent 属性的值可以与目标 bean 的 id 属性或目标 bean 的 name 属性中的值之一相同。 目标 bean 必须位于当前 bean 的父容器中。 我们最好使用此 bean 引用方式，主要是当我们有容器层次结构并且希望将现有 bean 包装在父容器中时，该容器具有与父 bean 同名的代理。 以下显示了如何使用父属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- in the parent context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.something.SimpleAccountService"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- in the child (descendant) context --&gt;</span></span><br><span class="line">&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;</span><br><span class="line">    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">parent</span>=<span class="string">"accountService"</span>/&gt;</span> <span class="comment">&lt;!-- notice how we refer to the parent bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>注：4.0 beans XSD 不再支持 ref 元素的 local 属性，因为它不再提供常规 bean 引用的值。升级到 4.0 架构时，将现有的 ref 本地引用更改为 ref bean。</em></p>
<h4 id="内部-bean"><a href="#内部-bean" class="headerlink" title="内部 bean"></a>内部 bean</h4><p>直接看例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><code>&lt;list/&gt;</code>，<code>&lt;set/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素分别对应 Java Collection 类型 List，Set，Map 和 Properties 的属性和参数。 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moreComplexObject"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"development"</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"an entry"</span> <span class="attr">value</span>=<span class="string">"just some string"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">"a ref"</span> <span class="attr">value-ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someSet"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>map 的键和值、set 的值也可以是以下类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean | ref | idref | list | set | map | props | value | null</span><br></pre></td></tr></table></figure>

<h5 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h5><p>Spring 容器还支持合并集合。你可以定义父<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，然后定义子<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素继承和覆盖父集合中的值。 也就是说，子集合的值是合并父集合和子集合的元素的结果，相同时子集合的元素覆盖父集合中指定的值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"sales"</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">administrator=administrator@example.com</span><br><span class="line">sales=sales@example.com</span><br><span class="line">support=support@example.co.uk</span><br></pre></td></tr></table></figure>

<p><code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合同样会合并。 使用<code>&lt;list/&gt;</code>元素的时候，list 是有序的，且 父级的值在所有子级列表的值之前。 对于 Map，Set 和 Properties 集合类型，不存在排序。 因此，对于作为容器在内部使用的关联 Map，Set 和 Properties 实现类型的基础的集合类型，顺序是没有意义的。</p>
<h5 id="合并集合的限制"><a href="#合并集合的限制" class="headerlink" title="合并集合的限制"></a>合并集合的限制</h5><p>我们无法合并不同的集合类型（例如 Map 和 List）。 如果不小心这么做了，则会抛出相应的异常。必须在较低的继承子定义上指定 merge 属性。 在父集合定义上指定 merge 属性是多余的，并且不会导致所需的合并。</p>
<h5 id="强类型集合"><a href="#强类型集合" class="headerlink" title="强类型集合"></a>强类型集合</h5><p>通过在 Java 5 中引入泛型类型，我们可以使用强类型集合。也就是说，可以声明一种 Collection 类型，使得它只能包含（例如）String 元素。如果使用 Spring 将强类型依赖注入 Collection 到 bean 中，则可以利用 Spring 的类型转换支持，以便强类型 Collection 实例的元素在添加到之前转换为适当的 Collection 类。以下 Java 类和 bean 定义显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"something"</span> <span class="attr">class</span>=<span class="string">"x.y.SomeClass"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accounts"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"9.99"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"2.75"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"six"</span> <span class="attr">value</span>=<span class="string">"3.99"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当为注入准备 bean 的 accounts 属性时，通过反射可获得 something 关于强类型的元素类型的泛型信息 Map&lt;String, Float&gt;。因此，Spring 的类型转换基础结构将各种值元素识别为类型 Float，并将字符串值（9.99, 2.75 和 3.99）转换为实际 Float 类型。</p>
<h4 id="Null-和空值字符串"><a href="#Null-和空值字符串" class="headerlink" title="Null 和空值字符串"></a>Null 和空值字符串</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>用 <code>&lt;null/&gt;</code> 标签标示 null：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="XML-快捷方式-p-namespace"><a href="#XML-快捷方式-p-namespace" class="headerlink" title="XML 快捷方式 p-namespace"></a>XML 快捷方式 p-namespace</h4><p>举例 1：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"classic"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"someone@somewhere.com"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p-namespace"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">p:email</span>=<span class="string">"someone@somewhere.com"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>举例 2：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-classic"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"John Doe"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spouse"</span> <span class="attr">ref</span>=<span class="string">"jane"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"jane"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Jane Doe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-modern"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.example.Person"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">p:name</span>=<span class="string">"John Doe"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">p:spouse-ref</span>=<span class="string">"jane"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"jane"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Jane Doe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="XML-快捷方式-c-namespace"><a href="#XML-快捷方式-c-namespace" class="headerlink" title="XML 快捷方式 c-namespace"></a>XML 快捷方式 c-namespace</h4><p>Spring 3.1 中引入的 c-namespace 允许使用内联属性来配置构造函数参数，无需嵌套 constructor-arg 标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanTwo"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingTwo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanThree"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingThree"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- traditional declaration with optional argument names --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingOne"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"thingTwo"</span> <span class="attr">ref</span>=<span class="string">"beanTwo"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"thingThree"</span> <span class="attr">ref</span>=<span class="string">"beanThree"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"something@somewhere.com"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- c-namespace declaration with argument names --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingOne"</span> <span class="attr">c:thingTwo-ref</span>=<span class="string">"beanTwo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">c:thingThree-ref</span>=<span class="string">"beanThree"</span> <span class="attr">c:email</span>=<span class="string">"something@somewhere.com"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于构造函数参数名称不可用的情况（例如非 debug 模式），也可以使用参数索引，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingOne"</span> <span class="attr">c:_0-ref</span>=<span class="string">"beanTwo"</span> <span class="attr">c:_1-ref</span>=<span class="string">"beanThree"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:_2</span>=<span class="string">"something@somewhere.com"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>注：由于 XML 语法，索引表示法要求存在前导 <code>_</code>，因为 XML 属性名称不能以数字开头（即使某些 IDE 允许）。对于<code>&lt;constructor-arg&gt;</code>元素也可以使用相应的索引符号，但不常用，因为通常的声明顺序通常就足够了。\</em></p>
<h4 id="复合属性名称"><a href="#复合属性名称" class="headerlink" title="复合属性名称"></a>复合属性名称</h4><p>设置 bean 属性时，可以使用复合或嵌套属性名称，只要除最终属性名称之外的路径的所有组件都不是 null，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"something"</span> <span class="attr">class</span>=<span class="string">"things.ThingOne"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fred.bob.sammy"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该 somethingbean 具有一个 fred 属性，该属性具有属性，该 bob 属性具有 sammy 属性，并且最终 sammy 属性的值设置为 123。在构造 bean 之后，fred 属性 something 和 bob 属性 fred 不得为 null，否则会抛出 NullPointerException。</p>
<h3 id="使用-depends-on"><a href="#使用-depends-on" class="headerlink" title="使用 depends-on"></a>使用 depends-on</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么 beanOne 会依赖 manager，只有 manager 初始化完成才会构建 beanOne</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lazy"</span> <span class="attr">class</span>=<span class="string">"com.something.ExpensiveToCreateBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"not.lazy"</span> <span class="attr">class</span>=<span class="string">"com.something.AnotherBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>ApplicationContext 启动时不会初始化 lazy 的 bean。</p>
<p>但是，当延迟初始化的 bean 是未进行延迟初始化的单例 bean 的依赖项时，ApplicationContext 会在启动时创建延迟初始化的 bean，因为它必须满足单例的依赖关系。</p>
<h3 id="自动注入合作-bean"><a href="#自动注入合作-bean" class="headerlink" title="自动注入合作 bean"></a>自动注入合作 bean</h3><p>Spring 容器可以自动连接协作 bean 之间的关系。 我们可以通过检查 ApplicationContext 的内容让 Spring 自动为 bean 解析协作者（其他 bean）。 自动装配具有以下优点：</p>
<ul>
<li><p>自动装配可以显着减少指定属性或构造函数参数的需要。</p>
</li>
<li><p>自动装配可以随着对象的发展更新配置。例如，如果需要向类添加依赖项，则可以自动满足该依赖项，而无需修改配置。因此，自动装配在开发期间尤其有用，而不会在代码库变得更稳定时否定切换到显式布线的选项。</p>
</li>
</ul>
<p>使用基于 XML 的配置元数据（请参阅依赖注入）时，可以使用<code>&lt;bean/&gt;</code>元素的 autowire 属性为 bean 定义指定 autowire 模式。自动装配功能有四种模式。 下表描述了四种自动装配模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>（默认）无自动装配。Bean 引用必须由 ref 元素定义。不建议对较大的部署更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td>byName</td>
<td>按属性名称自动装配。Spring 查找与需要自动装配的属性同名的 bean。例如，如果 bean 定义按名称设置为 autowire 并且它包含一个 master 属性（即，它有一个 setMaster(..)方法），则 Spring 会查找名为 bean 的定义 master 并使用它来设置属性。</td>
</tr>
<tr>
<td>byType</td>
<td>如果容器中只存在一个属性类型的 bean，则允许属性自动装配。如果存在多个，则抛出致命异常，且可能不会根据类型对该 bean 使用自动装配。如果没有匹配的 bean，则不会发生任何事情（该属性未设置）。</td>
</tr>
<tr>
<td>constructor</td>
<td>类似 byType 但适用于构造函数参数。如果容器中没有构造函数参数类型的一个 bean，则会引发致命错误。</td>
</tr>
</tbody></table>
<h4 id="自动装配的局限和缺点"><a href="#自动装配的局限和缺点" class="headerlink" title="自动装配的局限和缺点"></a>自动装配的局限和缺点</h4><ul>
<li><p>显式依赖项 property 和 constructor-arg 设置始终覆盖自动装配，且不能自动装配简单属性，例如基元 Strings 和 Classes（以及此类简单属性的数组）。这种限制是设计决定的。</p>
</li>
<li><p>自动装配不如显式布线精确。虽然如前面的表中所述，但 Spring 会谨慎地避免在可能产生意外结果的模糊性的情况下进行猜测。我们不再明确清楚 Spring 管理对象之间的关系。</p>
</li>
<li><p>可能无法为可能从 Spring 容器生成文档的工具提供装配信息。</p>
</li>
<li><p>容器中的多个 bean 定义可以匹配 setter 方法或构造函数参数指定的类型以进行自动装配。对于数组，集合或 Map 实例，这不一定是个问题。但是，对于期望单个值的依赖关系，这种模糊性不是任意解决的。如果没有可用的唯一 bean 定义，则抛出异常。</p>
</li>
</ul>
<p>在这种情况下，你有一些选择：</p>
<ul>
<li><p>放弃自动装配，支持显式装载。</p>
</li>
<li><p>通过将其 autowire-candidate 属性设置为 bean，可以避免对 bean 定义进行自动装配 false，如下一节所述。</p>
</li>
<li><p>通过将其 <code>&lt;bean/&gt;</code> 元素的 primary 属性设置为 true，将单个 bean 定义指定为主要候选者。</p>
</li>
<li><p>实现基于注释的配置可用的更细粒度的控件，如基于注释的容器配置。</p>
</li>
</ul>
<h4 id="从自动装配中排除-Bean"><a href="#从自动装配中排除-Bean" class="headerlink" title="从自动装配中排除 Bean"></a>从自动装配中排除 Bean</h4><p>在每个 bean 的基础上，我们可以从自动装配中排除 bean。在 Spring 的 XML 格式中，将元素的 autowire-candidate 属性设置<code>&lt;bean/&gt;</code>为 false。容器使特定的 bean 定义对自动装配基础结构不可用（包括@Autowired 等注解配置）。</p>
<p>我们还可以根据与 bean 名称的模式匹配来限制 autowire 候选者。 <code>&lt;beans/&gt;</code>元素在其 default-autowire-candidates 属性中接受一个或多个模式。 例如，要将 autowire 候选状态限制为名称以 Repository 结尾的任何 bean，请提供值* Repository。 要提供多个模式，请在逗号分隔的列表中定义它们。 bean 定义的 autowire-candidate 属性的显式值 true 或 false 始终优先。 对于此类 bean，模式匹配规则不适用。</p>
<p>这些技术对于永远不希望通过自动装配注入其他 bean 的 bean 非常有用。这并不意味着排除的 bean 本身不能使用自动装配进行配置。相反，bean 本身不是自动装配其他 bean 的候选者。</p>
<h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p>在大多数应用程序场景中，容器中的大多数 bean 都是单例。当单例 bean 需要与另一个单例 bean 协作或非单例 bean 需要与另一个非单例 bean 协作时，通常通过将一个 bean 定义为另一个 bean 的属性来处理依赖关系。但是当 bean 生命周期不同时会出现问题。假设单例 bean A 需要使用非单例（原型）bean B，可能是在 A 上的每个方法都调用。但是容器只创建一次单例 bean A，因此只有一次机会来设置属性。每次需要时，容器都不能为 bean A 提供 bean B 的新实例。</p>
<p>有一种不太好解决方案是放弃一些 IoC，你可以通过实现 ApplicationContextAware 接口使 bean A 意识到容器，每次通过一个 <code>getBean(&quot;B&quot;)</code> 调用来请求一个新的 bean B 实例，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span></span><br><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring-API imports</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notice the Spring API dependency!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">"command"</span>, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这么做会使得业务代码知道并耦合到 Spring Framework，正确的做法应当是使用方法注入。方法注入是 Spring IoC 容器的一个高级功能，可以让开发者干净地处理这个用例。</p>
<h4 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h4><p>查找方法注入是指容器可以重写容器管理的 bean 上的方法并返回查找结果给容器中另一个命名 bean。查找通常涉及原型 bean，如上一节中描述的场景。Spring Framework 通过使用 CGLIB 库中的<strong>字节码生成</strong>来动态生成重写该方法的子类来实现此方法注入。</p>
<blockquote>
<ul>
<li>为了使这个动态子类生效，Spring bean 容器子类不能是 <code>final</code> 的类，要覆盖的方法也不能是 <code>final</code>。</li>
<li>对具有抽象方法的类进行单元测试需要自己对类进行子类化，并提供抽象方法的桩实现。</li>
<li>组件扫描也需要具体的方法，这需要具体的类来获取。</li>
<li>另一个关键限制是查找方法不适用于工厂方法，特别是配置类中的 <code>@Bean</code> 方法，因为在这种情况下，容器不负责创建实例，因此无法在运行时生成子类。</li>
</ul>
</blockquote>
<p>对于之前的 CommandManager，Spring 容器需要动态地覆盖 createCommand() 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no more Spring imports!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，要注入的方法需要以下形式的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</span><br></pre></td></tr></table></figure>

<p>我们进行如下的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCommand"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"myCommand"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，myCommand 会被动态注入。也可以使用 <code>@Lookup</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span>(<span class="string">"myCommand"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接根据返回值推断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们通常应该使用具体的桩实现来声明这种带注释的查找方法，以使它们与 Spring 的组件扫描规则兼容，默认情况下抽象类被忽略。此限制不适用于显式注册或显式导入的 bean 类。（这段话我没看懂）</p>
<p><em>另一种解决方案是使用 ObjectFactory / Provider 注入点，详见下文。</em></p>
<h4 id="任意方法替换"><a href="#任意方法替换" class="headerlink" title="任意方法替换"></a>任意方法替换</h4><p>与查找方法注入相比，一种不太有用的方法注入形式是能够使用另一个方法实现替换托管 bean 中的任意方法。这部分不重要，跳过也没关系。</p>
<p>使用基于 XML 的配置元数据，我们可以使用 replaced-method 元素将已存在的方法实现替换为已部署的 bean。比如下面的例子，我们想覆盖它的 computeValue 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some real code...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 org.springframework.beans.factory.support.MethodReplacer 接口的类提供了新的方法定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * meant to be used to override the existing computeValue(String)</span></span><br><span class="line"><span class="comment"> * implementation in MyValueCalculator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span><br><span class="line">        String input = (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署原始类并指定方法覆盖的 bean 定义类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"myValueCalculator"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span><br><span class="line">    &lt;!-- arbitrary method replacement --&gt;</span><br><span class="line">    &lt;replaced-method name=<span class="string">"computeValue"</span> replacer=<span class="string">"replacementComputeValue"</span>&gt;</span><br><span class="line">        &lt;arg-type&gt;String&lt;/arg-type&gt;</span><br><span class="line">    &lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"replacementComputeValue"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>&lt;arg-type/&gt;</code> 元素中的一个或多个元素 <code>&lt;replaced-method/&gt;</code> 来指示被覆盖的方法的方法签名。仅当方法重载且类中存在多个变体时，才需要参数的签名。为方便起见，参数的类型字符串可以是完全限定类型名称的子字符串。<br>比如<code>java.lang.String</code>、<code>String</code>、<code>Str</code>都可以匹配<code>java.lang.String</code>。</p>
<h2 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h2><p>Spring Framework 支持六种作用域，其中后四种作用域仅在使用 Web 感知的 ApplicationContext 才可用。</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>单例</td>
<td>（默认）将单个 bean 定义范围限定为每个 Spring IoC 容器的单个对象实例</td>
</tr>
<tr>
<td>原型（prototype）</td>
<td>每次都创建新的对象</td>
</tr>
<tr>
<td>请求（request）</td>
<td>作用域为单个 HTTP 请求，也就是说，每个 HTTP 请求都有自己的 bean 实例</td>
</tr>
<tr>
<td>会话（session）</td>
<td>作用域为单个 HTTP Session</td>
</tr>
<tr>
<td>应用（application）</td>
<td>作用域为整个 ServletContext</td>
</tr>
<tr>
<td>websocket</td>
<td>作用域为单个 WebSocket 期间</td>
</tr>
</tbody></table>
<p>前两个比较简单，不再详细解释。</p>
<p>值得一提的是，使用具有依赖于原型 bean 的单例作用域 bean 时，依赖项会在单例 bean 初始化的时候被注入，此后拿到的永远是同一个原型 bean 而并未创建新的。如果需要每次都能在运行时注入新的原型 bean，参见上文<a href="#方法注入">方法注入</a>。</p>
<h3 id="Request-Session-Application-和-WebSocket-作用域"><a href="#Request-Session-Application-和-WebSocket-作用域" class="headerlink" title="Request, Session, Application 和 WebSocket 作用域"></a>Request, Session, Application 和 WebSocket 作用域</h3><p>仅当使用 Web 感知的 Spring ApplicationContext 实现（例如 XmlWebApplicationContext）时，Request、Session、Application 和 websocket 作用域才可用。如果将这些作用域与常规的 Spring IoC 容器（例如 ClassPathXmlApplicationContext）一起使用，则会引发由于未知 bean 作用域的 IllegalStateException。</p>
<h4 id="初始-Web-配置"><a href="#初始-Web-配置" class="headerlink" title="初始 Web 配置"></a>初始 Web 配置</h4><p>要在请求，会话，应用程序和 websocket 级别（统称 Web 作用域）支持 bean 的作用域，在定义 bean 之前需要做一些初始配置。（单例和原型这两种标准范围不需要此初始设置）</p>
<p>如何初始设置取决于具体的 Servlet 环境。</p>
<p>如果在 Spring Web MVC 中访问 scoped bean，实际上是在 Spring DispatcherServlet 处理的请求中，则无需进行特殊设置。 DispatcherServlet 已经公开了所有相关状态。</p>
<p>如果使用 Servlet 2.5 的 Web 容器，并且在 Spring 的 DispatcherServlet 之外处理请求（例如，使用 JSF 或 Struts 时），则需要注册 org.springframework.web.context.request.RequestContextListener 的 ServletRequestListener。对于 Servlet 3.0+，可以使用该 WebApplicationInitializer 接口以编程方式完成。或者对于旧容器可以添加以下声明到 web.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.request.RequestContextListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果不方便设置 Listener，也可以使用 RequestContextFilter：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DispatcherServlet，RequestContextListener 和 RequestContextFilter 都可以做同样的事情，也就是将 HTTP 请求对象绑定到为该请求提供服务的 Thread。这使得请求和会话范围的 bean 可以在调用链的下游进一步使用。</p>
<h4 id="Request-作用域"><a href="#Request-作用域" class="headerlink" title="Request 作用域"></a>Request 作用域</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.something.LoginAction"</span> <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>@RequestScope</code> 注解。</p>
<h4 id="作为依赖项的-Scoped-Bean"><a href="#作为依赖项的-Scoped-Bean" class="headerlink" title="作为依赖项的 Scoped Bean"></a>作为依赖项的 Scoped Bean</h4><p>Spring IoC 容器不仅管理对象（bean）的实例化，还管理协作者（或依赖关系）的连接。如果要将（例如）HTTP 请求范围的 bean 注入到寿命较长范围的另一个 bean 中，我们可以选择注入 AOP 代理来代替范围内的 bean。也就是说，需要注入一个代理对象，该对象公开与范围对象相同的公共接口，但也可以从相关范围（例如 HTTP 请求）中检索真实目标对象，并将方法调用委托给真实对象。</p>
<p>具体的操作涉及到 AOP，之后详细解释。</p>
<p><em>注：CGLIB 只拦截公共方法的调用。</em></p>
<h3 id="自定义作用域"><a href="#自定义作用域" class="headerlink" title="自定义作用域"></a>自定义作用域</h3><p>bean 的作用域机制是可扩展的。我们可以定义自己的范围，甚至可以重新定义现有的作用域，尽管后者被认为是不好的做法且我们也无法重写内置的 singleton 和 prototype 范围。</p>
<h4 id="创建自定义作用域"><a href="#创建自定义作用域" class="headerlink" title="创建自定义作用域"></a>创建自定义作用域</h4><p>要将自定义作用域集成到 Spring 容器中，需要实现 org.springframework.beans.factory.config.Scope 接口，本节将对此进行介绍。 有关如何实现自己的作用域的想法，可以参阅 Spring Framework 和 <a href="https://docs.spring.io/spring-framework/docs/5.1.8.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html" target="_blank" rel="noopener">Scope</a> javadoc 提供的 Scope 实现，它解释了需要更详细地实现的方法。</p>
<p>Scope 接口有四个方法可以从作用域获取、删除对象，以及销毁对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable destructionCallback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getConversationId</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后一个方法可以获取作用域下的对话(conversation) ID。</p>
<p>不同的作用域下的 id 互不相同，同一个作用域下使用同一个 ID。</p>
<h4 id="使用自定义作用域"><a href="#使用自定义作用域" class="headerlink" title="使用自定义作用域"></a>使用自定义作用域</h4><p>在写好一个或多个自定义 Scope 实现之后，我们需要让 Spring 容器知道这个新的作用域。这个方法是使用 Spring 容器注册新 Scope 的核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerScope</span><span class="params">(String scopeName, Scope scope)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此方法在 ConfigurableBeanFactory 接口上声明，该接口可通过 Spring 随附的大多数具体 ApplicationContext 实现上的 BeanFactory 属性获得。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scope threadScope = <span class="keyword">new</span> SimpleThreadScope();</span><br><span class="line">beanFactory.registerScope(<span class="string">"thread"</span>, threadScope);</span><br></pre></td></tr></table></figure>

<p>接下来就可以使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外也可以使用 CustomScopeConfigurer 来注册一个 Scope：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"thread"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.SimpleThreadScope"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"thing2"</span> <span class="attr">class</span>=<span class="string">"x.y.Thing2"</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Rick"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"thing1"</span> <span class="attr">class</span>=<span class="string">"x.y.Thing1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"thing2"</span> <span class="attr">ref</span>=<span class="string">"thing2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>注：在 FactoryBean 实现中放置 <code>&lt;aop：scoped-proxy/&gt;</code> 时，被限制作用域的工厂 bean 本身，而不是从 <code>getObject()</code> 返回的对象。</em></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM参数详解]]></title>
      <url>https://HaleLu.github.io/2019/07/jvm/</url>
      <content type="html"><![CDATA[<p>此篇从当前实际接触到的生产环境配置出发，聊聊 JVM 的机制以及参数设置。</p>
<a id="more"></a>

<h2 id="配置举例"><a href="#配置举例" class="headerlink" title="配置举例"></a>配置举例</h2><p>先看一个当前使用的 jvm 配置（为方便阅读我加了换行和适当注释）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/jdk8/bin/java</span><br><span class="line">-Djava.util.logging.config.file=/usr/local/webserver/app-name/conf/logging.properties</span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-XX:MetaspaceSize=256M // 初始元空间大小(也是初始的阈值，即初始的high-water-mark)，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值</span><br><span class="line">-XX:MaxMetaspaceSize=256M // 最大元空间大小</span><br><span class="line">-Xms4g // 初始内存 4g</span><br><span class="line">-Xmx4g // 最大内存 4g</span><br><span class="line">-Xmn1g // 新生代 1g</span><br><span class="line">-Xss256k // 每个线程的内存大小</span><br><span class="line">-XX:SurvivorRatio=8 // Eden 区与 Survivor 区的大小比值 1:1:8</span><br><span class="line">-XX:MaxTenuringThreshold=8 // 垃圾最大年龄</span><br><span class="line">-XX:ParallelGCThreads=8 // 并行收集器的线程数</span><br><span class="line">-XX:+UseConcMarkSweepGC // 使用 CMS 内存收集</span><br><span class="line">-XX:+UseParNewGC // 设置年轻代为并行收集 可与 CMS 收集同时使用</span><br><span class="line">-XX:+DisableExplicitGC // 关闭 System.gc()</span><br><span class="line">-XX:+CMSParallelRemarkEnabled // 启用并行标记</span><br><span class="line">-XX:+CMSClassUnloadingEnabled // 启用永久代的类卸载</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=70 // 使用 70％后开始 CMS 收集</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection // 在 Full GC 的时候，对年老代的压缩</span><br><span class="line">                                   // CMS 是不会移动内存的，因此，这个非常容易产生碎片，导致内存不够用，因此，内存的压缩这个时候就会被启用。</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=5 // 多少 Full GC 次后进行内存压缩</span><br><span class="line">                                 // 由于并发收集器不对内存空间进行压缩，整理，所以运行一段时间以后会产生&quot;碎片&quot;，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩，整理。增加这个参数是个好习惯。可能会影响性能，但是可以消除碎片</span><br><span class="line">-XX:+CMSScavengeBeforeRemark // 重新标记之前对年轻代做一次 minor GC，以期望在对老年代GC的时候可以清除更多的对象，针对 Remark 停顿太长的情况，代价是多一次 minor GC</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError // 内存溢出时导出堆信息</span><br><span class="line">-Xloggc:/usr/local/webserver/app-name/logs/gc.log // gc日志</span><br><span class="line">-XX:+UseGCLogFileRotation // 启用GC日志文件的自动转储</span><br><span class="line">-XX:NumberOfGCLogFiles=10</span><br><span class="line">-XX:GCLogFileSize=10M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime -Dcom.sun.management.jmxremote.password.file=/usr/local/webserver/app-name/conf/jmxremote.password</span><br><span class="line">-Dcom.sun.management.jmxremote.access.file=/usr/local/webserver/app-name/conf/jmxremote.access -Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line">-XX:+CMSConcurrentMTEnabled</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:HeapDumpPath=/usr/local/webserver/app-name/logs/app-name.hprof</span><br><span class="line">-javaagent:/opt/jars/aspectjweaver-1.8.9.jar -Djdk.tls.ephemeralDHKeySize=2048</span><br><span class="line">-Djava.protocol.handler.pkgs=org.apache.catalina.webresources</span><br><span class="line">-Djava.endorsed.dirs=/usr/local/webserver/app-name/endorsed</span><br><span class="line">-classpath /usr/local/webserver/app-name/bin/bootstrap.jar:/usr/local/webserver/app-name/bin/tomcat-juli.jar</span><br><span class="line">-Dcatalina.base=/usr/local/webserver/app-name</span><br><span class="line">-Dcatalina.home=/usr/local/webserver/app-name</span><br><span class="line">-Djava.io.tmpdir=/usr/local/webserver/app-name/temp</span><br><span class="line">org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure>

<h2 id="配置解读"><a href="#配置解读" class="headerlink" title="配置解读"></a>配置解读</h2><p>除去一些日志和路径配置，其他主要包含两种配置</p>
<h3 id="内存配置"><a href="#内存配置" class="headerlink" title="内存配置"></a>内存配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=256M // 初始元空间大小(也是初始的阈值，即初始的high-water-mark)，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值</span><br><span class="line">-XX:MaxMetaspaceSize=256M // 最大元空间大小</span><br><span class="line">-Xms4g // 初始内存 4g</span><br><span class="line">-Xmx4g // 最大内存 4g</span><br><span class="line">-Xmn1g // 新生代 1g</span><br><span class="line">-Xss256k // 每个线程的内存大小</span><br><span class="line">-XX:SurvivorRatio=8 // Eden 区与 Survivor 区的大小比值 1:1:8</span><br></pre></td></tr></table></figure>

<p>可以看到我们目前使用的参数是 4G 内存，其中新生代指定 1G，老年代则为剩下的 3G。元数据区的大小为 256M。单线程最大 256k。</p>
<p>这边值得一提的是，从 JAVA 8 开始，永久代被移除出 JVM，改为元数据（metadata）区。</p>
<h3 id="GC-策略配置"><a href="#GC-策略配置" class="headerlink" title="GC 策略配置"></a>GC 策略配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio=8 // Eden 区与 Survivor 区的大小比值 1:1:8</span><br><span class="line">-XX:MaxTenuringThreshold=8 // 垃圾最大年龄</span><br><span class="line">-XX:ParallelGCThreads=8 // 并行收集器的线程数</span><br><span class="line">-XX:+UseConcMarkSweepGC // 使用 CMS 收集器</span><br><span class="line">-XX:+UseParNewGC // 年轻代使用 ParNew 收集器，可与 CMS 收集同时使用</span><br><span class="line">-XX:+DisableExplicitGC // 关闭 System.gc()</span><br><span class="line">-XX:+CMSParallelRemarkEnabled // 启用并行标记</span><br><span class="line">-XX:+CMSClassUnloadingEnabled // 启用永久代的类卸载</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=70 // 使用 70％后开始 CMS 收集</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection // 在 Full GC 的时候，对年老代的压缩</span><br><span class="line">                                   // CMS 是不会移动内存的，因此，这个非常容易产生碎片，导致内存不够用，因此，内存的压缩这个时候就会被启用。</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=5 // 多少 Full GC 次后进行内存压缩</span><br><span class="line">                                 // 由于并发收集器不对内存空间进行压缩，整理，所以运行一段时间以后会产生&quot;碎片&quot;，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩，整理。增加这个参数是个好习惯。可能会影响性能，但是可以消除碎片</span><br><span class="line">-XX:+CMSScavengeBeforeRemark // 重新标记之前对年轻代做一次 minor GC，以期望在对老年代GC的时候可以清除更多的对象，针对 Remark 停顿太长的情况，代价是多一次 minor GC</span><br><span class="line">-XX:+CMSConcurrentMTEnabled // 并发的CMS阶段将以多线程执行(因此，多个GC线程会与所有的应用程序线程并行工作)。</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br></pre></td></tr></table></figure>

<p>首先可以看到使用的收集器为 ParNew + CMS，这里简单介绍一下两种 GC 策略</p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 常被用作新生代的收集器，具体策略如下：</p>
<ol>
<li>等待所有执行中的用户线程进行到 safepoint，然后 Stop the World</li>
<li>并行进行 GC，采用标记-复制算法清理新生代</li>
</ol>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS 是目前最常用的老年代收集器，其主要步骤如下：</p>
<ol>
<li>等待所有执行中的用户线程进行到 safepoint，然后 Stop the World</li>
<li>单线程进行初始标记，标记 GC Roots（本地变量、方法区中静态对象、常量、JNI 中对象）</li>
<li>和用户进程并行，进行并发标记，逐级搜索 GC Roots 进行可达性分析</li>
<li>再次等待所有执行中的用户线程进行到 safepoint，然后 Stop the World</li>
<li>和用户进程并行，进行重新标记，修正标记产生变动的那一部分</li>
<li>和用户进程并行，清理老年代对象（并不整理）</li>
<li>和用户进程并行，清理并恢复在 CMS GC 过程中的各种状态，重新初始化 CMS 相关数据结构</li>
</ol>
<p>再回头来看这套配置：</p>
<ul>
<li>新生代的 Eden 区与 Survivor 区的大小比值 1:1:8</li>
<li>新生代经过 8 次 minor GC 后进入老年代；</li>
<li>GC 的并行数为 8</li>
<li>关闭显式 GC（即 System.gc()）</li>
<li>启用类卸载，即会回收元数据空间</li>
<li>老年代使用 70%后开始 CMS 收集</li>
<li>每 5 次 CMS 收集后整理老年代内存（因为 CMS 收集只会对老年代的对象执行清除操作，并不会整理，长期后会产生过多的碎片，导致实际内存足够但无法申请出足够的内存）</li>
<li>在 CMS 的重新标记（第五步）前对年轻代执行一次 minor GC（这样在对老年代重新标记时可以清除出更多的对象）</li>
<li>CMS 与用户进程并发的阶段会启动多个 GC 进程并发</li>
<li>开启并行显式 Full GC，但其实在这是个废配置，因为 DisableExplicitGC 已经禁用了显式 Full GC</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[raft]]></title>
      <url>https://HaleLu.github.io/2019/01/raft/</url>
      <content type="html"><![CDATA[<p>本篇讲解分布式系统共识算法 raft 的基本姿势，<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">相关论文</a>可点击这里。</p>
<p>注：此篇尚未整理完成，虽然代码已经完成，但因一些变故，日后再继续整理</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Paxos 作为一套可以解决分布式场景下高容错（半数以内的机器挂掉）的共识算法被广泛接受，然而由于其难以被理解所以少有直接的实现。Raft 的本质其实是对 Paxos 协议加强后的一种实现方式，对诸多细节进行了定义，使得这套系统变得易于实现。（个人认为，其实不得不承认的是，这样的代价是降低了效率）。</p>
<p>Raft 类似于其他的共识算法，但它有几个独有的特征———</p>
<ul>
<li>强 leader：Raft 的 leader 相比其他算法要更强，例如 log entry（理解为一条记录）只允许从 leader 通知给其他服务器，这使得 log entry 的分发变得简单易于理解；</li>
<li>leader 选举：Raft 中每个服务器都有自己不同的（随机）竞选周期。这一对心跳机制的独特改进有效解决了可能出现的选举冲突问题；</li>
<li>成员变更：Raft 在变更服务器集群成员时使用了新的联合共识方法，切换期间两个不同配置的大多数服务器保持重叠。</li>
</ul>
<p>看不懂没关系，往下看。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先讲一讲共识算法的一些基本概念（不仅仅是 raft 协议）。</p>
<h3 id="可复制状态机"><a href="#可复制状态机" class="headerlink" title="可复制状态机"></a>可复制状态机</h3><p>共识算法基本讲的都是基于可复制状态机的共识算法，服务器集合中的所有状态机都可以通过相同的日志拷贝计算得到相同的状态，即使一些（不超过半数）服务器出现异常也一样能保持一致。可复制状态机是众多大型分布式系统的基础。例如包括 GFS、HDFS、RAMCloud 等通常使用分布式的可复制状态机管理 leader 选举和保存配置信息。常见的可复制状态机的例子包括 Chubby 和 ZooKeeper。</p>
<p>可复制状态机通常通过可复制 log 实现。每台服务器保存了相同的所有历史 command 的 log，状态机依次执行这些 command 可以得到相同的状态和输出。（类比 git）</p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在共识协议中通常节点服务器有三种状态——leader、candidate 和 follower。</p>
<ul>
<li>leader：通常由 leader 决定确认 command 的写入，或者在数据不一致时决定使用的内容，或者由 leader 负责分发内容。</li>
<li>candidate：candidate 是候选人，candidate 并不总是存在。当 leader 节点出现异常或某些情况下，follower 会成为 candidate 并通过获得多数确认成为 leader。</li>
<li>follower：follower 作为分布式的执行机，接收执行来自 leader 的执行等。</li>
</ul>
<p>服务器节点的角色会在三种状态间根据规则切换。</p>
<h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><ul>
<li>心跳检测：所有 follower 和 leader 间会通过心跳保证连接正常。当 follower 长时间无法收到 leader 的心跳时或心跳回复时判定 leader 挂掉（真实情况下也可能是自己网络挂了）</li>
<li>leader 选举：当目前的 leader 无法正常工作或连接到时，需要进行 leader 选举选出新的 leader，一些 follower 会成为 candidate，并在获得半数赞同投票时成为新的 leader</li>
<li>投票：当收到竞选请求时决定是否选举 candidate 为 leader</li>
<li>log 分发：leader 会接受来自客户端的 log，然后将其分发复制给整个集群，同时强制要求其他节点与自己一致</li>
</ul>
<h2 id="raft-基础"><a href="#raft-基础" class="headerlink" title="raft 基础"></a>raft 基础</h2><p>在 raft 中，follower 是完全被动的：follower 不主动发送任何请求，只对 leader 和 candidate 的请求做回应。（如果客户端向 follower 发送了 command，follower 将其重定向到 leader）只有 leader 拥有 log 的写入权限，所有的 command 由 leader 先接受，然后分发给所有 follower，不一致时可覆盖 follower 内容。下图简要展示了各角色切换的条件。</p>
<p><img src=".png" alt></p>
<p>raft 采用任期制，任期用递增的整数表示。leader 由选举选出，在竞选时会有一到多个 candidate 尝试成为 leader，当 candidate 赢得竞选后，它会转变为该任期的 leader 直到新的任期。在某些情况下，投票可能无法产生大多数同意的情况（比如 3 个 candidate 每人获得了总数 1/3 节点的支持），那么很快新的任期（新的选举）会再次开始以打破局面。由此可以看出，raft 保证了每一任期至多有一个 leader。</p>
<p>然而作为分布式系统，不同的节点可能并不总是同时能观察到任期的更迭，甚至某些情况下某个节点可能会错过整个选举甚至整个任期，所以对于每个节点而言，都会存有一份当前任期和当前 leader。所有的节点间通信都会带上任期信息以校验传来的或自己节点的数据是否过期，并更新或通知更新。当 candidate 发现自己的 term 已经过旧则立刻回归 follower 状态。对于过旧的请求服务器直接拒绝执行。</p>
<p>raft 节点间通过 RPC 通信。具体的 RPC 格式在下文解释。</p>
<h2 id="raft-实现"><a href="#raft-实现" class="headerlink" title="raft 实现"></a>raft 实现</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><h4 id="持久状态"><a href="#持久状态" class="headerlink" title="持久状态"></a>持久状态</h4><p>这些状态信息需要在每次响应 RPC 前更新到静态存储</p>
<ul>
<li>currentTerm：节点观察到的最新任期（初始化为 0，递增）</li>
<li>votedFor：当前任期选举环节投给的 candidate 节点 ID</li>
<li>log[]：log 条目数组，每个条目都包含一条状态机 command 和收到该指令时的任期（首条下标为 1）</li>
</ul>
<h4 id="所有服务的易失状态"><a href="#所有服务的易失状态" class="headerlink" title="所有服务的易失状态"></a>所有服务的易失状态</h4><ul>
<li>commitIndex 已知最高日志条目的下标（初始化为 0，单调增加）</li>
<li>lastApplied 应用于状态机的最高日志条目的下标（初始化为 0，单调增加）</li>
</ul>
<h4 id="leader-的易失状态"><a href="#leader-的易失状态" class="headerlink" title="leader 的易失状态"></a>leader 的易失状态</h4><p>选举后重新初始化</p>
<ul>
<li>nextIndex[] 对于每个服务器，要发送到该服务器的下一个日志条目的下标（初始化为领导者最后日志下标+1）</li>
<li>matchIndex[] 对于每个服务器，已知在服务器上复制的最高日志条目的下标（初始化为 0，单调增加）</li>
</ul>
<p>AppendEntries RPC</p>
<p>由 leader 调用以复制日志条目; 也用作心跳。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 源码阅读（一）]]></title>
      <url>https://HaleLu.github.io/2017/09/Redis-Source-Code-1/</url>
      <content type="html"><![CDATA[<p>Redis 作为常用的内存数据库，代码精简易于阅读，所以成为我 Linux C 开发学习之首选。<br>Redis源码版本：4.0.2</p>
<a id="more"></a>

<p>本章主要看内存相关操作。</p>
<h1 id="zmalloc-c-amp-zmalloc-h"><a href="#zmalloc-c-amp-zmalloc-h" class="headerlink" title="zmalloc.c &amp; zmalloc.h"></a>zmalloc.c &amp; zmalloc.h</h1><p>定义各种内存申请操作。</p>
<p>提供了三种库，一种是google的tcmalloc，一种是jemalloc，还有一种就是malloc</p>
<h2 id="zmalloc"><a href="#zmalloc" class="headerlink" title="zmalloc"></a>zmalloc</h2><p>最简单的申请内存。加了一个<code>size_t</code>的空间，记录当前申请的空间的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//oom : out of memory</span></span><br><span class="line">    <span class="comment">//zmalloc_oom 是一个错误处理函数，输出错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//如果未定义malloc_size，那么在第一个位置写上size，更新used_memory后返回真正内容的地址</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未提供<code>zmalloc_size</code>函数，默认方法是向前取<code>PREFIX_SIZE</code>拿到<code>size</code>，相加得到真正的<code>size</code>（在刚才的情况中并不会被调用到）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</span><br><span class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></span><br><span class="line"><span class="comment">     * the underlying allocator. */</span></span><br><span class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中<code>update_zmalloc_stat_alloc</code>作用是更新<code>used_memory</code>。首先将<code>n</code>用<code>long</code>对齐，然后原子加<code>used_memory</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    atomicIncr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>atomicIncr</code>定义如下，<code>__atomic_add_fetch</code>是内建函数，原型为<code>type __atomic_add_fetch (type *ptr, type val, int memorder)</code>，详见<a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html" target="_blank" rel="noopener">文档</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure>

<h2 id="zfree"><a href="#zfree" class="headerlink" title="zfree"></a>zfree</h2><p>释放内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-get-rss"><a href="#zmalloc-get-rss" class="headerlink" title="zmalloc_get_rss"></a>zmalloc_get_rss</h2><p>获取RSS（resident set size，常驻内存大小）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROC_STAT)</span></span><br><span class="line"><span class="comment">//通过proc/&lt;pid&gt;/stat获取RSS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_TASKINFO)</span></span><br><span class="line"><span class="comment">//MACH内核可以通过task_info获取大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">task_t</span> task = MACH_PORT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> <span class="title">t_info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> t_info_count = TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_for_pid(current_task(), getpid(), &amp;task) != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    task_info(task, TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)&amp;t_info, &amp;t_info_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t_info.resident_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//使用used_memory值，并不是准确的RSS，会使得碎片率固定为1</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we can't get the RSS in an OS-specific way for this system just</span></span><br><span class="line"><span class="comment">     * return the memory usage we estimated in zmalloc()..</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Fragmentation will appear to be always 1 (no fragmentation)</span></span><br><span class="line"><span class="comment">     * of course... */</span></span><br><span class="line">    <span class="keyword">return</span> zmalloc_used_memory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-get-fragmentation-ratio"><a href="#zmalloc-get-fragmentation-ratio" class="headerlink" title="zmalloc_get_fragmentation_ratio"></a>zmalloc_get_fragmentation_ratio</h2><p>碎片率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fragmentation = RSS / allocated-bytes */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">size_t</span> rss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)rss/zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-get-smap-bytes-by-field"><a href="#zmalloc-get-smap-bytes-by-field" class="headerlink" title="zmalloc_get_smap_bytes_by_field"></a>zmalloc_get_smap_bytes_by_field</h2><p>按字段名计算总字节数，字段名需要以”:”结尾，pid为-1表示当前进程。若不支持直接返回0。（利用<code>&quot;proc/&lt;pid&gt;/smaps&quot;</code>或<code>&quot;proc/self/smaps&quot;</code>信息）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get the sum of the specified field (converted form kb to bytes) in</span></span><br><span class="line"><span class="comment"> * /proc/self/smaps. The field must be specified with trailing ":" as it</span></span><br><span class="line"><span class="comment"> * apperas in the smaps output.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If a pid is specified, the information is extracted for such a pid,</span></span><br><span class="line"><span class="comment"> * otherwise if pid is -1 the information is reported is about the</span></span><br><span class="line"><span class="comment"> * current process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example: zmalloc_get_smap_bytes_by_field("Rss:",-1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROC_SMAPS)</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_smap_bytes_by_field(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid) &#123;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flen = <span class="built_in">strlen</span>(field);</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        fp = fopen(<span class="string">"/proc/self/smaps"</span>,<span class="string">"r"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> filename[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(filename,<span class="keyword">sizeof</span>(filename),<span class="string">"/proc/%ld/smaps"</span>,pid);</span><br><span class="line">        fp = fopen(filename,<span class="string">"r"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,<span class="keyword">sizeof</span>(line),fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line,field,flen) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(line,<span class="string">'k'</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                *p = <span class="string">'\0'</span>;</span><br><span class="line">                bytes += strtol(line+flen,<span class="literal">NULL</span>,<span class="number">10</span>) * <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_smap_bytes_by_field(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid) &#123;</span><br><span class="line">    ((<span class="keyword">void</span>) field);</span><br><span class="line">    ((<span class="keyword">void</span>) pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-get-memory-size"><a href="#zmalloc-get-memory-size" class="headerlink" title="zmalloc_get_memory_size"></a>zmalloc_get_memory_size</h2><p>返回物理内存字节数。（声称虽然看起来丑但是已经是最干净的方式）</p>
<p>通过<code>sysctl</code>或<code>sysconf</code>查询物理内存使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> zmalloc_get_memory_size(<span class="keyword">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__unix) || defined(unix) || \</span></span><br><span class="line">    (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CTL_HW) &amp;&amp; (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_MEMSIZE)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_MEMSIZE;            <span class="comment">/* OSX. --------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM64)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM64;          <span class="comment">/* NetBSD, OpenBSD. --------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int64_t</span> size = <span class="number">0</span>;               <span class="comment">/* 64-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl( mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_SC_PHYS_PAGES) &amp;&amp; defined(_SC_PAGESIZE)</span></span><br><span class="line">    <span class="comment">/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)sysconf(_SC_PHYS_PAGES) * (<span class="keyword">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CTL_HW) &amp;&amp; (defined(HW_PHYSMEM) || defined(HW_REALMEM))</span></span><br><span class="line">    <span class="comment">/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_REALMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_REALMEM;        <span class="comment">/* FreeBSD. ----------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PYSMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM;        <span class="comment">/* Others. ------------------ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">0</span>;      <span class="comment">/* 32-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown method to get the data. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown OS. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 阅读 </tag>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ManualResetEvent 与 AutoResetEvent 简介]]></title>
      <url>https://HaleLu.github.io/2017/07/ManualResetEvent-and-AutoResetEvent/</url>
      <content type="html"><![CDATA[<p>ManualResetEvent 和 AutoResetEvent 是两种线程同步的方案。</p>
<a id="more"></a>

<p>他们可以通过调用 <code>WaitOne()</code> 方法阻塞当前线程，直到其他线程上调用了 <code>Set()</code> 方法。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>详细的使用方法如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> manualResetEvent = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task1 : Before WaitOne()"</span>);</span><br><span class="line">                manualResetEvent.WaitOne();</span><br><span class="line">                Console.WriteLine(<span class="string">"task1 : After WaitOne()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> task2 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task2 : Before Set()"</span>);</span><br><span class="line">                manualResetEvent.Set();</span><br><span class="line">                Console.WriteLine(<span class="string">"task2 : After Set()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            task1.Start();</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            task2.Start();</span><br><span class="line"></span><br><span class="line">            Task.WaitAll(task1, task2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task1 : Before WaitOne()</span><br><span class="line">task2 : Before Set()</span><br><span class="line">task2 : After Set()</span><br><span class="line">task1 : After WaitOne()</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先需要初始化一个 <code>ManualResetEvent</code> 或是 <code>AutoResetEvent</code> 。构造函数带一个参数，类型为 bool ，表示初始状态是否设置为终止。这个状态之后可以通过 <code>Set()</code> 和 <code>Reset()</code> 方法来改变。</p>
<p>换句话说，类似于 Event 中有一个开关，表示是否 <code>WaitOne</code> 时是否阻塞。</p>
<p>如果初始化为 true ，或是调用过 <code>Set()</code> ，那么这个开关就是打开的状态，当 Event 调用 <code>WaitOne()</code> 方法时，线程不会暂停，会继续执行下去。</p>
<p>而当初始化为 false ，或是调用过 <code>Reset()</code> 时，那么这个开关就是关闭的状态，当 Event 调用 <code>WaitOne()</code> 方法时线程会被阻塞，直到有其他线程通过 <code>Set()</code> 打开了开关。</p>
<h2 id="ManualResetEvent-与-AutoResetEvent-的区别"><a href="#ManualResetEvent-与-AutoResetEvent-的区别" class="headerlink" title="ManualResetEvent 与 AutoResetEvent 的区别"></a>ManualResetEvent 与 AutoResetEvent 的区别</h2><h3 id="ManualResetEvent"><a href="#ManualResetEvent" class="headerlink" title="ManualResetEvent"></a>ManualResetEvent</h3><p><code>ManualResetEvent</code> 的 <code>Set()</code> 为打开，<code>Reset()</code> 为关闭。一旦打开，所有阻塞在 <code>WaitOne()</code> 的线程都会继续执行。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> manualResetEvent = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task1 : Before WaitOne()"</span>);</span><br><span class="line">                manualResetEvent.WaitOne();</span><br><span class="line">                Console.WriteLine(<span class="string">"task1 : After WaitOne()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> task2 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task2 : Before WaitOne()"</span>);</span><br><span class="line">                manualResetEvent.WaitOne();</span><br><span class="line">                Console.WriteLine(<span class="string">"task2 : After WaitOne()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> task3 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task3 : Before Set()"</span>);</span><br><span class="line">                manualResetEvent.Set();</span><br><span class="line">                Console.WriteLine(<span class="string">"task3 : After Set()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            task1.Start();</span><br><span class="line">            task2.Start();</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            task3.Start();</span><br><span class="line"></span><br><span class="line">            Task.WaitAll(task1, task2, task3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task2 : Before WaitOne()</span><br><span class="line">task1 : Before WaitOne()</span><br><span class="line">task3 : Before Set()</span><br><span class="line">task3 : After Set()</span><br><span class="line">task1 : After WaitOne()</span><br><span class="line">task2 : After WaitOne()</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h3 id="AutoResetEvent"><a href="#AutoResetEvent" class="headerlink" title="AutoResetEvent"></a>AutoResetEvent</h3><p><code>AutoResetEvent</code> 的 <code>Set()</code> 和 <code>Reset()</code> 与 <code>ManualResetEvent</code> 一致。不同的是，每有一个阻塞在 <code>WaitOne()</code> 的线程由于开关打开而继续执行，都会自动回弹开关。（这也就是 AutoReset 的含义）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> autoResetEvent = <span class="keyword">new</span> AutoResetEvent(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task1 : Before WaitOne()"</span>);</span><br><span class="line">                autoResetEvent.WaitOne();</span><br><span class="line">                Console.WriteLine(<span class="string">"task1 : After WaitOne()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> task2 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task2 : Before WaitOne()"</span>);</span><br><span class="line">                autoResetEvent.WaitOne();</span><br><span class="line">                Console.WriteLine(<span class="string">"task2 : After WaitOne()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> task3 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"task3 : Before Set()"</span>);</span><br><span class="line">                autoResetEvent.Set();</span><br><span class="line">                Console.WriteLine(<span class="string">"task3 : After Set()"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            task1.Start();</span><br><span class="line">            task2.Start();</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            task3.Start();</span><br><span class="line"></span><br><span class="line">            Task.WaitAll(task1, task2, task3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task1 : Before WaitOne()</span><br><span class="line">task2 : Before WaitOne()</span><br><span class="line">task3 : Before Set()</span><br><span class="line">task3 : After Set()</span><br><span class="line">task1 : After WaitOne()</span><br></pre></td></tr></table></figure>

<p>保持阻塞，无法继续执行。<br>原因是 task1 被唤醒的同时关闭了开关， task2 无法通过。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>需要唤醒的线程只有一个时，两种没有区别。</p>
<p>会有多个线程同时等待，而每次只希望唤醒一个线程时，用 AutoResetEvent ，</p>
<p>希望一次唤醒所有线程永久可以通过时，用 ManualResetEvent 。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> C# </tag>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一些实用的 .NET 开发工具（一）：swagger]]></title>
      <url>https://HaleLu.github.io/2017/03/DotNET-Tools-1/</url>
      <content type="html"><![CDATA[<h1 id="swagger-是什么？"><a href="#swagger-是什么？" class="headerlink" title="swagger 是什么？"></a>swagger 是什么？</h1><p>swagger 是一套框架，作用是自动化生成 .NET 的 Web API 项目的 API 文档。<br>ASP.NET Core 官方提供了简单的 Swagger 使用文档：<a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger" target="_blank" rel="noopener">ASP.NET Web API Help Pages using Swagger</a></p>
<a id="more"></a>

<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><ol>
<li><p>首先我们要安装 Swashbuckle.AspNetCore 的 Nuget 包</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Swashbuckle.AspNetCore -Pre</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们可以在 <em>Startup.cs</em> 中的 <em>ConfigureServices</em> 方法中注册 Swagger 文档生成器，这里可以定义一个或多个需要生成的文档</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">services.AddMvc();</span><br><span class="line"></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">c.SwaggerDoc(<span class="string">"v1"</span>, <span class="keyword">new</span> Info &#123; Title = <span class="string">"My API"</span>, Version = <span class="string">"v1"</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们需要确保所有的 API 方法和非路径的参数都有明确的 Http 和 From 绑定修饰符</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params">[FromBody]Product product</span>)</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[HttpGet]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable&lt;Product&gt; <span class="title">Search</span>(<span class="params">[FromQuery]<span class="keyword">string</span> keywords</span>)</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<p> <em>注: 省略参数绑定修饰符则默认为请求 (query) 字段</em></p>
</li>
<li><p>在 <em>Configure</em> 方法中添加中间件来暴露 Swagger 生成的文档 JSON</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwagger();</span><br></pre></td></tr></table></figure>

<p> <em>此时你可以启动应用并在 “/swagger/v1/swagger.json.” 下看到 Swagger 生成的 JSON</em></p>
</li>
<li><p>（可选）如果你想得到交互式的文档，可以添加 swagger-ui 中间件。需要指定 Swagger JSON 源</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">"/swagger/v1/swagger.json"</span>, <span class="string">"My API V1"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <em>在 “/swagger” 下可以看到这个交互式的页面</em></p>
</li>
</ol>
<h1 id="Swashbuckle-amp-ApiExplorer"><a href="#Swashbuckle-amp-ApiExplorer" class="headerlink" title="Swashbuckle &amp; ApiExplorer"></a>Swashbuckle &amp; ApiExplorer</h1><p>Swashbuckle 十分依赖 <em>ApiExplorer</em> 。<em>ApiExplorer</em> 是一项位于 ASP.NET Core 之上的 Metadata 层的服务。如果服务集使用的是 <em>AddMvc</em> 方法引导 MVC 栈的话那么会自动注册 <em>ApiExplorer_。然而如果是用 _AddMvcCore</em> 来自行引导 MVC stack 的话你需要手动添加 Api Explorer 服务:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">services.AddMvcCore()</span><br><span class="line">    .AddApiExplorer();</span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Swashbuckle 包含三个包：Swagger 生成器, 暴露 JSON 格式 Swagger 文档的中间件和使用这个 JSON 暴露 swagger-ui 的中间件。 你可以通过 “Swashbuckle.AspNetCore” 包一起下载这些包或根据自己的需要独立下载。详细说明如下表所示</p>
<table>
<thead>
<tr>
<th>Package</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Swashbuckle.AspNetCore.Swagger</strong></td>
<td>用一个 JSON API 暴露 <em>SwaggerDocument</em> 对象。在返回一个序列化的 JSON 之前，这个包需要注册一个 <em>ISwaggerProvider</em> 的实现用于生成 Swagger 文档</td>
</tr>
<tr>
<td><strong>Swashbuckle.AspNetCore.SwaggerGen</strong></td>
<td>用于注入第一个组件需要的 <em>ISwaggerProvider</em> 的实现。这个特定的实现可以用你的路由（routes）、控制器（controllers）和模型（models）自动生成 Swagger 文档</td>
</tr>
<tr>
<td><strong>Swashbuckle.AspNetCore.SwaggerUI</strong></td>
<td>暴露一个嵌入版本的 swagger-ui。你可以指定 ui 从哪个 API 获取Swagger JSON，然后 ui 会使用 JSON 生成交互式文档</td>
</tr>
</tbody></table>
<h1 id="配置-amp-自定义"><a href="#配置-amp-自定义" class="headerlink" title="配置 &amp; 自定义"></a>配置 &amp; 自定义</h1><!--
* [Swashbuckle.AspNetCore.Swagger](#swashbuckleaspnetcoreswagger)

    * [修改 Swagger JSON 路径](#修改-Swagger-JSON-路径)
    * [使用 HTTP 请求信息修改 Swagger](#使用-HTTP-请求信息修改-Swagger)

* [Swashbuckle.AspNetCore.SwaggerGen](#swashbuckleaspnetcoreswaggergen)

    * [列举 HTTP responses](#列举-HTTP-responses)
    * [Include Descriptions from XML Comments](#include-descriptions-from-xml-comments)
    * [Provide Global API Metadata](#provide-global-api-metadata)
    * [Generate Multiple Swagger Documents](#generate-multiple-swagger-documents)
    * [Omit Obsolete Operations and/or Schema Properties](#omit-obsolete-operations-andor-schema-properties)
    * [Omit Arbitrary Operations](#omit-arbitrary-operations)
    * [Customize Operation Tags (e.g. for UI Grouping)](#customize-operation-tags-eg-for-ui-grouping)
    * [Change Operation Sort Order (e.g. for UI Sorting)](#change-operation-sort-order-eg-for-ui-sorting)
    * [Customize Schema Id's](#customize-schema-ids)
    * [Customize Schema for Enum Types](#customize-schema-for-enum-types)
    * [Override Schema for Specific Types](#override-schema-for-specific-types)
    * [Extend Generator with Operation, Schema & Document Filters](#extend-generator-with-operation-schema--document-filters)
    * [Add Security Definitions and Requirements](#add-security-definitions-and-requirements)

* [Swashbuckle.AspNetCore.SwaggerUI](#swashbuckleaspnetcoreswaggerui)
    * [Change Releative Path to the UI](#change-relative-path-to-the-ui)
    * [List Multiple Swagger Documents](#list-multiple-swagger-documents)
    * [Apply swagger-ui Parameters](#apply-swagger-ui-parameters)
    * [Inject Custom CSS](#inject-custom-css)
    * [Enable OAuth2.0 Flows](#enable-oauth20-flows)
-->

<h2 id="Swashbuckle-AspNetCore-Swagger"><a href="#Swashbuckle-AspNetCore-Swagger" class="headerlink" title="Swashbuckle.AspNetCore.Swagger"></a>Swashbuckle.AspNetCore.Swagger</h2><h3 id="修改-Swagger-JSON-路径"><a href="#修改-Swagger-JSON-路径" class="headerlink" title="修改 Swagger JSON 路径"></a>修改 Swagger JSON 路径</h3><p>Swagger JSON 默认暴露在 <code>/swagger/{documentName}/swagger.json</code> 路径下。在启用中间件时我们可以自行修改这个路径。自定义的路径<strong>必须</strong>包含 <code>{documentName}</code> 字段。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwagger(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.RouteTemplate = <span class="string">"api-docs/&#123;documentName&#125;/swagger.json"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><em>NOTE: 如果同时也使用了 SwaggerUI 中间件，那么我们还需要更新 Swagger UI 的配置：</em></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">"/api-docs/v1/swagger.json"</span>, <span class="string">"My API V1"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用-HTTP-请求信息修改-Swagger"><a href="#使用-HTTP-请求信息修改-Swagger" class="headerlink" title="使用 HTTP 请求信息修改 Swagger"></a>使用 HTTP 请求信息修改 Swagger</h3><p>如果我们想使用当前请求的某些信息设置 Swagger metadata，那么可以注册一个过滤器。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwagger(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.PreSerializeFilters.Add((swaggerDoc, httpReq) =&gt; swaggerDoc.Host = httpReq.Host.Value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><em>SwaggerDocument</em> 和当前的 <em>HttpRequest</em> 都会被传递至过滤器。这个方法提供了很大的灵活性。例如你可以赋值给 <code>host</code> 属性（如上所示），你也可以检查 session 信息或者是 Authoriation header 来验证用户权限。 </p>
<h2 id="Swashbuckle-AspNetCore-SwaggerGen"><a href="#Swashbuckle-AspNetCore-SwaggerGen" class="headerlink" title="Swashbuckle.AspNetCore.SwaggerGen"></a>Swashbuckle.AspNetCore.SwaggerGen</h2><h3 id="列举-HTTP-responses"><a href="#列举-HTTP-responses" class="headerlink" title="列举 HTTP responses"></a>列举 HTTP responses</h3><p>Swashbuckle 默认会为所有方法生成 <code>200</code> responses。如果这个方法返回一个 DTO，那么这个 DTO 将会被用来生成 HTTP responses body 的 schema，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">GetById</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br></pre></td></tr></table></figure>

<p>Will produce the following response metadata:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">responses: &#123;</span><br><span class="line">  200: &#123;</span><br><span class="line">    description: &quot;Success&quot;,</span><br><span class="line">    schema: &#123;</span><br><span class="line">      $ref: &quot;#/definitions/Product&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指定-HTTP-responses"><a href="#指定-HTTP-responses" class="headerlink" title="指定 HTTP responses"></a>指定 HTTP responses</h4><p>如果你想要指定一个状态码和/或其他 responses，或者需要返回的不是 DTO 而是 <em>IActionResult_，你可以用 ASP.NET Core 中的 _ProducesResponseTypeAttribute</em> 描述特定的 response，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">[<span class="meta">ProducesResponseType(typeof(Product), 200)</span>]</span><br><span class="line">[<span class="meta">ProducesResponseType(typeof(IDictionary&lt;string, string&gt;), 400)</span>]</span><br><span class="line">[<span class="meta">ProducesResponseType(typeof(void), 500)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetById</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br></pre></td></tr></table></figure>

<p>这种写法会得到的 response metadata:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">responses: &#123;</span><br><span class="line">  200: &#123;</span><br><span class="line">    description: &quot;Success&quot;,</span><br><span class="line">    schema: &#123;</span><br><span class="line">      $ref: &quot;#/definitions/Product&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  400: &#123;</span><br><span class="line">    description: &quot;Bad Request&quot;,</span><br><span class="line">    schema: &#123;</span><br><span class="line">      type: &quot;object&quot;,</span><br><span class="line">      additionalProperties: &#123;</span><br><span class="line">        type: &quot;string&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  500: &#123;</span><br><span class="line">    description: &quot;Server Error&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-XML-注释生成描述"><a href="#使用-XML-注释生成描述" class="headerlink" title="使用 XML 注释生成描述"></a>使用 XML 注释生成描述</h3><p>为了增强可读性，控制器和模型可以添加 <a href="http://msdn.microsoft.com/zh-cn/library/b2s063f7(v=vs.110).aspx" target="_blank" rel="noopener">XML 文档注释</a>，并在注册 Swashbuckle 时将这些注释包含进 Swagger JSON:</p>
<ol>
<li><p>打开项目的“属性”选项，选择“生成”标签页并勾上“ XML 文档文件”。然后当你生成项目时可以它会自动生成一个包含所有 XML 注释的文件。</p>
<p> <em>此时如果某个类或方法没有使用 XML 注释，那么会产生一个生成警告。如果想要去掉这个警告,在此页的“禁止显示警告”选项中添加警告码“1591”即可。</em></p>
</li>
<li><p>在注册 Swashbuckle 时引用 XML 注释文件来生成 Swagger JSON:</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerDoc(<span class="string">"v1"</span>,</span><br><span class="line">        <span class="keyword">new</span> Info</span><br><span class="line">        &#123;</span><br><span class="line">            Title = <span class="string">"My API - V1"</span>,</span><br><span class="line">            Version = <span class="string">"v1"</span></span><br><span class="line">        &#125;</span><br><span class="line">     );</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> filePath = Path.Combine(PlatformServices.Default.Application.ApplicationBasePath, <span class="string">"MyApi.xml"</span>);</span><br><span class="line">     c.IncludeXmlComments(filePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法注释应当有 summary、 remarks 和 response 标签。</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Retrieves a specific product by unique id</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>Awesomeness!<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;response code="200"&gt;</span>Product created<span class="doctag">&lt;/response&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;response code="400"&gt;</span>Product has missing/invalid values<span class="doctag">&lt;/response&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;response code="500"&gt;</span>Oops! Can't create your product right now<span class="doctag">&lt;/response&gt;</span></span></span><br><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">[<span class="meta">ProducesResponseType(typeof(Product), 200)</span>]</span><br><span class="line">[<span class="meta">ProducesResponseType(typeof(IDictionary&lt;string, string&gt;), 400)</span>]</span><br><span class="line">[<span class="meta">ProducesResponseType(typeof(void), 500)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">GetById</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生成项目，XML 注释文件会被更新。你可以打开 Swagger JSON 页面看看这些注释是怎么映射进对应的 Swagger 文档的。</p>
</li>
</ol>
<p><em>注：你也可以通过给 model 以及它们的属性添加 summary 标签的方式生成 Swagger 文档。如果你有多个 XML 注释文件（例如控制器和 model 是独立的类库），你可以多次调用 IncludeXmlComments 方法，他们会被合并进输出的 Swagger JSON.</em></p>
<h3 id="提供全局-API-Metadata"><a href="#提供全局-API-Metadata" class="headerlink" title="提供全局 API Metadata"></a>提供全局 API Metadata</h3><p>除了 <em>Paths_， _Operations</em> 和 _Responses_，Swashbuckle 还提供了全局 metadata (详见 <a href="http://swagger.io/specification/#swaggerObject)。例如，你可以为你的" target="_blank" rel="noopener">http://swagger.io/specification/#swaggerObject)。例如，你可以为你的</a> API、服务项、甚至是联系方式和证书信息提供一个完整的描述：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c.SwaggerDoc(<span class="string">"v1"</span>,</span><br><span class="line">    <span class="keyword">new</span> Info</span><br><span class="line">    &#123;</span><br><span class="line">        Title = <span class="string">"My API - V1"</span>,</span><br><span class="line">        Version = <span class="string">"v1"</span>,</span><br><span class="line">        Description = <span class="string">"A sample API to demo Swashbuckle"</span>,</span><br><span class="line">        TermsOfService = <span class="string">"Knock yourself out"</span>,</span><br><span class="line">        Contact = <span class="keyword">new</span> Contact</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">"Joe Developer"</span>,</span><br><span class="line">            Email = <span class="string">"joe.developer@tempuri.org"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        License = <span class="keyword">new</span> License</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">"Apache 2.0"</span>,</span><br><span class="line">            Url = <span class="string">"http://www.apache.org/licenses/LICENSE-2.0.html"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><em>使用 IntelliSense 可以看到哪些字段是可用的。</em></p>
<p>未完待更。</p>
<!--
### 生成多个 Swagger 文档 ###

With the setup described above, the generator will include all API operations in a single Swagger document. However, you can create multiple documents if necessary. For example, you may want a separate document for each version of your API. To do this, start by defining multiple Swagger docs in _Startup.cs_:

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerDoc(<span class="string">"v1"</span>, <span class="keyword">new</span> Info &#123; Title = <span class="string">"My API - V1"</span>, Version = <span class="string">"v1"</span> &#125;);</span><br><span class="line">    c.SwaggerDoc(<span class="string">"v2"</span>, <span class="keyword">new</span> Info &#123; Title = <span class="string">"My API - V2"</span>, Version = <span class="string">"v2"</span> &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><em>Take note of the first argument to SwaggerDoc. It MUST be a URI-friendly name that uniquely identifies the document. It’s subsequently used to make up the path for requesting the corresponding Swagger JSON. For example, with the default routing, the above documents will be available at “/swagger/v1/swagger.json” and “/swagger/v2/swagger.json”.</em></p>
<p>Next, you’ll need to inform Swashbuckle which actions to include in each document. Although this can be customized (see below), by default, the generator will use the <em>ApiDescription.GroupName</em> property, part of the built-in metadata layer that ships with ASP.NET Core, to make this distinction. You can set this by decorating individual actions OR by applying an application wide convention.</p>
<h4 id="通过修饰符指定"><a href="#通过修饰符指定" class="headerlink" title="通过修饰符指定"></a>通过修饰符指定</h4><p>To include an action in a specific Swagger document, decorate it with the <em>ApiExplorerSettingsAttribute</em> and set <em>GroupName</em> to the corresponding document name (case sensitive):</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">ApiExplorerSettings(GroupName = <span class="meta-string">"v2"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">[FromBody]Product product</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-Convention-指定"><a href="#通过-Convention-指定" class="headerlink" title="通过 Convention 指定"></a>通过 Convention 指定</h4><p>To group by convention instead of decorating every action, you can apply a custom controller or action convention. For example, you could wire up the following convention to assign actions to documents based on the controller namespace.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApiExplorerGroupPerVersionConvention.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiExplorerGroupPerVersionConvention</span> : <span class="title">IControllerModelConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Apply</span>(<span class="params">ControllerModel controller</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> controllerNamespace = controller.ControllerType.Namespace; <span class="comment">// e.g. "Controllers.V1"</span></span><br><span class="line">        <span class="keyword">var</span> apiVersion = controllerNamespace.Split(<span class="string">'.'</span>).Last().ToLower();</span><br><span class="line"></span><br><span class="line">        controller.ApiExplorer.GroupName = apiVersion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddMvc(c =&gt;</span><br><span class="line">        c.Conventions.Add(<span class="keyword">new</span> ApiExplorerGroupPerVersionConvention())</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义选择方式"><a href="#自定义选择方式" class="headerlink" title="自定义选择方式"></a>自定义选择方式</h4><p>When selecting actions for a given Swagger document, the generator invokes a <em>DocInclusionPredicate</em> against every <em>ApiDescription</em> that’s surfaced by the framework. The default implementation inspects <em>ApiDescription.GroupName</em> and returns true if the value is either null OR equal to the requested document name. However, you can also provide a custom inclusion predicate. For example, if you’re using an attribute-based approach to implement API versioning (e.g. Microsoft.AspNetCore.Mvc.Versioning), you could configure a custom predicate that leverages this instead:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c.DocInclusionPredicate((docName, apiDesc) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> versions = apiDesc.ControllerAttributes()</span><br><span class="line">        .OfType&lt;ApiVersionAttribute&gt;()</span><br><span class="line">        .SelectMany(attr =&gt; attr.Versions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> versions.Any(v =&gt; <span class="string">$"v<span class="subst">&#123;v.ToString()&#125;</span>"</span> == docName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="通过-UI-显示多个文档"><a href="#通过-UI-显示多个文档" class="headerlink" title="通过 UI 显示多个文档"></a>通过 UI 显示多个文档</h4><p>If you’re using the <em>SwaggerUI</em> middleware, you’ll need to specify any additional Swagger endpoints you want to expose. See <a href="#list-multiple-swagger-documents">List Multiple Swagger Documents</a> for more.</p>
<h3 id="忽略废弃操作和-或-Schema-属性"><a href="#忽略废弃操作和-或-Schema-属性" class="headerlink" title="忽略废弃操作和/或 Schema 属性"></a>忽略废弃操作和/或 Schema 属性</h3><p>The <a href="http://swagger.io/specification/">Swagger spec</a> includes a “deprecated” flag for indicating that an operation is deprecated and should be refrained from use. The Swagger generator will automatically set this flag if the corresponding action is decorated with the <em>ObsoleteAttribute</em>. However, instead of setting a flag, you can configure the generator to ignore obsolete actions altogether:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.IgnoreObsoleteActions();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A similar approach can also be used to omit obsolete properties from Schema’s in the Swagger output. That is, you can decorate model properties with the <em>ObsoleteAttribute</em> and configure Swashbuckle to omit those properties when generating JSON Schemas:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.IgnoreObsoleteProperties();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="忽略某一方法"><a href="#忽略某一方法" class="headerlink" title="忽略某一方法"></a>忽略某一方法</h3><p>You can omit operations from the Swagger output by decorating individual actions OR by applying an application wide convention.</p>
<h4 id="通过修饰符指定-1"><a href="#通过修饰符指定-1" class="headerlink" title="通过修饰符指定"></a>通过修饰符指定</h4><p>To omit a specific action, decorate it with the <em>ApiExplorerSettingsAttribute</em> and set the <em>IgnoreApi</em> flag:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">[<span class="meta">ApiExplorerSettings(IgnoreApi = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">GetById</span>(<span class="params"><span class="keyword">int</span> id</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-Convention-指定-1"><a href="#通过-Convention-指定-1" class="headerlink" title="通过 Convention 指定"></a>通过 Convention 指定</h4><p>To omit actions by convention instead of decorating them individually, you can apply a custom action convention. For example, you could wire up the following convention to only document GET operations:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApiExplorerGetsOnlyConvention.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiExplorerGetsOnlyConvention</span> : <span class="title">IActionModelConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Apply</span>(<span class="params">ActionModel action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        action.ApiExplorer.IsVisible = action.Attributes.OfType&lt;HttpGetAttribute&gt;().Any();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddMvc(c =&gt;</span><br><span class="line">        c.Conventions.Add(<span class="keyword">new</span> ApiExplorerGetsOnlyConvention())</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义方法标签（当-UI-需要以此分组时）"><a href="#自定义方法标签（当-UI-需要以此分组时）" class="headerlink" title="自定义方法标签（当 UI 需要以此分组时）"></a>自定义方法标签（当 UI 需要以此分组时）</h3><p>The <a href="http://swagger.io/specification/">Swagger spec</a> allows one or more “tags” to be assigned to an operation. The Swagger generator will assign the controller name as the default tag. This is particularly interesting if you’re using the <em>SwaggerUI</em> middleware as it uses this value to group operations.</p>
<p>You can override the default tag by providing a function that applies tags by convention. For example, the following configuration will tag, and therefore group operations in the UI, by HTTP method:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.TagActionsBy(api =&gt; api.HttpMethod);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="改变方法顺序-当-UI-需要以此排序时"><a href="#改变方法顺序-当-UI-需要以此排序时" class="headerlink" title="改变方法顺序 (当 UI 需要以此排序时)"></a>改变方法顺序 (当 UI 需要以此排序时)</h3><p>By default, actions are ordered by assigned tag (see above) before they’re grouped into the path-based, hierarchichal structure imposed by the <a href="http://swagger.io/specification">Swagger spec</a>. You can change this behavior with a custom sorting strategy:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.OrderActionsBy((apiDesc) =&gt; <span class="string">$"<span class="subst">&#123;apiDesc.ControllerName()&#125;</span>_<span class="subst">&#123;apiDesc.HttpMethod&#125;</span>"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>NOTE: This dictates the sort order BEFORE actions are grouped and transformed into the Swagger format. So, it affects the ordering of groups (i.e. Swagger PathItems), AND the ordering of operations within a group, in the Swagger output.</em></p>
<h3 id="自定义-Schema-Id’s"><a href="#自定义-Schema-Id’s" class="headerlink" title="自定义 Schema Id’s"></a>自定义 Schema Id’s</h3><p>If the generator encounters complex parameter or response types, it will generate a corresponding JSON Schema, add it to the global “definitions” dictionary, and reference it from the operation description by unique Id. For example, if you have an action that returns a “Product” type, the generated schema will be referenced as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">responses: &#123;</span><br><span class="line">  200: &#123;</span><br><span class="line">    description: &quot;Success&quot;,</span><br><span class="line">    schema: &#123;</span><br><span class="line">      $ref: &quot;#/definitions/Product&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, if it encounters multiple “Product” classes under different namespaces (e.g. “RequestModels.Product” &amp; “ResponseModels.Product”), then Swashbuckle will raise an exception due to “Conflicting schemaIds”. In this case, you’ll need to provide a custom Id strategy that further qualifies the name:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.CustomSchemaIds((type) =&gt; type.FullName);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="自定义枚举类型-Schema"><a href="#自定义枚举类型-Schema" class="headerlink" title="自定义枚举类型 Schema"></a>自定义枚举类型 Schema</h3><p>When describing parameters and responses, Swashbuckle does its best to reflect the application’s serialization settings. For example, if the <em>CamelCaseContractResolver</em> is enabled, Schema property names will be camelCased in the generated Swagger.</p>
<p>Similarly for enum types, if the <em>StringEnumConverter</em> is enabled, then the corresponding Schema’s will list enum names rather than integer values.</p>
<p>For most cases this should be sufficient. However, if you need more control, Swashbuckle exposes the following options to override the default behavior:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.DescribeAllEnumsAsStrings();</span><br><span class="line">    c.DescribeStringEnumsInCamelCase();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="为指定类型重写-Schema"><a href="#为指定类型重写-Schema" class="headerlink" title="为指定类型重写 Schema"></a>为指定类型重写 Schema</h3><p>Out-of-the-box, Swashbuckle does a decent job at generating JSON Schema’s that accurately describe your request and response payloads. However, if you’re customizing serialization behavior for certain types in your API, you may need to help it out.</p>
<p>For example, you might have a class with muliple properties that you want to represent in JSON as a comma-separated string. To do this you would probably implement a custom <em>JsonConverter</em>. In this case, Swashbuckle doesn’t know how the converter is implemented and so you would need to provide it with a Schema that accurately describes the type:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PhoneNumber.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhoneNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> CountryCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> AreaCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> SubscriberId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.MapType&lt;PhoneNumber&gt;(() =&gt; <span class="keyword">new</span> Schema &#123; Type = <span class="string">"string"</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Extend-Generator-with-Operation-Schema-amp-Document-Filters"><a href="#Extend-Generator-with-Operation-Schema-amp-Document-Filters" class="headerlink" title="Extend Generator with Operation, Schema &amp; Document Filters"></a>Extend Generator with Operation, Schema &amp; Document Filters</h3><p>Swashbuckle exposes a filter pipeline that hooks into the generation process. Once generated, individual metadata objects are passed into the pipeline where they can be modified further. You can wire up one or more custom filters for <em>Operation</em>, <em>Schema</em> and <em>Document</em> objects:</p>
<h4 id="Operation-Filters"><a href="#Operation-Filters" class="headerlink" title="Operation Filters"></a>Operation Filters</h4><p>Swashbuckle retrieves an <em>ApiDescription</em>, part of ASP.NET Core, for every action and uses it to generate a corresponding <em>Swagger Operation</em>. Once generated, it passes the <em>Operation</em> and the <em>ApiDescription</em> through the list of configured Operation Filters.</p>
<p>In a typical filter implementation, you inspect the <em>ApiDescription</em> for relevant information (e.g. route info, action attributes etc.) and then update the Swagger <em>Operation</em> accordingly. For example, the following filter lists an additional “401” response for all actions that are decorated with the <em>AuthorizeAttribute</em>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AuthResponsesOperationFilter.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthResponsesOperationFilter</span> : <span class="title">IOperationFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Apply</span>(<span class="params">Operation operation, OperationFilterContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> authAttributes = context.ApiDescription</span><br><span class="line">            .ControllerAttributes()</span><br><span class="line">            .Union(context.ApiDescription.ActionAttributes())</span><br><span class="line">            .OfType&lt;AuthorizeAttribute&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (authAttributes.Any())</span><br><span class="line">            operation.Responses.Add(<span class="string">"401"</span>, <span class="keyword">new</span> Response &#123; Description = <span class="string">"Unauthorized"</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.OperationFilter&lt;AuthResponsesOperationFilter&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>NOTE: Filter pipelines are DI-aware. That is, you can create filters with constructor parameters and if the parameter types are registered with the DI framework, they’ll be automatically injected when the filters are instantiated</em></p>
<h4 id="Schema-Filters"><a href="#Schema-Filters" class="headerlink" title="Schema Filters"></a>Schema Filters</h4><p>Swashbuckle generates a Swagger-flavored <em><a href="http://swagger.io/specification/#schemaObject">JSONSchema</a></em> for every parameter, response and property type that’s exposed by your controller actions. Once generated, it passes the <em>Schema</em> and <em>Type</em> through the list of configured Schema Filters.</p>
<p>The example below adds an AutoRest vendor extension (see <a href="https://github.com/Azure/autorest/blob/master/docs/extensions/readme.md#x-ms-enum">https://github.com/Azure/autorest/blob/master/docs/extensions/readme.md#x-ms-enum</a>) to inform the AutoRest tool how enums should be modelled when it generates the API client.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoRestSchemaFilter.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoRestSchemaFilter</span> : <span class="title">ISchemaFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Apply</span>(<span class="params">Schema schema, SchemaFilterContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> typeInfo = context.SystemType.GetTypeInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (typeInfo.IsEnum)</span><br><span class="line">        &#123;</span><br><span class="line">            schema.Extensions.Add(</span><br><span class="line">                <span class="string">"x-ms-enum"</span>,</span><br><span class="line">                <span class="keyword">new</span> &#123; name = typeInfo.Name,  modelAsString = <span class="literal">true</span> &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.SchemaFilter&lt;AutoRestSchemaFilter&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Document-Filters"><a href="#Document-Filters" class="headerlink" title="Document Filters"></a>Document Filters</h4><p>Once a <em>Swagger Document</em> has been generated, it too can be passed through a set of pre-configured <em>Document</em> Filters. This gives full control to modify the document however you see fit. To ensure you’re still returning valid Swagger JSON, you should have a read through the <a href="http://swagger.io/specification/">specification</a> before using this filter type.</p>
<p>The example below provides a description for any tags that are assigned to operations in the document:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TagDescriptionsDocumentFilter</span> : <span class="title">IDocumentFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Apply</span>(<span class="params">SwaggerDocument swaggerDoc, DocumentFilterContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        swaggerDoc.Tags = <span class="keyword">new</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Tag &#123; Name = <span class="string">"Products"</span>, Description = <span class="string">"Browse/manage the product catalog"</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Tag &#123; Name = <span class="string">"Orders"</span>, Description = <span class="string">"Submit orders"</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>NOTE: If you’re using the SwaggerUI middleware, this filter can be used to display additional descriptions beside each group of Operations.</em></p>
<h3 id="Add-Security-Definitions-and-Requirements"><a href="#Add-Security-Definitions-and-Requirements" class="headerlink" title="Add Security Definitions and Requirements"></a>Add Security Definitions and Requirements</h3><p>In Swagger, you can describe how your API is secured by defining one or more <em>Security Scheme’s</em> (e.g basic, api key, oauth etc.) and declaring which of those schemes are applicable globally OR for specific operations. For more details, take a look at the “securityDefinitions” and “security” fields in the <a href="http://swagger.io/specification/#swaggerObject">Swagger spec</a>.</p>
<p>You can use some of the options described above to include security metadata in the generated <em>Swagger Document</em>. The example below adds an <a href="https://oauth.net/2/">OAuth 2.0</a> definition to the global metadata and a corresponding <em>Operation Filter</em> that uses the presence of an <em>AuthorizeAttribute</em> to determine which operations the scheme applies to.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Define the OAuth2.0 scheme that's in use (i.e. Implicit Flow)</span></span><br><span class="line">    c.AddSecurityDefinition(<span class="string">"oauth2"</span>, <span class="keyword">new</span> OAuth2Scheme</span><br><span class="line">    &#123;</span><br><span class="line">        Type = <span class="string">"oauth2"</span>,</span><br><span class="line">        Flow = <span class="string">"implicit"</span>,</span><br><span class="line">        AuthorizationUrl = <span class="string">"http://petstore.swagger.io/oauth/dialog"</span></span><br><span class="line">        Scopes = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; <span class="string">"readAccess"</span>, <span class="string">"Access read operations"</span> &#125;,</span><br><span class="line">            &#123; <span class="string">"writeAccess"</span>, <span class="string">"Access write operations"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Assign scope requirements to operations based on AuthorizeAttribute</span></span><br><span class="line">    c.OperationFilter&lt;SecurityRequirementsOperationFilter&gt;();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SecurityRequirementsOperationFilter.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SecurityRequirementsOperationFilter</span> : <span class="title">IOperationFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Apply</span>(<span class="params">Operation operation, OperationFilterContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Policy names map to scopes</span></span><br><span class="line">        <span class="keyword">var</span> controllerScopes = context.ApiDescription.ControllerAttributes()</span><br><span class="line">            .OfType&lt;AuthorizeAttribute&gt;()</span><br><span class="line">            .Select(attr =&gt; attr.Policy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> actionScopes = context.ApiDescription.ActionAttributes()</span><br><span class="line">            .OfType&lt;AuthorizeAttribute&gt;()</span><br><span class="line">            .Select(attr =&gt; attr.Policy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> requiredScopes = controllerScopes.Union(actionScopes).Distinct();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requiredScopes.Any())</span><br><span class="line">        &#123;</span><br><span class="line">            operation.Responses.Add(<span class="string">"401"</span>, <span class="keyword">new</span> Response &#123; Description = <span class="string">"Unauthorized"</span> &#125;);</span><br><span class="line">            operation.Responses.Add(<span class="string">"403"</span>, <span class="keyword">new</span> Response &#123; Description = <span class="string">"Forbidden"</span> &#125;);</span><br><span class="line"></span><br><span class="line">            operation.Security = <span class="keyword">new</span> List&lt;IDictionary&lt;<span class="keyword">string</span>, IEnumerable&lt;<span class="keyword">string</span>&gt;&gt;&gt;();</span><br><span class="line">            operation.Security.Add(<span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, IEnumerable&lt;<span class="keyword">string</span>&gt;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                &#123; <span class="string">"oauth2"</span>, requiredScopes &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>NOTE: If you’re using the SwaggerUI middleware, you can enable interactive OAuth2.0 flows that are powered by the emitted security metadata. See <a href="#">Enabling OAuth2.0 Flows</a> for more details.</em></p>
<h2 id="Swashbuckle-AspNetCore-SwaggerUI"><a href="#Swashbuckle-AspNetCore-SwaggerUI" class="headerlink" title="Swashbuckle.AspNetCore.SwaggerUI"></a>Swashbuckle.AspNetCore.SwaggerUI</h2><h3 id="Change-Relative-Path-to-the-UI"><a href="#Change-Relative-Path-to-the-UI" class="headerlink" title="Change Relative Path to the UI"></a>Change Relative Path to the UI</h3><p>By default, the Swagger UI will be exposed at “/swagger”. If neccessary, you can alter this when enabling the SwaggerUI middleware:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.RoutePrefix = <span class="string">"api-docs"</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List-Multiple-Swagger-Documents"><a href="#List-Multiple-Swagger-Documents" class="headerlink" title="List Multiple Swagger Documents"></a>List Multiple Swagger Documents</h3><p>When enabling the middleware, you’re required to specify one or more Swagger endpoints (fully qualified or relative to the current host) to power the UI. If you provide multiple endpoints, they’ll be listed in the top right corner of the page, allowing users to toggle between the different documents. For example, the following configuration could be used to document different versions of an API.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">"/swagger/v1/swagger.json"</span>, <span class="string">"V1 Docs"</span>);</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">"/swagger/v2/swagger.json"</span>, <span class="string">"V2 Docs"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Apply-swagger-ui-Parameters"><a href="#Apply-swagger-ui-Parameters" class="headerlink" title="Apply swagger-ui Parameters"></a>Apply swagger-ui Parameters</h3><p>The swagger-ui ships with it’s own set of configuration parameters, all described here <a href="https://github.com/swagger-api/swagger-ui#swaggerui">https://github.com/swagger-api/swagger-ui#swaggerui</a>. In Swashbuckle, most of these are surfaced through the SwaggerUI middleware options:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.EnabledValidator();</span><br><span class="line">    c.BooleanValues(<span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">0</span>, <span class="number">1</span> &#125;);</span><br><span class="line">    c.DocExpansion(<span class="string">"full"</span>);</span><br><span class="line">    c.InjectOnCompleteJavaScript(<span class="string">"/swagger-ui/on-complete.js"</span>);</span><br><span class="line">    c.InjectOnFailureJavaScript(<span class="string">"/swagger-ui/on-failure.js"</span>);</span><br><span class="line">    c.SupportedSubmitMethods(<span class="keyword">new</span>[] &#123; <span class="string">"get"</span>, <span class="string">"post"</span>, <span class="string">"put"</span>, <span class="string">"patch"</span> &#125;);</span><br><span class="line">    c.ShowRequestHeaders();</span><br><span class="line">    c.ShowJsonEditor();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Most of them are self explanatory, mapping back to the corresponding swagger-ui docs. To inject custom JavaScript (i.e. <em>InjectOnCompleteJavaScript</em> and <em>InjectOnFailureJavaScript</em>), you’ll need to add the scripts to your application and provide the relative paths as shown above. In ASP.NET Core, this is easily done by placing your script files in the <em>wwwroot</em> folder.</p>
<h3 id="Inject-Custom-CSS"><a href="#Inject-Custom-CSS" class="headerlink" title="Inject Custom CSS"></a>Inject Custom CSS</h3><p>To tweak the look and feel, you can inject additional CSS stylesheets by adding them to your <em>wwwroot</em> folder and specifying the relative paths in the middleware options:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    c.InjectStylesheet(<span class="string">"/swagger-ui/custom.css"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Enable-OAuth2-0-Flows"><a href="#Enable-OAuth2-0-Flows" class="headerlink" title="Enable OAuth2.0 Flows"></a>Enable OAuth2.0 Flows</h3><p>The swagger-ui has built-in support to participate in OAuth2.0 authorization flows. It interacts with authorization and/or token endpoints, as specified in the Swagger JSON, to obtain access tokens for subsequent API calls. See <a href="#add-security-definitions-and-requirements">Adding Security Definitions and Requirements</a> for an example of adding OAuth2.0 metadata to the generated Swagger.</p>
<p>If you’re Swagger endpoint includes the appropriate security metadata, you can enable the UI interaction as follows:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Provide client ID, client ID, realm and application name</span></span><br><span class="line">    c.ConfigureOAuth2(<span class="string">"swagger-ui"</span>, <span class="string">"swagger-ui-secret"</span>, <span class="string">"swagger-ui-realm"</span>, <span class="string">"Swagger UI"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>–&gt;</p>
-->]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> swagger </tag>
            
            <tag> 生成文档 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth 2.0 认证框架（一）]]></title>
      <url>https://HaleLu.github.io/2017/02/OAuth-1/</url>
      <content type="html"><![CDATA[<p>最近需要搭一个第三方验证的服务器。这个想法之前就有，但是当时水平粗浅，也只能看个一知半解，没有理解透彻。趁这个机会好好学一学 OAuth 2.0 认证框架。</p>
<a id="more"></a>

<h2 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h2><h3 id="什么是-OAuth-2-0"><a href="#什么是-OAuth-2-0" class="headerlink" title="什么是 OAuth 2.0"></a>什么是 OAuth 2.0</h3><p>OAuth 是一套第三方认证框架，即认证服务器和资源服务器分开，用户向认证服务器授权，资源服务器才有权使用认证服务器认证用户身份，认证通过后用户才有权使用资源服务器中的权限资源。2.0 是目前的版本号。<br>以下的 OAuth 代指 OAuth 2.0 框架。<br>目前微信、QQ、新浪微博、人人网等众多网站都支持这样的第三方登录，基本都是使用的 OAuth 框架。其中 Github 的较为标准。所以我们可以以此为例。</p>
<h3 id="为什么要用第三方登录"><a href="#为什么要用第三方登录" class="headerlink" title="为什么要用第三方登录"></a>为什么要用第三方登录</h3><p>对于小型应用而言，希望降低使用者的门槛，无需经过复杂的注册；另一方面可以直接使用腾讯、新浪等大网站的客户资源；性能和成本上讲也省掉了自己维护大量用户数据的烦恼。<br>对于大型网站而言，方便自己解耦，可以更方便地扩展新的应用；也可以吸引用户粘性，让用户更多的应用关联自己的用户资源；同时这种关联信息也是日后数据挖掘的一项原料。<br>当然，上面的这些其实都是我瞎猜的。</p>
<p>自己的项目之所以要将授权服务器拆开纯粹是为了解耦，可以多应用使用相同的用户资源而不会建立多余数据库连接。</p>
<h2 id="OAuth-基本定义"><a href="#OAuth-基本定义" class="headerlink" title="OAuth 基本定义"></a>OAuth 基本定义</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>OAuth 框架定义了四种角色：</p>
<ul>
<li>资源拥有者（Resource Owner）<ul>
<li>指权限资源的拥有者，当拥有者是一个人的时候，我们称为用户。（权限资源指需要经过验证，确认具有权限的主体才能获取的资源）</li>
</ul>
</li>
<li>资源服务器（Resource Server）<ul>
<li>管理权限资源，接受和响应使用令牌（token）的请求。</li>
</ul>
</li>
<li>客户端（Client）<ul>
<li>经过资源拥有者授权的、代表其发送权限资源请求的应用。（客户端可以泡在服务器、用户电脑或是其它任何设备上）</li>
</ul>
</li>
<li>授权服务器（Authorization Server）<ul>
<li>在验证资源拥有者身份和获得授权后向客户端分配令牌（token）。</li>
</ul>
</li>
</ul>
<h3 id="协议流"><a href="#协议流" class="headerlink" title="协议流"></a>协议流</h3><pre><code>+--------+                               +---------------+
|        |--(A)- Authorization Request -&gt;|   Resource    |
|        |                               |     Owner     |
|        |&lt;-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant --&gt;| Authorization |
| Client |                               |     Server    |
|        |&lt;-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------&gt;|    Resource   |
|        |                               |     Server    |
|        |&lt;-(F)--- Protected Resource ---|               |
+--------+                               +---------------+</code></pre><h4 id="A-Authorization-Request"><a href="#A-Authorization-Request" class="headerlink" title="(A) Authorization Request"></a>(A) Authorization Request</h4><p>客户端需要资源拥有者授权。授权请求可以直接对资源拥有者请求，或者更好的做法是通过授权服务器作为媒介。</p>
<h4 id="B-Authorization-Grant"><a href="#B-Authorization-Grant" class="headerlink" title="(B) Authorization Grant"></a>(B) Authorization Grant</h4><p>客户端收到来自资源拥有者的授权许可。许可的格式通常使用以下定义的四种授权模式的一种（当然你也可以自行定义授权模式）。具体使用何种模式取决于客户端使用了哪种且授权服务器是否支持。</p>
<h4 id="C-Authorization-Grant"><a href="#C-Authorization-Grant" class="headerlink" title="(C) Authorization Grant"></a>(C) Authorization Grant</h4><p>客户端向授权服务器请求一个令牌（token）表示授权许可。</p>
<h4 id="D-Access-Token"><a href="#D-Access-Token" class="headerlink" title="(D) Access Token"></a>(D) Access Token</h4><p>授权服务器验证客户端并确认授权许可。如果授权许可通过，那么分配给客户端一个 token。</p>
<h4 id="E-Access-Token"><a href="#E-Access-Token" class="headerlink" title="(E) Access Token"></a>(E) Access Token</h4><p>客户端通过 token 验证身份并从资源服务器请求资源。</p>
<h4 id="F-Protected-Resource"><a href="#F-Protected-Resource" class="headerlink" title="(F) Protected Resource"></a>(F) Protected Resource</h4><p>资源服务器验证 token 有效性后处理请求。</p>
<h3 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h3><p>有四种常见的授权模式：</p>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>这种授权模式将授权服务器作为客户端和资源拥有者的中间媒介。用户不向客户端直接授权，而是将用户指引到授权服务器，然后将得到授权码的用户定向回客户端（原文 1.3.1 中提到通过 user-agent 的方式引导，我没有太懂是什么意思，欢迎看懂的小伙伴给我解答一下）</p>
<h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><p>简化模式是为使用脚本语言（例如 JavaScript）的客户端优化设计的一种授权模式。简化模式中不分配授权码，而是直接分配 token（作为资源拥有者的身份验证结果）。因为没有中间验证信息（例如授权码），所以这种授权模式称为简化模式。<br>在简化模式中，授权服务器并不验证客户端就直接分配了 token。在一些情况下，客户端身份可以通过重定向到返回 token 的 URI 来验证客户端。这个 token 可能会被暴露给用户或者其他用户 UA 层面的应用。<br>简化模式对于一些比如浏览器客户端可以提高效率，当然也会导致一些安全上的问题。</p>
<p>第一点是可能 token 被抓，所以<strong>必须</strong>使用 TLS（即使用 HTTPS）。<br>第二点是可能存在“点击挟持”（clickjacking），即使用隐形的不可见的 button 覆盖在授权页面上，让用户在不知情情况下误授权。所以本地应用<strong>应当</strong>使用外部浏览器而不是应用内的嵌入浏览器。</p>
<h4 id="密码验证模式"><a href="#密码验证模式" class="headerlink" title="密码验证模式"></a>密码验证模式</h4><p>密码模式即直接使用账号密码（或其他验证信息）登录。只<strong>应当</strong>用于用户对客户端高度信任（例如是设备操作系统的一部分）且其他授权模式都不可用的情况。<br>即使使用这种模式，客户端也不应当存储账号密码，而是每次都使用验证信息去交换 token。</p>
<h4 id="客户端证书模式"><a href="#客户端证书模式" class="headerlink" title="客户端证书模式"></a>客户端证书模式</h4><p>将客户端证书（或其他形式的客户端凭证）看做授权凭证。在已经授权的资源范围内，客户端可以被看做用户本人，拥有获取权限资源的权限。</p>
<h3 id="授权令牌（token）"><a href="#授权令牌（token）" class="headerlink" title="授权令牌（token）"></a>授权令牌（token）</h3><p>简单来说，token 就是表示授权的一个临时证明，通常是一个字符串。这个字符串通常对客户端是不透明（opaque）的（根据我的理解，应该指的是看不见）。用户授权后，资源服务器和授权服务器才可以通过 token 来验证对某一指定域的权限。当超越已授权的权限时，可能需要提供额外的验证信息来获得权限。<br>token 本身就已经足够表明授权者身份。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">The OAuth 2.0 Authorization Framework - Internet Engineering Task Force (IETF)</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 身份验证 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公钥基础设施（四）：证书签发（以OpenSSL为例）]]></title>
      <url>https://HaleLu.github.io/2017/02/Public-Key-Infrastructure-4/</url>
      <content type="html"><![CDATA[<p>这篇是以OpenSSL为例如何生成证书、自签名以及签发客户证书。</p>
<a id="more"></a>

<p>需事先安装OpenSSL。</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前几篇我们已经讲过，证书相当于是权威机构对个人公钥的认证，而个人持有对应的私钥并保密。那么我们如何创建证书呢？</p>
<h2 id="搭建根CA"><a href="#搭建根CA" class="headerlink" title="搭建根CA"></a>搭建根CA</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先建目录：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootCA</span><br><span class="line"><span class="built_in">cd</span> rootCA</span><br><span class="line"><span class="built_in">mkdir</span> newcerts private conf requests</span><br></pre></td></tr></table></figure>

<p>再创建序号和记录文件</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch index.txt</span><br><span class="line"><span class="built_in">echo</span> unique_subject = yes &gt; index.txt.attr</span><br><span class="line"><span class="built_in">echo</span> <span class="number">01</span> &gt; serial</span><br></pre></td></tr></table></figure>

<h3 id="创建私钥"><a href="#创建私钥" class="headerlink" title="创建私钥"></a>创建私钥</h3><p>首先我们需要生成一个私钥：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/ca.key <span class="number">2048</span></span><br></pre></td></tr></table></figure>

<p>这样生成的私钥是不加密的，当然我们也可以选择一种加密方式（可选的加密方式可以使用 <code>openssl help</code> 查询）<br>以des3为例，我们生成私钥的命令：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out private/ca.key <span class="number">2048</span></span><br></pre></td></tr></table></figure>

<p>输入一个不少于4位的密码即可。</p>
<p><em>注：这样加密的意义是一旦私钥被复制可以不让攻击者直接就能使用私钥，然而只能拖延不能完全防止。原则上私钥被复制需要更换私钥。</em></p>
<h3 id="创建自签名证书"><a href="#创建自签名证书" class="headerlink" title="创建自签名证书"></a>创建自签名证书</h3><p>所谓请求就是将自己的信息和自己需要被签名的公钥打包成的一个文件。这个请求会被提交给CA确认。确认无误后CA会用自己的私钥签名。  </p>
<p>接下来我们需要生成一个请求，我们有两种可选方式：</p>
<h4 id="直接生成证书（方式一）"><a href="#直接生成证书（方式一）" class="headerlink" title="直接生成证书（方式一）"></a>直接生成证书（方式一）</h4><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -key private/ca.key -out ca.crt</span><br></pre></td></tr></table></figure>

<p>接下来按照指引填入相关信息。<br>这样就生成了一张自签名证书。<br>其中 <code>-x509</code> 表示生成x509格式的自签名证书。（待会我们生成请求时会使用 <code>-new</code> 而不是 <code>-x509</code> ）<br>另外，我们可以通过 <code>-day</code> 参数指定过期时间, <code>-set_serial</code> 参数设置特定序列号。<br>具体可以使用 <code>openssl req -help</code> 命令查看详细。 </p>
<h4 id="通过配置文件生成请求（方式二）"><a href="#通过配置文件生成请求（方式二）" class="headerlink" title="通过配置文件生成请求（方式二）"></a>通过配置文件生成请求（方式二）</h4><p>至于配置文件的详细解释可以查阅<a href="https://www.openssl.org/docs/man1.1.0/apps/config.html" target="_blank" rel="noopener">官方文档</a>。</p>
<p>以下只给一个样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">[ default ]</span><br><span class="line">name		= rootCA</span><br><span class="line">dir		= .</span><br><span class="line"></span><br><span class="line">base_url	= http://your.website.com</span><br><span class="line">crl_url		= $base_url/crls/$name.crl</span><br><span class="line"></span><br><span class="line">[ ca ]</span><br><span class="line">default_ca	= CA_root</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">[ CA_root ]</span><br><span class="line">new_certs_dir	= $dir/newcerts		# default place for new certs.</span><br><span class="line"></span><br><span class="line">private_key	= $dir/private/ca.key	# The private key</span><br><span class="line">certificate	= $dir/ca.crt		# The CA certificate</span><br><span class="line"></span><br><span class="line">database	= $dir/index.txt	# database index file.</span><br><span class="line">serial		= $dir/serial		# The current serial number</span><br><span class="line">crlnumber	= $dir/crlserial	# the current crl number</span><br><span class="line">RANDFILE	= $dir/private/.rand	# private random number file</span><br><span class="line"></span><br><span class="line">preserve	= no</span><br><span class="line">name_opt	= ca_default</span><br><span class="line">cert_opt	= ca_default</span><br><span class="line"></span><br><span class="line">default_startdate	= 170101000000Z</span><br><span class="line">default_enddate		= 200201000000Z</span><br><span class="line">default_crl_days	= 30</span><br><span class="line">default_md		= default</span><br><span class="line"></span><br><span class="line">x509_extensions	= v3_intermediate_ca</span><br><span class="line"></span><br><span class="line">policy		= policy_root</span><br><span class="line"></span><br><span class="line">[ policy_root ]</span><br><span class="line">countryName		= supplied</span><br><span class="line">stateOrProvinceName	= optional</span><br><span class="line">organizationName	= match</span><br><span class="line">organizationalUnitName	= supplied</span><br><span class="line">commonName		= supplied</span><br><span class="line">emailAddress		= optional</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">[ req ]</span><br><span class="line">default_bits		= 2048</span><br><span class="line">default_keyfile		= $dir/private/ca.key</span><br><span class="line">distinguished_name	= req_distinguished_root</span><br><span class="line">x509_extensions		= v3_ca</span><br><span class="line">string_mask		= utf8only</span><br><span class="line"></span><br><span class="line">[ req_distinguished_root ]</span><br><span class="line">countryName			= Country Name (2 letter code)</span><br><span class="line">countryName_min			= 2</span><br><span class="line">countryName_max			= 2</span><br><span class="line"></span><br><span class="line">stateOrProvinceName		= State or Province Name (full name)</span><br><span class="line"></span><br><span class="line">localityName			= Locality Name (eg, city)</span><br><span class="line"></span><br><span class="line">organizationName		= Organization Name (eg, company)</span><br><span class="line"></span><br><span class="line">organizationalUnitName		= Organizational Unit Name (eg, section)</span><br><span class="line"></span><br><span class="line">commonName			= Common Name (e.g. server FQDN or YOUR name)</span><br><span class="line">commonName_max			= 64</span><br><span class="line"></span><br><span class="line">countryName_default		= CN</span><br><span class="line">stateOrProvinceName_default	= Your Province</span><br><span class="line">organizationName_default	= Your Company Name</span><br><span class="line">organizationalUnitName_default	= Secure Digital Certificate Signing</span><br><span class="line">commonName_default		= The Root CA of Your Private Certifications</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">[ v3_ca ]</span><br><span class="line">subjectKeyIdentifier	= hash</span><br><span class="line">basicConstraints	= critical,CA:true</span><br><span class="line">keyUsage = critical, cRLSign, keyCertSign</span><br><span class="line"></span><br><span class="line">[ v3_intermediate_ca ]</span><br><span class="line">subjectKeyIdentifier	= hash</span><br><span class="line">authorityKeyIdentifier	= keyid:always</span><br><span class="line">basicConstraints	= critical,CA:true</span><br><span class="line">keyUsage = critical, cRLSign, keyCertSign</span><br><span class="line">crlDistributionPoints	= @crl_info</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">[ crl_ext ]</span><br><span class="line">authorityKeyIdentifier = keyid:always</span><br><span class="line"></span><br><span class="line">[ crl_info ]</span><br><span class="line">URI.0 = $crl_url</span><br></pre></td></tr></table></figure>

<p>保存为 <code>conf/default.cnf</code> 。</p>
<p>接下来在生成请求时带上配置文件即可。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -key private/ca.key -out ca.crt -config conf/default.cnf</span><br></pre></td></tr></table></figure>

<p><em>注：此处如果不带 <code>-key private/ca.key</code> 参数，OpenSSL会在对应目录下创建一个新的private/ca.key文件。也就是说，你也可以选择跳过第一步直接使用配置文件的方式一条命令生成私钥及请求。</em></p>
<p>现在我们已经有了一个根证书ca.crt，从某种程度上，我们现在已经搭建出了一个根CA。</p>
<h2 id="搭建二级CA"><a href="#搭建二级CA" class="headerlink" title="搭建二级CA"></a>搭建二级CA</h2><p>通常情况下，一级CA（即根CA）不直接签发服务器证书，而是签发二级CA。由二级CA签发服务器证书。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>同搭建根CA：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">mkdir</span> secondCA</span><br><span class="line"><span class="built_in">cd</span> secondCA</span><br><span class="line"><span class="built_in">mkdir</span> newcerts private conf requests</span><br><span class="line">touch index.txt</span><br><span class="line"><span class="built_in">echo</span> unique_subject = yes &gt; index.txt.attr</span><br><span class="line"><span class="built_in">echo</span> <span class="number">01</span> &gt; serial</span><br></pre></td></tr></table></figure>

<h3 id="创建私钥-1"><a href="#创建私钥-1" class="headerlink" title="创建私钥"></a>创建私钥</h3><p>同搭建根CA：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/ca.key <span class="number">2048</span></span><br></pre></td></tr></table></figure>

<h3 id="创建证书请求"><a href="#创建证书请求" class="headerlink" title="创建证书请求"></a>创建证书请求</h3><p>除 <code>-x509</code> 被换成 <code>-new</code> 以外其他基本一致。<br>我们以方式二（使用配置文件）为例。<br>首先写一个配置文件。（和前一个类似，不再举例）<br>然后：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key private/ca.key -out ../rootCA/requests/secondCA.csr -config conf/default.cnf</span><br></pre></td></tr></table></figure>

<h3 id="签发二级CA证书"><a href="#签发二级CA证书" class="headerlink" title="签发二级CA证书"></a>签发二级CA证书</h3><p>这一步我们需要使用根CA的身份，用根CA的私钥签发二级CA的证书</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../rootCA</span><br><span class="line">openssl ca -<span class="keyword">in</span> requests/secondCA.csr -out ../secondCA/ca.crt -config conf/default.cnf</span><br></pre></td></tr></table></figure>

<p>确认后，证书签发完成。</p>
<p>至此，二级CA搭建完成</p>
<h2 id="签发服务器证书"><a href="#签发服务器证书" class="headerlink" title="签发服务器证书"></a>签发服务器证书</h2><p>类似二级CA：</p>
<h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">mkdir</span> serverCA</span><br><span class="line"><span class="built_in">cd</span> serverCA</span><br><span class="line"><span class="built_in">mkdir</span> newcerts private conf</span><br><span class="line">touch index.txt</span><br><span class="line"><span class="built_in">echo</span> unique_subject = yes &gt; index.txt.attr</span><br><span class="line"><span class="built_in">echo</span> <span class="number">01</span> &gt; serial</span><br></pre></td></tr></table></figure>

<h3 id="创建私钥-2"><a href="#创建私钥-2" class="headerlink" title="创建私钥"></a>创建私钥</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/ca.key <span class="number">2048</span></span><br></pre></td></tr></table></figure>

<h3 id="创建证书请求-1"><a href="#创建证书请求-1" class="headerlink" title="创建证书请求"></a>创建证书请求</h3><p>写好配置文件后：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key private/ca.key -out ../secondCA/requests/serverCA.csr -config conf/default.cnf</span><br></pre></td></tr></table></figure>

<p><em>注：之后ServerCA签发的客户端证书不具备CA权限，所以注意修改 <code>basicConstraints</code></em></p>
<h3 id="签发服务器证书-1"><a href="#签发服务器证书-1" class="headerlink" title="签发服务器证书"></a>签发服务器证书</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../secondCA</span><br><span class="line">openssl ca -<span class="keyword">in</span> requests/serverCA.csr -out ../serverCA/ca.crt -config conf/default.cnf</span><br></pre></td></tr></table></figure>

<h2 id="签发客户端证书"><a href="#签发客户端证书" class="headerlink" title="签发客户端证书"></a>签发客户端证书</h2><p>好吧都是一样的。。。</p>
<h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../serverCA</span><br><span class="line"><span class="built_in">mkdir</span> Client.<span class="variable">%x%</span></span><br></pre></td></tr></table></figure>

<h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out Client.<span class="variable">%x%</span>/client.key <span class="number">2048</span></span><br></pre></td></tr></table></figure>

<h3 id="生成请求"><a href="#生成请求" class="headerlink" title="生成请求"></a>生成请求</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key Client.<span class="variable">%x%</span>/client.key -out requests/client.<span class="variable">%x%</span>.csr -config conf/openssl.cnf</span><br></pre></td></tr></table></figure>

<h3 id="签发"><a href="#签发" class="headerlink" title="签发"></a>签发</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -<span class="keyword">in</span> requests/client.<span class="variable">%x%</span>.csr -out Client.<span class="variable">%x%</span>/client.crt -config conf/default.cnf</span><br></pre></td></tr></table></figure>

<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>为了客户端方便导入，最后需要打包成p12文件</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -clcerts -<span class="keyword">in</span> Client.<span class="variable">%x%</span>/client.crt -inkey Client.<span class="variable">%x%</span>/client.key -out Client.<span class="variable">%x%</span>/client.p12</span><br></pre></td></tr></table></figure>

<h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>写的可能有点草率，很多东西没说清楚，之后有空再完善。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公钥基础设施（三）：SSL协议]]></title>
      <url>https://HaleLu.github.io/2017/02/Public-Key-Infrastructure-3/</url>
      <content type="html"><![CDATA[<p>本篇主要讲SSL协议的通信过程。</p>
<a id="more"></a>

<h2 id="几个小问题"><a href="#几个小问题" class="headerlink" title="几个小问题"></a>几个小问题</h2><h3 id="SSL协议是干什么的？"><a href="#SSL协议是干什么的？" class="headerlink" title="SSL协议是干什么的？"></a>SSL协议是干什么的？</h3><p>首先，SSL是一种Web安全机制，他的作用是加密双方通信保证双方在不安全网络上的信息私密且不被篡改。</p>
<h3 id="SSL是怎么加密通信的？"><a href="#SSL是怎么加密通信的？" class="headerlink" title="SSL是怎么加密通信的？"></a>SSL是怎么加密通信的？</h3><p>简单来说，双方先使用公钥体制互相验证身份并协商一个密钥，然后双方使用这个密钥作为之后通信的对称密钥来加密会话。<br>由于协商密钥是使用公钥体制进行的，所以密钥本身是不会被其他人截获的，所以保证了之后的通信过程加密的可靠性。<br>而之后的会话使用对称密钥是因为每次都使用非对称密钥则开销过大，使用对称密钥可以大大节省开销。</p>
<h2 id="SSL协议详解"><a href="#SSL协议详解" class="headerlink" title="SSL协议详解"></a>SSL协议详解</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>有人说，SSL是在TCP和HTTP层之间的，也有人说，SSL层是和HTTP层并列在TCP层之上的。<br>我觉得应该是这样的：<br><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-3/Pic-1.jpg" alt></p>
<h4 id="SSL记录协议"><a href="#SSL记录协议" class="headerlink" title="SSL记录协议"></a>SSL记录协议</h4><p>记录协议将要发送的数据分块、压缩（可选）、加上消息认证代码（MAC）、加密、再加上一个SSL头，将最终的到的数据放入一个TCP段。<br>一个SSL记录的格式如下图所示：<br><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-3/Pic-2.jpg" alt></p>
<h4 id="SSL修改密码规范协议和警报协议"><a href="#SSL修改密码规范协议和警报协议" class="headerlink" title="SSL修改密码规范协议和警报协议"></a>SSL修改密码规范协议和警报协议</h4><p>这两个协议对我们开发来说关系不大。<br>修改密码规范协议仅一个字节，值为1，用于更新连接所使用的的密码套件。<br>警报协议两个字节，第一个字节表示等级，1表示警报（warning），2表示致命错误（error），第二个字节是警报信息的描述码，这里不详细列举。</p>
<h4 id="SSL握手协议"><a href="#SSL握手协议" class="headerlink" title="SSL握手协议"></a>SSL握手协议</h4><p>这是SSL协议的重点，SSL的复杂性和安全性基本依赖于握手协议。</p>
<p>握手协议一共分四个阶段：</p>
<h5 id="第一阶段：建立安全功能"><a href="#第一阶段：建立安全功能" class="headerlink" title="第一阶段：建立安全功能"></a>第一阶段：建立安全功能</h5><p>第一阶段的主要任务是协商SSL版本、加密算法、压缩算法等。具体流程如下：<br><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-3/Pic-3.jpg" alt></p>
<p>客户端发出一个ClientHello，包括</p>
<ul>
<li>客户端可以支持的SSL最高版本号</li>
<li>客户端生成的一个随机数</li>
<li>会话ID</li>
<li>客户端可以支持的密码套件列表</li>
<li>客户端可以支持的压缩算法列表</li>
</ul>
<p>那么服务器返回一个ServerHello，包括</p>
<ul>
<li>确定使用的SSL版本号（取客户端和服务器支持的最高版本号的较小值）</li>
<li>服务端生成的一个随机数</li>
<li>会话ID</li>
<li>服务端确定使用的密码套件</li>
<li>服务端确定使用的压缩算法</li>
</ul>
<p>至此，客户端服务端已经协商确认了：</p>
<ul>
<li>SSL版本</li>
<li>密钥交换、信息验证和加密算法</li>
<li>压缩方法</li>
<li>有关密钥生成的两个随机数</li>
</ul>
<h5 id="第二阶段：服务器认证和密钥交换"><a href="#第二阶段：服务器认证和密钥交换" class="headerlink" title="第二阶段：服务器认证和密钥交换"></a>第二阶段：服务器认证和密钥交换</h5><p>第二阶段双方之间做的事主要就是，服务器向客户端发送相关信息。<br>一般先后发送四条消息：</p>
<ul>
<li>证书链</li>
<li>服务器密钥交换<ul>
<li>此阶段非必须，以下情况下不需要此消息<ul>
<li>服务器发送了带有固定Diffie-Hellman参数的证书</li>
<li>使用RSA密钥交换</li>
</ul>
</li>
<li>那么剩下的，以下情况需要此消息<ul>
<li>匿名Diffie-Hellman：消息内容包括两个全局Diffie-Hellman值和服务器Diffie-Hellman公钥</li>
<li>瞬时Diffie-Hellman：消息内容包括三个Diffie-Hellman参数，包括匿名Diffie-Hellman中的两个参数和它们的签名</li>
<li>RSA密钥交换，服务器在使用RSA时仅使用了RSA签名密钥：因此，客户端不能简单地通过服务器公钥加密其密钥后传送，而服务器必须创建一个临时RSA公钥/私钥对，并使用服务器密钥交换信息发送公钥。消息内容包括两个临时的RSA公钥参数和参数签名。</li>
<li>Fortezza</li>
</ul>
</li>
<li>注：此时的签名并不是直接将请求hash后用私钥加密。为了防止重放攻击，还会将上一阶段客户端和服务器生成的两个随机数带上一起hash。</li>
</ul>
</li>
<li>证书请求消息（服务器不使用匿名Diffie-Hellman）<ul>
<li>包含两个参数：证书类型和签证机构<ul>
<li>第一个参数证书类型表明了公钥算法和用途</li>
<li>第二个参数签证机构是一张可接受的签证机构表</li>
</ul>
</li>
</ul>
</li>
<li>服务器完成消息（没有其他内容，仅表示消息结束）</li>
</ul>
<h5 id="第三阶段：客户端认证和密钥交换"><a href="#第三阶段：客户端认证和密钥交换" class="headerlink" title="第三阶段：客户端认证和密钥交换"></a>第三阶段：客户端认证和密钥交换</h5><p>第三阶段是客户端向服务器发送信息的阶段。在此之前，客户端会先检验服务端证书的有效性、参数是否可接受。<br>一般先后有三条消息：</p>
<ul>
<li>证书链（可选，如果服务器请求了证书，那么需要发送证书消息，如果没有证书需要发送“无证书警报”）</li>
<li>客户端密钥交换消息<ul>
<li>消息的内容依赖密钥交换的类型：<ul>
<li><strong>RSA</strong>：客户端生成48字节的次密钥，并使用服务器证书中的公钥或服务器密钥交换消息中的临时RSA密钥加密。他被用于生成主密钥</li>
<li><strong>瞬时或匿名Diffie-Hellman</strong>：发送的客户端Diffie-Hellman公钥参数</li>
<li><strong>固定Diffie-Hellman</strong>：由于证书消息中包括Diffie-Hellman公钥参数，因此此消息内容为空</li>
<li><strong>Fortezza</strong>：发送客户端的Fortezza参数</li>
</ul>
</li>
</ul>
</li>
<li>证书验证消息<ul>
<li>固定Diffie-Hellman不发送这一消息</li>
<li>客户端用私钥签名主密钥和握手信息，以防客户证书被盗用</li>
</ul>
</li>
</ul>
<h5 id="第四阶段：完成"><a href="#第四阶段：完成" class="headerlink" title="第四阶段：完成"></a>第四阶段：完成</h5><p>此阶段完成安全连接的设置。<br>过程如下：</p>
<ul>
<li>客户端使用修改密码规范协议发送一个修改密码规范消息（切换为对称加密）</li>
<li>客户端使用新的加密算法和密钥发送一个完成消息，完成消息的内容是对握手消息的hash，确认密钥交换和认证过程的正确性</li>
<li>服务端回应一个修改密码规范消息</li>
<li>服务端使用新的加密算法和密钥发送一个完成消息</li>
</ul>
<p>至此，握手完成，客户端和服务器可以用对称加密交换信息了。<br>至于主密钥的计算由于和我们关系不大，我们只需要知道是用次密钥、服务器随机数、客户端随机数这三者生成的就可以了。有兴趣的小伙伴可以自行查阅相关书籍或资料。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公钥基础设施（二）：数字证书]]></title>
      <url>https://HaleLu.github.io/2017/02/Public-Key-Infrastructure-2/</url>
      <content type="html"><![CDATA[<p>本篇主要讲数字证书的相关概念和作用。</p>
<a id="more"></a>

<h2 id="认识数字证书"><a href="#认识数字证书" class="headerlink" title="认识数字证书"></a>认识数字证书</h2><h3 id="直观认识"><a href="#直观认识" class="headerlink" title="直观认识"></a>直观认识</h3><p>我们先选择任意一个HTTPS的网站（例如<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a>），在Chrome浏览器中用F12调出开发者工具，选择Security标签页。<br><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-2/pic-1.jpg" alt><br>点击View certificate，可以看到一张证书。<br><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-2/pic-2.jpg" alt><br>这张证书是一张服务器证书，在详细信息中我们可以看到这张证书的基本信息。<br><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-2/pic-3.jpg" alt>  </p>
<p>所谓HTTPS，其实就是HTTP + SSL。<br>SSL的详细协议在下一篇讲，目前只需知道SSL所使用的数字证书就是这里的证书。而HTTPS就是用对方的公钥加密自己的通话，与对方协商出一个安全的对称密钥和加密方式，然后将双方通话过程全部用对称密钥加密（使用对称密钥是为了节省开销，每次都非对称加密会极大加重系统负担），由于协商过程是使用了公钥机制加密的，所以对称密钥也是安全的。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数字证书就是互联网通讯中标识通讯各方身份信息的一系列数据，提供了一种在Internet上验证身份的方式，其作用类似于驾驶执照或身份证。<br>数字证书通常由数字证书授权中心（Certificate Authority — CA）签发，带有CA的数字签名。其中包含公开密钥拥有者信息以及公开密钥的文件。<br>最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>其实说完最简单的证书，我们就可以知道数字证书最基本的功能是什么了。</p>
<ul>
<li>一个带有CA签名的证书，可以证明证书的主体是经过签发者认证的，安全的、可信任的（例如我们一开始看到的那张证书就是baidu.com经过了权威可信任的机构认证的凭证）</li>
<li>由于公钥也被签在了证书内，所以只有掌握对应私钥的主体（也就是证书主体本人）才能解密你用公钥加密过的数据<ul>
<li>即使其他任何人伪造了假的主体（例如修改DNS将<a href="http://www.baidu.com指向自己的服务器），但无法伪造带有CA签名的证书。换句话说，他可以伪造**http**://www.baidu.com，但无法伪造**https**://www.baidu.com" target="_blank" rel="noopener">www.baidu.com指向自己的服务器），但无法伪造带有CA签名的证书。换句话说，他可以伪造**http**://www.baidu.com，但无法伪造**https**://www.baidu.com</a></li>
<li>即使伪装者强行将合法的证书（例如baidu.com的证书）拿来作为自己的证书搭出了HTTPS服务，那么当客户端用证书中的公钥加密自己的信息时，伪装者由于没有对应的私钥，他将无法解密信息</li>
</ul>
</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>目前的证书通常遵循 ITUT X.509国际标准，证书主要包括以下信息：</p>
<ul>
<li>版本号：用来区分X.509的不同版本</li>
<li>序列号：每一个证书都有惟一的数字型编号</li>
<li>认证机构标识：颁发该证书的机构惟一的X.500名字</li>
<li>主体标识：证书持有者的名称</li>
<li>主体公钥信息：和该主体私钥相对应的公钥</li>
<li>证书有效期：证书开始有效期和证书失效期</li>
<li>密钥/证书用法：描述该主体的公/私密钥对的合法用途</li>
<li>扩展：说明该证书的附加信息</li>
<li>认证机构签名：用认证机构的私钥生成的数字签名</li>
</ul>
<p><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-2/pic-4.jpg" alt><br>认证机构签名是将主体部分hash后用认证机构私钥加密，如果能够被认证机构公钥解密就说明了证书内容没有被篡改。<br>验证方式如下图：<br><img src="http://halelu.github.io/2017/02/Public-Key-Infrastructure-2/pic-5.jpg" alt></p>
<h2 id="数字证书的使用"><a href="#数字证书的使用" class="headerlink" title="数字证书的使用"></a>数字证书的使用</h2><h3 id="PKI的基本组件"><a href="#PKI的基本组件" class="headerlink" title="PKI的基本组件"></a>PKI的基本组件</h3><ul>
<li>证书授权中心CA<ul>
<li>证书签发机构，是PKI的核心，使PKI 应用中权威的、可信任的、公正的第三方机构。主要负责产生、分配并管理所有参与网上交易的实体所需的身份认证数字证书。</li>
</ul>
</li>
<li>证书库<ul>
<li>证书的集中存放地，提供公众查询。</li>
</ul>
</li>
<li>密钥备份及恢复系统（optional）<ul>
<li>对用户的解密密钥进行备份，当丢失时进行恢复，而签名密钥不用备份和恢复。</li>
</ul>
</li>
<li>证书撤销处理系统<ul>
<li>证书由于某种原因需要作废，终止使用，将通过证书撤销列表(CRL)来实现。</li>
</ul>
</li>
<li>PKI应用接口系统<ul>
<li>为各种各样的应用提供安全、一致、可信任的方式与PKI交互，确保所建立起来的网络环境安全可靠，并降低管理成本。</li>
</ul>
</li>
</ul>
<h3 id="PKI的基本原理"><a href="#PKI的基本原理" class="headerlink" title="PKI的基本原理"></a>PKI的基本原理</h3><p>首先，PKI有两条基本原则：</p>
<ul>
<li>有些安全性非常高、信誉非常好的CA是所有人都可以信任的，他们拥有签发下级CA的权利。他们的证书通常被内置在操作系统的可信任列表里。</li>
<li>如果一个CA是可信任的且CA拥有签发下级证书的权利，那么他签发的证书也是可信任的。</li>
</ul>
<p>所以，通常我们看到的证书都是一条证书链。通常 <strong>根CA</strong> 不签发末端的客户证书，只负责签发 <strong>CA</strong> 证书，而 <strong>CA</strong> 根据他们证书中被授予的权限，有些可以签发下级CA有些只可以签发客户证书。<br>每张证书都会有过期时间和一个证书撤销列表（CRL）的URL。如果一张证书过期或被写进了CRL，那么证书就会作废（这往往是由私钥泄露导致的）。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公钥基础设施（一）：公钥机制]]></title>
      <url>https://HaleLu.github.io/2017/02/Public-Key-Infrastructure-1/</url>
      <content type="html"><![CDATA[<p>好久没有更文了。<br>最近有个项目，想用证书的方式来验证设备身份，所以仔细研究了一下PKI。<br>其实信安课上有讲，可是当时一知半解，现在刚好整理复习一下。</p>
<a id="more"></a>

<h2 id="PKI概述"><a href="#PKI概述" class="headerlink" title="PKI概述"></a>PKI概述</h2><p>PKI（Public Key Infrastructure）全称是公钥基础设施，主要提供公钥加密和数字签名服务。PKI技术以公钥技术为基础，以数字证书为媒介，结合对称加密和非对称加密技术，将个人、组织、设备的标识信息与各自的公钥捆绑在一起。其主要目的是通过自动管理密钥和证书，为用户建立起一个安全、可信的网络运行环境，使用户可以在多种应用环境下方便地使用加密和数字签名技术，在互联网上验证用户的身份，从而保证了互联网上所传输信息的真实性、完整性、机密性和不可否认性。</p>
<h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><p>目前常规的加密方式通常只有两种：对称和非对称加密。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>所谓对称加密，就是指加密和解密使用的密钥是相同的，加密和解密的过程对称，所以被称为对称加密。<br>例如异或加密就是一种很简单的对称加密算法。（即明文用密钥加密一次成为密文，密文用同一密钥解密一次成为明文）</p>
<p>在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>算法公开，安全性由密钥本身保证</li>
<li>计算量小、运算效率高，适合加密大量数据</li>
<li>密文长度和明文相等，不会增加负担<ul>
<li><em>这个优点是我在信息安全的PPT上看到的，但是学长认为这并不一定。例如如果将BASE64的编码表看作是密钥的话，BASE64是一种对称加密，但是加密后密码变长了。我站学长，不过我觉得讲义上这么说大概指的是成熟的对称加密算法考虑到加解密效率一般都会尽可能保证密文长度不增加？</em></li>
</ul>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>双方在约定密钥时需要以安全方式进行</li>
<li>一旦一方密钥泄露，则会话完全暴露</li>
<li>易被破解（也许不一定，但一般不如非对称加密）</li>
<li>由于密钥是基于会话的，密钥数量平方级增长，难以管理</li>
</ul>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>相对的，非对称加密指加密和解密所需的密钥并不相同，用 <strong>加密密钥</strong> 加密的密文是无法再次用 <strong>加密密钥</strong> 解出明文的，只能用与加密密钥对应的 <strong>解密密钥</strong> 来得到明文。<br>当然，<strong>加密密钥</strong> 和 <strong>解密密钥</strong> 是相对的，他们可以互相加解密。<br>也就是说，在非对称加密中，有一个密钥对，其中一个用来加密的时候，还要得到另一个才能解密。</p>
<p>所以，在非对称加密中有两个密钥，只要自己保密两个中的一个，那么就能保证通话的安全。也就是说其中一个即使泄露也不会影响安全性，是可公开的。<br>于是这种体制又被称为 <strong>公钥机制</strong> 。</p>
<h2 id="公钥机制"><a href="#公钥机制" class="headerlink" title="公钥机制"></a>公钥机制</h2><p>每个人都有两把密钥，其中一把密钥由自己保密，称为 <strong>私钥</strong> ，另一把任何人都可以拥有，向所有人公开，称为 <strong>公钥</strong> 。<br>公钥体制主要能做的两件事就是加密和验证。</p>
<p>加密是保证对方发送给自己的数据不会被他人破解。<br>验证是保证自己发送给对方的数据无法被他人篡改，且自己也不可否认。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>加密的实现方式是，对方用公钥加密信息并发送给自己。解密密文的私钥只有自己有，所以保证了密文的机密性。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证的实现方式是，将自己要发送的信息用自己的私钥加密。由于自己的公钥是公开的，所以密文本身没有机密性，可被任何人解密，但是对方能否用公钥解密这一点就保证了文本的完整性和不可否认。<br>其他人如果想修改原文，那么修改后是无法再次用私钥进行加密的，也就无法让密文可以被公钥解密。<br>事实上，由于正文过长，我们往往会将信息hash后再用私钥加密，附在正文后用以验证。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>双方信息可以以安全方式传输</li>
<li>大大减少密钥持有量，每人仅需一把仅自己持有的私钥和一把可公开的公钥，常数级</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>计算复杂、耗用资源大</li>
<li>密文长度大于明文，传输负担增大</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NOIp 2016 提高组题解]]></title>
      <url>https://HaleLu.github.io/2016/12/NOIP-2016/</url>
      <content type="html"><![CDATA[<h2 id="照例"><a href="#照例" class="headerlink" title="照例"></a>照例</h2><p>好久不刷题不写题解了。想想自己也大三了。看到子楚兄说自己退役的一瞬间，突然发现自己的时间其实也只剩下一年不到了。<br>到现在ACM连个铜都没拿过，CCPC也是打铁。再不好好刷题再也没时间了。<br>跟队友开玩笑说明年要拿金。但我真的希望不是玩笑。</p>
<p>刷题，我生命中最美的两个字！</p>
<a id="more"></a>

<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="T1-toy-玩具谜题"><a href="#T1-toy-玩具谜题" class="headerlink" title="T1 toy 玩具谜题"></a>T1 toy 玩具谜题</h3><p><a href="https://www.luogu.org/problem/show?pid=1563" target="_blank" rel="noopener">原题链接</a></p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>水题，模拟就行。<br>我取了个巧，把0换成-1，然后乘就可以。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, d[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100010</span>][<span class="number">15</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %s"</span>, &amp;d[i], name[i]); getchar();</span><br><span class="line">		<span class="keyword">if</span> (!d[i]) d[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a, s;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;s);</span><br><span class="line">		<span class="keyword">if</span> (!a) a = <span class="number">-1</span>;</span><br><span class="line">		pos -= a * d[pos] * s;</span><br><span class="line">		<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>) pos += n;</span><br><span class="line">		<span class="keyword">if</span> (pos &gt; n) pos -= n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name[pos]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-running-天天爱跑步"><a href="#T2-running-天天爱跑步" class="headerlink" title="T2 running 天天爱跑步"></a>T2 running 天天爱跑步</h3><p><a href="https://www.luogu.org/problem/show?pid=1600" target="_blank" rel="noopener">原题链接</a></p>
<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>两天最难的题了吧。一开始想的是骗分。思路是网上看来的。<br>首先所有的路径一定是从起点经过LCA（最小公共祖先）到达终点，先上后下（也有可能只上或只下）。<br>于是我们把s到t的路径拆分成s到top（向上）再由top到t（向下）。<br>如果把节点v深度记为d[v]的话，那么在向上的过程中 时间+深度 是定值d[s]。<br>同样，向下过程中 深度-时间 是定值d[t]-len（len = d[s]+d[t]-2*d[top]，是路径总长度，也是总时间）。<br>换句话说，对于从s到top这条路径上所有的点v，如果它的观察时间w[v]满足w[v]+d[v] == d[s]；同理，向下满足d[v]-w[v] == d[t]-len，那么它的答案数就要+1。  </p>
<p>有几个点吧，第一个是LCA，第二个是树的前缀和。<br>LCA有人说用Tarjan，我比较菜，不会。我能接受的一种O(nlogn)的方法就是开一个f[0..N][0..logN]的数组，f[i][j]表示结点i的第2^j级父节点。这样找LCA的时候就是O(logn)级别的了。<br>然后说到，在给s到top或者top到t做标记的时候我们是不能遍历一个个做标记的，所以我们先O(1)的做标记。<br>比如s到top时，我们在s处做+1标记，在top处做-1标记，之后在求结果的时候深搜求子树和。<br>用两个数组（桶）up[i]、down[i]记录当前搜索路径下定值为i的路径数（为了避免负数，down数组下标需要加上一个MAXN）<br>然后就没有了。</p>
<h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300007 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> first[MAXN*<span class="number">20</span>], last[MAXN*<span class="number">2</span>], next[MAXN*<span class="number">2</span>], num;</span><br><span class="line"><span class="keyword">int</span> first1[MAXN*<span class="number">20</span>], last1[MAXN*<span class="number">2</span>], next1[MAXN*<span class="number">2</span>], num1;</span><br><span class="line"><span class="keyword">int</span> first2[MAXN*<span class="number">20</span>], last2[MAXN*<span class="number">2</span>], next2[MAXN*<span class="number">2</span>], num2;</span><br><span class="line"><span class="keyword">int</span> first3[MAXN*<span class="number">20</span>], last3[MAXN*<span class="number">2</span>], next3[MAXN*<span class="number">2</span>], num3;</span><br><span class="line"><span class="keyword">int</span> first4[MAXN*<span class="number">20</span>], last4[MAXN*<span class="number">2</span>], next4[MAXN*<span class="number">2</span>], num4;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">int</span> w[MAXN];</span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="keyword">int</span> up[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> down[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (d[x] &lt; d[y])</span><br><span class="line">	&#123;</span><br><span class="line">		swap(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (d[f[x][i]] &gt;= d[y])</span><br><span class="line">		&#123;</span><br><span class="line">			x = f[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[x] != d[y])</span><br><span class="line">		x = f[x][<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">		&#123;</span><br><span class="line">			x = f[x][i];</span><br><span class="line">			y = f[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (x != y) ? f[x][<span class="number">0</span>] : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = up[d[v]+w[v]];</span><br><span class="line">	<span class="keyword">int</span> y = down[d[v]-w[v]+MAXN];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=first1[v]; i; i=next1[i])</span><br><span class="line">	&#123;</span><br><span class="line">		up[last1[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=first2[v]; i; i=next2[i])</span><br><span class="line">	&#123;</span><br><span class="line">		down[last2[i]+MAXN]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=first[v]; i; i=next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (last[i] != f[v][<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(last[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[v] = up[d[v]+w[v]] + down[d[v]-w[v]+MAXN]-x-y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=first3[v]; i; i=next3[i])</span><br><span class="line">	&#123;</span><br><span class="line">		up[last3[i]]--;</span><br><span class="line">		<span class="keyword">if</span> (last3[i] == d[v]+w[v])</span><br><span class="line">			ans[v]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=first4[v]; i; i=next4[i])</span><br><span class="line">	&#123;</span><br><span class="line">		down[last4[i]+MAXN]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_deep</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	d[v] = d[fa]+<span class="number">1</span>;</span><br><span class="line">	f[v][<span class="number">0</span>] = fa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = first[v]; i; i=next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (last[i] != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			calc_deep(last[i], v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	last[++num] = v;</span><br><span class="line">	next[num] = first[u];</span><br><span class="line">	first[u] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_up</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	last1[++num1] = v;</span><br><span class="line">	next1[num1] = first1[u];</span><br><span class="line">	first1[u] = num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_down</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	last2[++num2] = v;</span><br><span class="line">	next2[num2] = first2[u];</span><br><span class="line">	first2[u] = num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_top_up</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	last3[++num3] = v;</span><br><span class="line">	next3[num3] = first3[u];</span><br><span class="line">	first3[u] = num3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_top_down</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	last4[++num4] = v;</span><br><span class="line">	next4[num4] = first4[u];</span><br><span class="line">	first4[u] = num4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		add(u, v);</span><br><span class="line">		add(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	calc_deep(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">20</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j] = f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> s, t;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;t);</span><br><span class="line">		<span class="keyword">int</span> top = lca(s, t);</span><br><span class="line">		<span class="keyword">int</span> len = d[s]+d[t]-d[top]-d[top];</span><br><span class="line">		<span class="keyword">int</span> diff = d[t] - len;</span><br><span class="line">		add_up(s, d[s]);</span><br><span class="line">		add_down(t, diff);</span><br><span class="line">		add_top_up(top, d[s]);</span><br><span class="line">		add_top_down(top, diff);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-classroom-换教室"><a href="#T3-classroom-换教室" class="headerlink" title="T3 classroom 换教室"></a>T3 classroom 换教室</h3><p><a href="https://www.luogu.org/problem/show?pid=1850" target="_blank" rel="noopener">原题链接</a></p>
<h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><p>dp，几乎算是模板题。<br>递推式自己看代码吧。</p>
<h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2010 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXL 10000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">double</span> k[MAXN];</span><br><span class="line"><span class="keyword">int</span> w[MAXN][MAXN];</span><br><span class="line"><span class="keyword">double</span> f[MAXN][MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">min</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, v ,e;</span><br><span class="line">	<span class="keyword">int</span> i, j, mid;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;v, &amp;e);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;k[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=v; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=v; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			w[i][j] = MAXL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=v; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		w[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;e; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[u][v]);</span><br><span class="line">		<span class="keyword">if</span> (w[v][u] &gt; w[u][v])</span><br><span class="line">			w[v][u] = w[u][v];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			w[u][v] = u == v ? <span class="number">0</span> : w[v][u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (mid=<span class="number">1</span>; mid&lt;=v; mid++)</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=v; i++)</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=v; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (w[i][j] &gt; w[i][mid] + w[mid][j])</span><br><span class="line">				&#123;</span><br><span class="line">					w[i][j] = w[i][mid] + w[mid][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i&lt;j) </span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j][<span class="number">0</span>] = f[i][j][<span class="number">1</span>] = MAXL;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) </span><br><span class="line">					f[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					f[i][j][<span class="number">0</span>] = min(f[i<span class="number">-1</span>][j][<span class="number">0</span>] + w[c[i<span class="number">-1</span>]][c[i]], </span><br><span class="line">							 f[i<span class="number">-1</span>][j][<span class="number">1</span>] + k[i<span class="number">-1</span>] * w[d[i<span class="number">-1</span>]][c[i]] + (<span class="number">1</span>-k[i<span class="number">-1</span>]) * w[c[i<span class="number">-1</span>]][c[i]]);</span><br><span class="line">				<span class="keyword">if</span> (j==<span class="number">0</span>)</span><br><span class="line">					f[i][j][<span class="number">1</span>] = MAXL;</span><br><span class="line">				<span class="keyword">else</span>			 </span><br><span class="line">					f[i][j][<span class="number">1</span>] = min(f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>] + (<span class="number">1</span>-k[i]) * w[c[i<span class="number">-1</span>]][c[i]] + k[i] * w[c[i<span class="number">-1</span>]][d[i]],</span><br><span class="line">							 f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + k[i] * k[i<span class="number">-1</span>] * w[d[i<span class="number">-1</span>]][d[i]] + k[i] * (<span class="number">1</span>-k[i<span class="number">-1</span>]) * w[c[i<span class="number">-1</span>]][d[i]] + (<span class="number">1</span>-k[i]) * k[i<span class="number">-1</span>] * w[d[i<span class="number">-1</span>]][c[i]] + (<span class="number">1</span>-k[i<span class="number">-1</span>]) * (<span class="number">1</span>-k[i]) * w[c[i<span class="number">-1</span>]][c[i]]);</span><br><span class="line">			</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> ans = f[n][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m &amp;&amp; j&lt;=n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[n][j][<span class="number">0</span>] &lt; ans) ans = f[n][j][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (f[n][j][<span class="number">1</span>] &lt; ans) ans = f[n][j][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, ans);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="T1-problem-组合数问题"><a href="#T1-problem-组合数问题" class="headerlink" title="T1 problem 组合数问题"></a>T1 problem 组合数问题</h3><p><a href="https://www.luogu.org/problem/show?pid=2822" target="_blank" rel="noopener">原题链接</a></p>
<h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><p>杨辉三角性质+二维前缀和。</p>
<h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2016</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL C[MAXN][MAXN];</span><br><span class="line">LL ans[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;k);</span><br><span class="line">	</span><br><span class="line">	C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; <span class="number">2010</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		ans[i][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j]) % k;</span><br><span class="line">			ans[i][j] = ans[i<span class="number">-1</span>][j] + ans[i][j<span class="number">-1</span>] - ans[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span> (C[i][j] == <span class="number">0</span>) ans[i][j]++;</span><br><span class="line">		&#125;</span><br><span class="line">		C[i][i] = <span class="number">1</span>;</span><br><span class="line">		ans[i][i] = ans[i][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">if</span> (m &gt; n) m = n;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[n][m]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-earthworm-蚯蚓"><a href="#T2-earthworm-蚯蚓" class="headerlink" title="T2 earthworm 蚯蚓"></a>T2 earthworm 蚯蚓</h3><p><a href="https://www.luogu.org/problem/show?pid=2827" target="_blank" rel="noopener">原题链接</a></p>
<h4 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h4><p>一开始用的queue，结果爆常数了。一怒之下开个10^6的数组好了。<br>由于切的比例p是定值，所以先被切的一定比后被切的长，所以直接把原长排序、再把切下来的两端分别放进两个队列，每次取队首的比，最长的拿来切。<br>每回合所有的增长转化为被切的两个缩短。需要注意的是切之前要算一下原长再切。</p>
<h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2140000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 7200100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q1[MAXM], q2[MAXM], q3[MAXM];</span><br><span class="line"><span class="keyword">int</span> head1=<span class="number">0</span>, head2=<span class="number">0</span>, head3=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tail1=<span class="number">-1</span>, tail2=<span class="number">-1</span>, tail3=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Trunc</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)(x + N) - N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, q, u, v, t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n+m+<span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q1[i] = q2[i] = q3[i] = -N;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(q1, q1+n, cmp);</span><br><span class="line">	tail1 = n<span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> p = (<span class="keyword">double</span>)u/v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *t1, *t2, *t3;</span><br><span class="line">	t1 = q1+head1;</span><br><span class="line">	t2 = q2+head2;</span><br><span class="line">	t3 = q3+head3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*t1 &gt;= *t2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*t1 &gt;= *t3)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t1;</span><br><span class="line">				head1++;</span><br><span class="line">				t1++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t3;</span><br><span class="line">				head3++;</span><br><span class="line">				t3++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*t2 &gt;= *t3)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t2;</span><br><span class="line">				head2++;</span><br><span class="line">				t2++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t3;</span><br><span class="line">				head3++;</span><br><span class="line">				t3++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp += q * i;</span><br><span class="line">		q2[++tail2] = Trunc(tmp * p - (i+<span class="number">1</span>) * q);</span><br><span class="line">		q3[++tail3] = tmp - (<span class="keyword">int</span>)(tmp * p) - (i+<span class="number">1</span>) * q;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> ((i+<span class="number">1</span>) == t) <span class="built_in">printf</span>(<span class="string">"%d"</span>, tmp);	</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((i+<span class="number">1</span>) % t == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" %d"</span>, tmp);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*t1 != -N || *t2 != -N || *t3 != -N)</span><br><span class="line">	&#123;</span><br><span class="line">		tt++;</span><br><span class="line">		<span class="keyword">if</span> (*t1 &gt;= *t2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*t1 &gt;= *t3)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t1;</span><br><span class="line">				head1++;</span><br><span class="line">				t1++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t3;</span><br><span class="line">				head3++;</span><br><span class="line">				t3++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*t2 &gt;= *t3)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t2;</span><br><span class="line">				head2++;</span><br><span class="line">				t2++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				tmp = *t3;</span><br><span class="line">				head3++;</span><br><span class="line">				t3++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (tt == t) <span class="built_in">printf</span>(<span class="string">"%d"</span>, tmp + m*q);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tt % t == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" %d"</span>, tmp + m*q);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-angrybirds-愤怒的小鸟"><a href="#T3-angrybirds-愤怒的小鸟" class="headerlink" title="T3 angrybirds 愤怒的小鸟"></a>T3 angrybirds 愤怒的小鸟</h3><p><a href="https://www.luogu.org/problem/show?pid=2831" target="_blank" rel="noopener">原题链接</a></p>
<h4 id="解释-5"><a href="#解释-5" class="headerlink" title="解释"></a>解释</h4><p>状压dp。<br>i看成二进制，由低到高第x位表示第x只猪。0为未击中，1为击中。<br>先两两初始化出由这两个点确定的抛物线可以击中的所有的猪（击中就或上这一位），然后O(2^n)的dp就可以了。<br>有几个坑，一个是a有可能大于等于0，另一个是double由于精度的问题等于要用abs(a-b)&lt;EXP的方式判断。</p>
<h4 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 265000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">double</span> y[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line">LL pow2[<span class="number">20</span>];</span><br><span class="line">LL route[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;=<span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log2</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">128</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">256</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">512</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1024</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2048</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4096</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8192</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16384</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32768</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">65536</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">131072</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">262144</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">524288</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">19</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pow2[i] = pow2[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">double</span> a = (x[i]*y[j]-x[j]*y[i])/(x[i]*x[j]*(x[j]-x[i]));</span><br><span class="line">				<span class="keyword">double</span> b = (x[j]*x[j]*y[i]-x[i]*x[i]*y[j])/(x[i]*x[j]*(x[j]-x[i]));</span><br><span class="line">				<span class="keyword">if</span> (a &gt;= <span class="number">0</span> || <span class="built_in">abs</span>(x[j]-x[i]) &lt; EXP) &#123;</span><br><span class="line">					route[i][j] = pow2[i];</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				route[i][j] = pow2[i] | pow2[j];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">abs</span>(a*x[k]*x[k]+b*x[k]-y[k]) &lt; EXP) </span><br><span class="line">					&#123;</span><br><span class="line">						route[i][j] |= pow2[k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				route[j][i] = route[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (LL s=<span class="number">1</span>; s&lt;pow2[n]; s++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[s] = <span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (LL s=<span class="number">0</span>; s&lt;pow2[n]<span class="number">-1</span>; s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i = log2(((s ^ (s+<span class="number">1</span>)) + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			LL tmp = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp =  s | route[i][j];</span><br><span class="line">				<span class="keyword">if</span> (f[tmp] &gt; f[s] + <span class="number">1</span>)</span><br><span class="line">					f[tmp] = f[s] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">				tmp = pow2[n]<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span> (f[tmp] &gt; f[s] + <span class="number">1</span>)</span><br><span class="line">					f[tmp] = f[s] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[pow2[n]<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The 2016 ACM-ICPC Asia Beijing Regional Contest]]></title>
      <url>https://HaleLu.github.io/2016/09/The-2016-ACM-ICPC-Asia-Beijing-Regional-Contest/</url>
      <content type="html"><![CDATA[<p>补题解。<br>好久不写了，但是再不好好写大三就废了。<br>不废话了。</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><a href="https://hihocoder.com/problemset/problem/1383" target="_blank" rel="noopener">原题戳这里</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 n 本书, 每本书的格式为<code>CATEGORY 1/CATEGORY 2/..../CATEGORY n/BOOKNAME</code>, 现在要重新格式化这些书的格式. 第 n 个 category 前面需要有 4(n-1) 个空格, 如果这本书在第 n 个 category 上, 那么它前面要有 4n 个空格. 同一 category 里面,  category 和书名都按照字典序排序, 但是 category 要排在书前面. 第一个 category 需要按照字典序排列。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">B/A</span><br><span class="line">B/A</span><br><span class="line">B/B</span><br><span class="line">0</span><br><span class="line">A1/B1/B32/B7</span><br><span class="line">A1/B/B2/B4/C5</span><br><span class="line">A1/B1/B2/B6/C5</span><br><span class="line">A1/B1/B2/B5</span><br><span class="line">A1/B1/B2/B1</span><br><span class="line">A1/B3/B2</span><br><span class="line">A3/B1</span><br><span class="line">A0/A1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">B</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">Case 2:</span><br><span class="line">A0</span><br><span class="line">    A1</span><br><span class="line">A1</span><br><span class="line">    B</span><br><span class="line">        B2</span><br><span class="line">            B4</span><br><span class="line">                C5</span><br><span class="line">    B1</span><br><span class="line">        B2</span><br><span class="line">            B6</span><br><span class="line">                C5</span><br><span class="line">            B1</span><br><span class="line">            B5</span><br><span class="line">        B32</span><br><span class="line">            B7</span><br><span class="line">    B3</span><br><span class="line">        B2</span><br><span class="line">A3</span><br><span class="line">    B1</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>hzy解了这题。建树并排序就可以了。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> nm[<span class="number">105</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">	book bk;</span><br><span class="line">	<span class="keyword">int</span> sons,son[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">bool</span> shu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tree a[maxn];</span><br><span class="line">book b[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> tot,now;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">vali</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="string">'A'</span>&amp;&amp;x&lt;=<span class="string">'Z'</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="string">'0'</span>&amp;&amp;x&lt;=<span class="string">'9'</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> (x==<span class="string">' '</span>||x==<span class="string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getstr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	c=getchar(); </span><br><span class="line">	<span class="keyword">if</span>(c==EOF)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span>(!vali(c))&#123;</span><br><span class="line">		c=getchar();</span><br><span class="line">		<span class="keyword">if</span>(c==EOF)<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(vali(c))&#123;</span><br><span class="line">		b[x].nm[len++]=c;</span><br><span class="line">		c=getchar();</span><br><span class="line">		<span class="keyword">if</span>(c==EOF)<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	b[x].nm[len]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">big</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(b[x].nm)&amp;&amp;i&lt;<span class="built_in">strlen</span>(b[y].nm);i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(b[x].nm[i]&gt;b[y].nm[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(b[x].nm[i]&lt;b[y].nm[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(b[x].nm)&gt;<span class="built_in">strlen</span>(b[y].nm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">yes</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;z&lt;<span class="built_in">strlen</span>(b[y].nm) &amp;&amp; b[y].nm[z]!=<span class="string">'/'</span>;z++,i++)</span><br><span class="line">		<span class="keyword">if</span>(a[x].bk.nm[i]!=b[y].nm[z])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[x].bk.nm[i]!=<span class="string">'\0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(z&gt;=<span class="built_in">strlen</span>(b[y].nm)&amp;&amp;a[x].shu==<span class="literal">false</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(z&lt;<span class="built_in">strlen</span>(b[y].nm)&amp;&amp;b[y].nm[z]==<span class="string">'/'</span>&amp;&amp;a[x].shu)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> x,<span class="keyword">unsigned</span> <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[s].sons;i++)</span><br><span class="line">		<span class="keyword">if</span>(yes(a[s].son[i],x,y))&#123;</span><br><span class="line">			<span class="keyword">while</span>(y&lt;<span class="built_in">strlen</span>(b[x].nm)&amp;&amp;b[x].nm[y]!=<span class="string">'/'</span>)y++;</span><br><span class="line">			<span class="keyword">if</span>(y&gt;=<span class="built_in">strlen</span>(b[x].nm))<span class="keyword">return</span>;</span><br><span class="line">			ins(a[s].son[i],x,y+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	++tot;</span><br><span class="line">	a[s].sons++;</span><br><span class="line">	a[s].son[a[s].sons]=tot;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;y&lt;<span class="built_in">strlen</span>(b[x].nm)&amp;&amp;b[x].nm[y]!=<span class="string">'/'</span>;y++,j++)</span><br><span class="line">		a[tot].bk.nm[j]=b[x].nm[y];</span><br><span class="line">	a[tot].bk.nm[j]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">if</span>(y&gt;=<span class="built_in">strlen</span>(b[x].nm))&#123;</span><br><span class="line">		a[tot].shu=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">		a[tot].shu=<span class="number">0</span>;</span><br><span class="line">	ins(tot,x,y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">biger</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a[x].bk.nm)&amp;&amp;i&lt;<span class="built_in">strlen</span>(a[y].bk.nm);i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(a[x].bk.nm[i]&gt;a[y].bk.nm[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(a[x].bk.nm[i]&lt;a[y].bk.nm[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(a[x].bk.nm)&gt;<span class="built_in">strlen</span>(a[y].bk.nm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=x; x=y; y=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s_sort</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a[x].sons;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=a[x].sons;j++)</span><br><span class="line">			<span class="keyword">if</span>(biger(a[x].son[i],a[x].son[j]))&#123;</span><br><span class="line">				swap(a[x].son[i],a[x].son[j]);</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;i++)<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a[x].bk.nm);</span><br><span class="line">	&#125;</span><br><span class="line">	s_sort(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[x].sons;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[a[x].son[i]].shu==<span class="literal">false</span>)</span><br><span class="line">			deal(a[x].son[i],y+<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[x].sons;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[a[x].son[i]].shu)</span><br><span class="line">			deal(a[x].son[i],y+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("d:/shit.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		tot=<span class="number">0</span>; now=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			++now; </span><br><span class="line">			getstr(now);</span><br><span class="line">			<span class="keyword">if</span>(c==EOF)&#123;</span><br><span class="line">				--now;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strlen</span>(b[now].nm)&lt;=<span class="number">2</span>&amp;&amp;b[now].nm[<span class="number">0</span>]==<span class="string">'0'</span>)&#123;</span><br><span class="line">				--now;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=now;i++)&#123;</span><br><span class="line">			ins(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		id++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,id);</span><br><span class="line">		deal(<span class="number">0</span>,<span class="number">-4</span>);</span><br><span class="line">		<span class="keyword">if</span>(c!=<span class="string">'\n'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><a href="https://hihocoder.com/problemset/problem/1384" target="_blank" rel="noopener">原题戳这里</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出n个数p1,p2,…,pn, 你要把把这nn个数划分成若干段(每段都是连续的), 每段的代价这么计算:<br>从每段中选出m(不够m对的话, 选出最多的对数)对，计算每对数之间的差值，然后求平方和，代价是所有选法的平方和的最大值，记为SPD。<br>你要划分成最少的段，使得每段的SPD都不大于k。</p>
<h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">B/A</span><br><span class="line">B/A</span><br><span class="line">B/B</span><br><span class="line">0</span><br><span class="line">A1/B1/B32/B7</span><br><span class="line">A1/B/B2/B4/C5</span><br><span class="line">A1/B1/B2/B6/C5</span><br><span class="line">A1/B1/B2/B5</span><br><span class="line">A1/B1/B2/B1</span><br><span class="line">A1/B3/B2</span><br><span class="line">A3/B1</span><br><span class="line">A0/A1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">B</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">Case 2:</span><br><span class="line">A0</span><br><span class="line">    A1</span><br><span class="line">A1</span><br><span class="line">    B</span><br><span class="line">        B2</span><br><span class="line">            B4</span><br><span class="line">                C5</span><br><span class="line">    B1</span><br><span class="line">        B2</span><br><span class="line">            B6</span><br><span class="line">                C5</span><br><span class="line">            B1</span><br><span class="line">            B5</span><br><span class="line">        B32</span><br><span class="line">            B7</span><br><span class="line">    B3</span><br><span class="line">        B2</span><br><span class="line">A3</span><br><span class="line">    B1</span><br></pre></td></tr></table></figure>

<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>hzy解了这题。建树并排序就可以了。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> nm[<span class="number">105</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">	book bk;</span><br><span class="line">	<span class="keyword">int</span> sons,son[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">bool</span> shu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tree a[maxn];</span><br><span class="line">book b[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> tot,now;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">vali</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="string">'A'</span>&amp;&amp;x&lt;=<span class="string">'Z'</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="string">'0'</span>&amp;&amp;x&lt;=<span class="string">'9'</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> (x==<span class="string">' '</span>||x==<span class="string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getstr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	c=getchar(); </span><br><span class="line">	<span class="keyword">if</span>(c==EOF)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span>(!vali(c))&#123;</span><br><span class="line">		c=getchar();</span><br><span class="line">		<span class="keyword">if</span>(c==EOF)<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(vali(c))&#123;</span><br><span class="line">		b[x].nm[len++]=c;</span><br><span class="line">		c=getchar();</span><br><span class="line">		<span class="keyword">if</span>(c==EOF)<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	b[x].nm[len]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">big</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(b[x].nm)&amp;&amp;i&lt;<span class="built_in">strlen</span>(b[y].nm);i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(b[x].nm[i]&gt;b[y].nm[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(b[x].nm[i]&lt;b[y].nm[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(b[x].nm)&gt;<span class="built_in">strlen</span>(b[y].nm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">yes</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;z&lt;<span class="built_in">strlen</span>(b[y].nm) &amp;&amp; b[y].nm[z]!=<span class="string">'/'</span>;z++,i++)</span><br><span class="line">		<span class="keyword">if</span>(a[x].bk.nm[i]!=b[y].nm[z])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[x].bk.nm[i]!=<span class="string">'\0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(z&gt;=<span class="built_in">strlen</span>(b[y].nm)&amp;&amp;a[x].shu==<span class="literal">false</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(z&lt;<span class="built_in">strlen</span>(b[y].nm)&amp;&amp;b[y].nm[z]==<span class="string">'/'</span>&amp;&amp;a[x].shu)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> x,<span class="keyword">unsigned</span> <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[s].sons;i++)</span><br><span class="line">		<span class="keyword">if</span>(yes(a[s].son[i],x,y))&#123;</span><br><span class="line">			<span class="keyword">while</span>(y&lt;<span class="built_in">strlen</span>(b[x].nm)&amp;&amp;b[x].nm[y]!=<span class="string">'/'</span>)y++;</span><br><span class="line">			<span class="keyword">if</span>(y&gt;=<span class="built_in">strlen</span>(b[x].nm))<span class="keyword">return</span>;</span><br><span class="line">			ins(a[s].son[i],x,y+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	++tot;</span><br><span class="line">	a[s].sons++;</span><br><span class="line">	a[s].son[a[s].sons]=tot;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;y&lt;<span class="built_in">strlen</span>(b[x].nm)&amp;&amp;b[x].nm[y]!=<span class="string">'/'</span>;y++,j++)</span><br><span class="line">		a[tot].bk.nm[j]=b[x].nm[y];</span><br><span class="line">	a[tot].bk.nm[j]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">if</span>(y&gt;=<span class="built_in">strlen</span>(b[x].nm))&#123;</span><br><span class="line">		a[tot].shu=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">		a[tot].shu=<span class="number">0</span>;</span><br><span class="line">	ins(tot,x,y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">biger</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a[x].bk.nm)&amp;&amp;i&lt;<span class="built_in">strlen</span>(a[y].bk.nm);i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(a[x].bk.nm[i]&gt;a[y].bk.nm[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(a[x].bk.nm[i]&lt;a[y].bk.nm[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(a[x].bk.nm)&gt;<span class="built_in">strlen</span>(a[y].bk.nm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=x; x=y; y=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s_sort</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a[x].sons;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=a[x].sons;j++)</span><br><span class="line">			<span class="keyword">if</span>(biger(a[x].son[i],a[x].son[j]))&#123;</span><br><span class="line">				swap(a[x].son[i],a[x].son[j]);</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;i++)<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a[x].bk.nm);</span><br><span class="line">	&#125;</span><br><span class="line">	s_sort(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[x].sons;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[a[x].son[i]].shu==<span class="literal">false</span>)</span><br><span class="line">			deal(a[x].son[i],y+<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[x].sons;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[a[x].son[i]].shu)</span><br><span class="line">			deal(a[x].son[i],y+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("d:/shit.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		tot=<span class="number">0</span>; now=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			++now; </span><br><span class="line">			getstr(now);</span><br><span class="line">			<span class="keyword">if</span>(c==EOF)&#123;</span><br><span class="line">				--now;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strlen</span>(b[now].nm)&lt;=<span class="number">2</span>&amp;&amp;b[now].nm[<span class="number">0</span>]==<span class="string">'0'</span>)&#123;</span><br><span class="line">				--now;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=now;i++)&#123;</span><br><span class="line">			ins(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		id++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,id);</span><br><span class="line">		deal(<span class="number">0</span>,<span class="number">-4</span>);</span><br><span class="line">		<span class="keyword">if</span>(c!=<span class="string">'\n'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 .NET Core 项目中添加 WCF Service]]></title>
      <url>https://HaleLu.github.io/2016/07/How-to-Add-Net-Service-in-NET-Core/</url>
      <content type="html"><![CDATA[<h2 id="What-is-Web-Service"><a href="#What-is-Web-Service" class="headerlink" title="What is Web Service?"></a>What is Web Service?</h2><p>微软的 ASP.NET Web Service 是一套基于XML扩展标记语言，使用Soap简单对象访问协议实现的网络数据交互服务。它使用 WSDL 来描述服务相关的接口。<br>ASP.NET Web Service 必须依赖于 IIS，是一种无状态的通讯协议。</p>
<a id="more"></a>

<h2 id="Why-WCF"><a href="#Why-WCF" class="headerlink" title="Why WCF?"></a>Why WCF?</h2><p>从某种程度上来说，Web Service 是 WCF（Windows Communication Foundation）的子集，它支持 Web Service 的所有标准。当然它不仅仅支持 Web Service，它是微软为整合.NET平台下所有的和分布式系统有关的技术而创建的统一框架。<br>WCF 相对 Web Service 的优势很多，不在此一一举例。<br>在 .NET Core 的正式版中，大概是由于跨平台的需要，微软抛弃了 Web Service，所以我们只能用 WCF 来添加网络服务。</p>
<h2 id="How-to"><a href="#How-to" class="headerlink" title="How to?"></a>How to?</h2><p>首先可以在<a href="https://visualstudiogallery.msdn.microsoft.com/c3b3666e-a928-4136-9346-22e30c949c08" target="_blank" rel="noopener">这里</a>下载安装 Visual Studio WCF Connected Service 的扩展。<br>其次，创建一个 .NET Core 项目（以类库项目为例）。<br><img src="http://halelu.github.io/2016/07/How-to-Add-Net-Service-in-NET-Core/Picture-1.png" alt><br>在项目中添加 WCF 服务：<br><img src="http://halelu.github.io/2016/07/How-to-Add-Net-Service-in-NET-Core/Picture-2.png" alt><br><img src="http://halelu.github.io/2016/07/How-to-Add-Net-Service-in-NET-Core/Picture-3.png" alt><br>添加对应的 Webservice.asmx，修改相关参数（其实只要改名字就好），一路 next 然后 Finish：<br><img src="http://halelu.github.io/2016/07/How-to-Add-Net-Service-in-NET-Core/Picture-4.png" alt><br>对应的 Web Service 就添加成功了~</p>
<h2 id="参考来自"><a href="#参考来自" class="headerlink" title="参考来自"></a>参考来自</h2><p><a href="https://blogs.msdn.microsoft.com/webdev/2016/05/25/announcing-wcf-connected-service-for-net-core-rc2-and-asp-net-core-rc2/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/webdev/2016/05/25/announcing-wcf-connected-service-for-net-core-rc2-and-asp-net-core-rc2/</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 技术 </tag>
            
            <tag> WCF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[聊聊 .NET Core]]></title>
      <url>https://HaleLu.github.io/2016/07/Intro-to-Dotnet-Core/</url>
      <content type="html"><![CDATA[<h2 id="关于-NET-Core"><a href="#关于-NET-Core" class="headerlink" title="关于 .NET Core"></a>关于 .NET Core</h2><p>.NET Core 的正式版终于发布了。.NET Core 是一个<a href="https://github.com/dotnet" target="_blank" rel="noopener">开源项目</a>。根据官方的说法，.NET Core 是跨平台的（当然它的确是跨平台的）。<br>我们常说的 .NET 通常指的是.NET Framework，通常只运行于 Windows。两者的关系用官方的图来表示就是这样：<br><img src="http://halelu.github.io/2016/07/Intro-to-Dotnet-Core/Picture-1.png" alt><br>他们有一个共同的子集。</p>
<p>恩，据说这玩意以后还要收费？不知道是不是我理解错了。要是我理解错了求英语好的来给我解释一下。原文如下：</p>
<blockquote>
<p>Finally, .NET Core will be “pay-for-play” and performant. One goal of the .NET Core effort is to make the cost of abstraction clear to developers, by implementing a pay-for-play model that makes obvious the costs that come from employing a higher-level abstraction to solve a problem. Abstractions don’t come for free, and that truth should never be hidden from developers. Additionally, .NET Core will favor performance with a standard library that minimizes allocations and the overall memory footprint of your system.</p>
</blockquote>
<a id="more"></a>

<h2 id="NET-CLI"><a href="#NET-CLI" class="headerlink" title=".NET CLI"></a>.NET CLI</h2><p>.NET Core 提供了 .NET CLI（Command Line Interface），可以通过命令行来完成程序的编译，相关命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dotnet new</td>
<td>使用 C# 语言初始化用于类库或控制台应用程序的有效项目。</td>
</tr>
<tr>
<td>dotnet restore</td>
<td>还原在指定项目的 project.json 文件中定义的依赖项。依赖项通常是您在应用程序中使用的 NuGet 包。</td>
</tr>
<tr>
<td>dotnet build</td>
<td>生成您的代码！ 此命令将生成适用于您的项目的中间语言 (IL) 二进制。如果项目是控制台应用程序，则产生的输出是可执行的，您可以立即运行。默认情况下，生成命令会将生成的程序集和可执行文件（如果适用）输出到调用位置目录的 bin 目录中。</td>
</tr>
<tr>
<td>dotnet test</td>
<td>如果不支持运行测试，则不会出现适合的工具。此命令让您可以使用在 project.json 文件中指定的运行程序运行一组测试。目前支持 xUnit 和 NUnit 测试运行程序。</td>
</tr>
<tr>
<td>dotnet publish</td>
<td>发布在目标计算机上运行的应用程序。</td>
</tr>
<tr>
<td>dotnet pack</td>
<td>pack 命令会把您的项目打包成 NuGet 包。输出一组 nupkg 文件后，您可以将其上载至您的源，或使用本地文件夹替代将其用于还原操作。</td>
</tr>
<tr>
<td>dotnet run</td>
<td>运行命令将编译并运行您的应用程序。您可以将其看作没有 Visual Studio 的 Ctrl+F5 模拟。</td>
</tr>
</tbody></table>
<p>.NET Core 依赖 NuGet 提供的各种包。开发者也可以把自己的类库打包成 NuGet 包共享到 <a href="https://www.nuget.org/" target="_blank" rel="noopener">NuGet</a>。</p>
<h2 id="参考来自"><a href="#参考来自" class="headerlink" title="参考来自"></a>参考来自</h2><p><a href="https://msdn.microsoft.com/en-us/magazine/mt694084.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/magazine/mt694084.aspx</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生活笔记（2016-07-18）]]></title>
      <url>https://HaleLu.github.io/2016/07/Note-4/</url>
      <content type="html"><![CDATA[<p>好久没有更新了，再不写点什么就真的要忘了这块地方。</p>
<a id="more"></a>

<h2 id="照例的絮絮叨叨"><a href="#照例的絮絮叨叨" class="headerlink" title="照例的絮絮叨叨"></a>照例的絮絮叨叨</h2><p>一不小心，竟然都大三了，这些天看着新生群里陆续加进来的心生们，想到自己已经大三了，不禁有点恍惚。又想起那句，去年我大一，明年我就大四了，一阵心慌。<br>感觉自己还很弱，感觉自己还有很多想做，感觉自己还有好多好多想要在进入社会之前完成的事情都还没用做。</p>
<p>真的好心慌。</p>
<p>时间根本不够用啊摔！</p>
<h2 id="算是这段时间的-summary-吧"><a href="#算是这段时间的-summary-吧" class="headerlink" title="算是这段时间的 summary 吧"></a>算是这段时间的 summary 吧</h2><p>上次比完蓝桥杯是想写一份题解来着，然而奈何下笔什么都不会。好像从那之后就再也没有更新了。</p>
<p>期末倒是挺忙，各种整理、复习、预习，偶尔还穿插一点比赛什么的。<br>一不小心错过了暑期国际课程的选课。</p>
<p>假期来了<a href="http://www.carvedge.com/" target="_blank" rel="noopener">开悦科技</a>这边实习，写写东西，学习学习。主要是做做 .NET，挣点学费。<br>这些天学到的东西尽量整理出来。</p>
<p>7 月 9-10 日参加了一个全国大学生信息安全的 CTF 比赛，抱着队友的大腿进了决赛。只是很水的帮队友做了一道签到题，还有做了一半的破译，最后队友全转大写过掉了，也算是 2333。<br>其他的都是胡乱折腾了好久，其实也没有帮到太大忙。（<a href="http://halelu.github.io/2016/07/Note-4/writeup.docx">这里有本队 WriteUp</a>，<a href="http://mp.weixin.qq.com/s?__biz=MzI0NjQxODg0Ng==&mid=2247484044&idx=1&sn=96cfca9bb1ec03572c990ac3d913c59e&scene=23&srcid=0711ufe4EQMnjSTzL2jQWCOK#rd" target="_blank" rel="noopener">这是官方题解</a>）  
最后还能混个 i 春秋的 VIP，其实这波也不亏。</p>
<p>7 月 16-17 日去打了一场中国高校计算机大赛-团体程序设计天梯赛，然叔看的起，放在了一队。然而成绩不忍直视。说真我都不好意思提。</p>
<p>希望自己加油吧。</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Something About TSP (1)]]></title>
      <url>https://HaleLu.github.io/2016/05/Something-About-TSP-1/</url>
      <content type="html"><![CDATA[<h2 id="旅行商问题（traveling-salesman-problem）"><a href="#旅行商问题（traveling-salesman-problem）" class="headerlink" title="旅行商问题（traveling-salesman problem）"></a>旅行商问题（traveling-salesman problem）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>通常我们讨论的都是对称旅行商问题（SYMMETRIC traveling-salesman problem），即距离矩阵保持对称（A 到 B 与 B 到 A 距离相等）。<br>严格意义上的旅行商问题的要求是：遍历所有点，保证每个点刚好访问一次，求最短的遍历路径。</p>
<a id="more"></a>

<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>解决这种问题的算法分为两种：精确算法（Exact algorithms）和启发式方法（heuristic methods）。<br>精确算法的复杂度过高（n的指数级），短时间可解决的问题约在60个点（1971）。<br>一般采用启发式方法去解决能得到一个相对满意的结果。</p>
<p>解决这个问题的灵感来自于另一个问题：图分割问题。<br>问题描述很简单：将图分为两个点的个数相同的部分，并满足两个部分间的距离最短。</p>
<p>我们可以将这两个问题抽象成同一种问题：<br>从集合 S 中寻找满足限制条件 C 并能使目标函数 f 最小化的子集 T 。</p>
<p>接下来，我们就可以将启发式算法的思路总结出来：</p>
<ul>
<li>找到一个可行解，即一个满足条件 C 的子集 T</li>
<li>尝试在 T 上做一些改变，寻找比 T 更优（能使得 f 更小）的子集 T’</li>
<li>如果找到子集 T’ 更优（使得 f(T’) &lt; f(T) ），用 T’ 替换 T 并重复上一</li>
<li>如果找不到，T 就是局部最优解。再次重复第一步直到时间到某一上限或答案已经足够满意。</li>
</ul>
<p>在 TSP 问题中，这个问题的具体化就是：</p>
<ul>
<li>从所有边构成的集合 S 中找出一个可行回路 T</li>
<li>每次从 T 中找出 k 条边，从 S-T 中找出另外的 k 条边，保证这 k 条边交换后能形成回路且费用更小</li>
<li>如果找到则进行交换</li>
<li>如果找不到，则 T 就是局部最优解。再次重复直到时间到达某一上限或答案足够满意</li>
</ul>
<h3 id="启发式算法的核心"><a href="#启发式算法的核心" class="headerlink" title="启发式算法的核心"></a>启发式算法的核心</h3><p>这种算法好坏主要看两点：</p>
<ul>
<li>第一步中找到的初始解的好坏</li>
<li>第二步中的替换算法的好坏</li>
</ul>
<p>KL算法重点关注第二个点。  </p>
<p>第二步中有一个难题，是 k 的值具体应该取多少？  </p>
<p>如果遍历 k 那无疑是一件很恐怖的事，所以我们尝试用一些方法：</p>
<ul>
<li>生成随机初始解 T<ul>
<li>令 i = 1</li>
<li>选择第 i 步的“最不合适”对：xi 和 yi，使得 {x1, x2, …… , xi} 和 {y1, y2, …… , yi} 交换后缩短的距离值最大<em>（具体原则在下面给出）</em></li>
<li>如果找不到不合适对，则进入下一步，否则重复本步骤</li>
</ul>
</li>
<li>如果一个更优解已经找到，则将 x 和 y 两个集合交换，得到新的 T，重复上一步骤；若找不到更优解，则进入下一步</li>
<li>如果需要的话重复第一步</li>
</ul>
<p>那我们采用怎样的方法去找“最不合适”对呢？<br>首先，我们要保证每次交换后都能得到一个可行的交换，所以我们保证 x1、y1、x2、y2 …… 依次首尾相连（且 yn 最后一个节点为 x1 的第一个节点），如下图所示：<br><img src="http://halelu.github.io/2016/05/Something-About-TSP-1/Figure-1.png" alt></p>
<p>其次，假设 gi 表示 xi 与 yi 交换后减少的代价，那么我们不必在某一个 gi 为负数时立刻停止，我们只在 g1+g2+……+gi ≤ 0 时认为找不到“不合适”对。</p>
<p>当然，我们要保证不重新选取被去掉的边。</p>
<h2 id="Kernighan-Lin-算法"><a href="#Kernighan-Lin-算法" class="headerlink" title="Kernighan-Lin 算法"></a>Kernighan-Lin 算法</h2><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h3><ul>
<li>Step 1: 生成随机回路 T</li>
<li>Step 2: 令 G* = 0，任选一个点 t1 作为起始点，从 t1 出发选取回路 T 中的一条边 x1 ，假设另一端为 t2，令 i = 1 </li>
<li>Step 3: 从 t2 出发，选取任一不在 T 中的边 y1，假设另一端为 t3，满足 g1 &gt; 0 。若不存在这样的 y1，则跳至 Step 6 (d)</li>
<li>Step 4: 令 i = i + 1，选择 xi （T 中以 t(2i-1) 为出发点的路径）和 yi，具体说明如下：<ul>
<li>(a) 若 xi 连接的是 t(2i) 和 t1 ，则完成一次查找</li>
<li>(b) yi 应当从 t(2i) 出发；若没有可行边，则跳转至 Step 5（显然，我们优先考虑最近的点）</li>
<li>(c) x 和 y 不能有交集</li>
<li>(d) G &gt; 0</li>
<li>(e) yi 的选择应保证 t(2i+1) 在 T 中有其他邻接点</li>
<li>(f) 在选定 yi 前，我们观察是否连接 t(2i) 和 t1 比选择的 yi 是更好的选择（费用减少更多）。令 yi* 表示边 ( t(2i), t1 )，gi* = |xi| - |yi*| 。若 G(i-1) + gi* &gt; G* 则更新 G* 的值为 G(i-1) + gi* 并记 i 为 k。</li>
</ul>
</li>
<li>Step 5: 当找不到 xi 和 yi 满足 4(c)-(e) 或 Gi ≤ G* 时，结束上一循环。若 G* &gt; 0，更新 T’ ，且 f(T’) = f(T) - G*。以 T’ 为初始回路重复从 Step 2 开始的这一过程。 </li>
<li>Step 6: 如果 G* = 0，按下列方式处理：<ul>
<li>(a) 重复 Step 4 和 5，按升序选择满足 g1 + g2 &gt; 0 的 y2 ，跳回 Step 2 </li>
<li>(b) 如果 Step 4 (b) 中所有 y2 的选项都使得 G 为负，则返回 Step 4 (a) 尝试选择另一个 x2</li>
<li>(c) 如果仍然无法得到解，跳至 Step 3，按升序找新的 y1</li>
<li>(d) 如果找不到合适的 y1，跳至 Step 2，尝试另一条 x1</li>
<li>(e) 如果仍然失败，跳回 Step 2，重新选择 t1</li>
</ul>
</li>
</ul>
<p>生成的最终路径：<br><img src="http://halelu.github.io/2016/05/Something-About-TSP-1/Figure-3.png" alt></p>
<h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><h4 id="避免校验时间（Avoiding-Checkout-Time）"><a href="#避免校验时间（Avoiding-Checkout-Time）" class="headerlink" title="避免校验时间（Avoiding Checkout Time）"></a>避免校验时间（Avoiding Checkout Time）</h4><p>如果回路 T 无法再次被改进，则 T 是一个局部最优解。当下次再次得到回路 T 时，避免再次检验。<br>可节约 30-50% 的运行时间。</p>
<h4 id="预测（Lookahead）"><a href="#预测（Lookahead）" class="headerlink" title="预测（Lookahead）"></a>预测（Lookahead）</h4><p>为避免出现选择的 yi 使得 x(i+1) 太小最终导致无用的搜索，在选择 yi 时选择使得 |x(i+1)|-|yi| 最大的 yi。</p>
<h4 id="减少重复搜索（Reduction）"><a href="#减少重复搜索（Reduction）" class="headerlink" title="减少重复搜索（Reduction）"></a>减少重复搜索（Reduction）</h4><p>因为很多时候，大部分重要的优化都是相同的，所以我们在找出至少两个局部最优解后，求这些最优解的交集，并以这些边作为初始回路的一部分。<br>数据测试发现，两个普通的局部最优解有 85% 是相似的，甚至 7-8 个最优解也有 60-80% 是相似的。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>无法进行不连续交换。<br>e.g.:<br><img src="http://halelu.github.io/2016/05/Something-About-TSP-1/Figure-2.png" alt></p>
<h3 id="初始随机解的生成优化"><a href="#初始随机解的生成优化" class="headerlink" title="初始随机解的生成优化"></a>初始随机解的生成优化</h3><p>根据初始随机解的生成方式的不同，衍生出不同的方法，其中包括：</p>
<ul>
<li>最近插入法(nearest insertion，NI)</li>
<li>凸包法（connex hull insertion，CHI)</li>
<li>最远插入法(farthest insertion，FI)</li>
<li>最邻近法(nearest neighbor algorithm，NN)</li>
<li>节约算法（clark wright algorithm，CW)</li>
<li>贪婪算法（greedy algorithm，GA)</li>
<li>最小双生树法（double spanning tree，DST)<br>部分算法性能如下：<br><img src="http://halelu.github.io/2016/05/Something-About-TSP-1/Figure-4.png" alt><br><img src="http://halelu.github.io/2016/05/Something-About-TSP-1/Figure-5.png" alt></li>
</ul>
<h2 id="论文来自"><a href="#论文来自" class="headerlink" title="论文来自"></a>论文来自</h2><p><em>An Effective Heuristic Algorithm for the Traveling-Salesman Problem</em><br>　　—— S. Lin and B. W. Kernighan<br><em>Lin-Kernighan 算法初始解的启发式构造策略</em><br>　　—— 曾华，崔文，付连宁，吴耀华</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 旅行商问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈最长公共子序列算法及其优化（2）]]></title>
      <url>https://HaleLu.github.io/2016/05/Something-About-Longest-Common-Subsequences-2/</url>
      <content type="html"><![CDATA[<p>这一篇是队友所看的论文，稍作整理。</p>
<p><a href="https://hzlclock.wordpress.com/2016/05/15/lcs-algorithm-that-consumes-liner-space/" target="_blank" rel="noopener">想看他做的PPT可以戳这里</a></p>
<a id="more"></a>

<h2 id="空间压缩"><a href="#空间压缩" class="headerlink" title="空间压缩"></a>空间压缩</h2><p>首先纠正上一篇中的一处错误，空间可以压缩到 O(n) ，然而同时就意味着不能得到具体序列。当不在乎具体序列时可以简单使用对 i 模2的方法压缩空间。<br>此文提供了一种方法在不提高复杂度的前提下压缩空间并能回求序列的方案。</p>
<h2 id="不回求序列的压缩法"><a href="#不回求序列的压缩法" class="headerlink" title="不回求序列的压缩法"></a>不回求序列的压缩法</h2><p>将上一篇所提到的 f[0..n][0..m] 中的第一维用 i mod 2 替换，则只有0和1，然而不影响正确性。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>将 A 二分，用不回求序列的压缩法求 A[0..n/2] 和 B[0..m] 的公共子序列长度，将所有的 f[(n/2)%2][0..m] 的值（共 m+1 个）保存为 L1[0..m]。<br>同理，将 A[n/2+1..n] 和 B[0..m] 倒序后得到长度 L2[m..0]。<br>找到 B 数组的中间值 k ，使得 L1[k]+L2[n-k] 取得最大值。<br>那么我们就知道了，用 A[0..n/2] 和 B[0..k] 匹配，A[n/2+1..n] 和 B[k+1..m] 匹配便可得到最长的公共子序列。<br>那我们递归处理A[0..n/2] 和 B[0..k] 以及 A[n/2+1..n] 和 B[k+1..m] 的匹配就可以得到最终字符串了。</p>
<p>当然，递归的最后需要特判 A 序列长度为0和1的情况。</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="http://halelu.github.io/2016/05/Something-About-Longest-Common-Subsequences-2/Figure-1.png" alt><br><em>注：ALG B指的是</em>上文所说的 i mod 2 的压缩空间的方法。</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>显然空间只有O(m)；<br>时间略微有些复杂。用了两次 <em>不回求序列的压缩法</em> ，复杂度为 O(mn)，然而每次递归复杂度递减为上一次的一半，求和后可以知道总复杂度只有O(2mn)，常数不看，即O(mn).</p>
<h2 id="论文来自"><a href="#论文来自" class="headerlink" title="论文来自"></a>论文来自</h2><p><em>A Liner Space Algorithm for Computing Maximal Common Subsequences</em><br>　　—— D.S. Hirschberg (Princeton University)</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生活笔记（2016-05-15）]]></title>
      <url>https://HaleLu.github.io/2016/05/Note-2/</url>
      <content type="html"><![CDATA[<p>算是定期汇报一下工作吧。</p>
<a id="more"></a>

<h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p>结掉了几门课，停掉了几门课。现在还上着的基本就是英语和计组了。<br>计组这些天在做 MIPS ，挺有意思的。博客的其他文章也有提到在做的这件事。<br>算法研讨下周一要讲DP，刚整理了一篇论文。今天晚上必须搞懂另一篇并做好 PPT。</p>
<h2 id="辩论"><a href="#辩论" class="headerlink" title="辩论"></a>辩论</h2><p>算是结掉了一份工作，虽然似乎没有做到很好。以后的锅可能就甩给学弟了。</p>
<h2 id="科创"><a href="#科创" class="headerlink" title="科创"></a>科创</h2><p>又是一拖再拖下来了。得抓紧时间赶工了，中期检查快到了。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这两天终于差（bing）不（mei）多（you）补完了上周的 <a href="http://halelu.github.io/2016/05/JSCPC-2016-Note/">解题报告</a>。还差 spfa 和 莫比乌斯函数 的坑，接下来接着填。</p>
<h2 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h2><p>下午会打一个很奇葩的天梯赛。下下周末可能要出去打蓝桥，可是好像和算法考试重了。<br>报了一个信息安全竞赛，也是这两天。真的想弃了蓝桥杯了。<br>万一真的去实习没法来补考岂不是很尴尬？</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>选课系统的万年老坑啊啊啊啊啊啊啊啊。<br>看样子我要接一口大锅啦啊啊啊啊啊啊啊。<br>好吧接下来又要开始动工了，争取学期结束前完工。</p>
<h2 id="絮絮叨叨"><a href="#絮絮叨叨" class="headerlink" title="絮絮叨叨"></a>絮絮叨叨</h2><p>日子过得越来越充实。<br>祝自己越来越优秀吖~  </p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MIPS处理器设计（1）：支持9条指令的单周期处理器]]></title>
      <url>https://HaleLu.github.io/2016/05/MIPS-1/</url>
      <content type="html"><![CDATA[<p>这两天写完了一个 MIPS 的支持9条指令的单周期处理器。</p>
<a id="more"></a>

<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>单周期的 Mips 处理器<br>只支持 add、sub、and、or、lw、sw、slt、beq、j 这9条指令  </p>
<h2 id="开发语言、工具和环境"><a href="#开发语言、工具和环境" class="headerlink" title="开发语言、工具和环境"></a>开发语言、工具和环境</h2><p>采用 Verilog 语言开发<br>Window 10 环境下<br>使用了 Sublime Text + ModelSim 的方式进行开发（ModelSim 自带的编辑器真的难用一个tab竟然是8个空格啊啊啊啊啊）</p>
<h2 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h2><p>具体分为两大部分和处理器部分</p>
<h3 id="datapath（数据通路）"><a href="#datapath（数据通路）" class="headerlink" title="datapath（数据通路）"></a>datapath（数据通路）</h3><p>定义了各种元部件</p>
<h4 id="alu-v"><a href="#alu-v" class="headerlink" title="alu.v"></a>alu.v</h4><p>模块名：alu<br>说明：算逻部件<br>输入接口：op（4位，运算符编码）, a, b（32位，运算数）<br>输出接口：zero（结果是否为0）, dout（32位，运算结果）<br>op的说明：<br>　　0010： dout = a + b<br>　　0110： dout = a - b<br>　　0001： dout = a | b<br>　　0000： dout = a &amp; b<br>　　0111： dout = a &lt; b ? 1 : 0</p>
<h4 id="dm-v"><a href="#dm-v" class="headerlink" title="dm.v"></a>dm.v</h4><p>模块名：dm_4k<br>说明：数据寄存器，大小为4k（时钟上升沿触发）<br>输入接口：addr（10位，数据地址）, din（32位，写数据时的数据端）, we（写数据使能端）, re（读数据使能端）, clk（时钟端）<br>输出接口：dout（32位，读数据时的数据输出端）  </p>
<h4 id="ext-v"><a href="#ext-v" class="headerlink" title="ext.v"></a>ext.v</h4><p>模块名：ext<br>说明：符号扩展部件（W 表示输入数据宽度）<br>输入接口：din（W 位）<br>输出接口：dout（32位）  </p>
<h4 id="im-v"><a href="#im-v" class="headerlink" title="im.v"></a>im.v</h4><p>模块名：im_4k<br>说明：指令存储器，大小为4k<br>输入接口：addr（10位，运算符编码）<br>输出接口：dout（32位，对应指令）  </p>
<h4 id="mux-v"><a href="#mux-v" class="headerlink" title="mux.v"></a>mux.v</h4><p>模块名：mux2<br>说明：二路选择器（W 表示输入数据宽度）<br>输入接口：a, b（W 位，表示0和1对应的数据源）, s（选择信号）<br>输出接口：dout（W 位，选择结果）  </p>
<h4 id="pc-v"><a href="#pc-v" class="headerlink" title="pc.v"></a>pc.v</h4><p>模块名：pc<br>说明：程序计数器（时钟上升沿触发）<br>输入接口：clk（时钟端）, rst（重置信号）, data（32位，下一指令地址）<br>输出接口：dout（32位，当前指令地址）  </p>
<h4 id="regheap-v"><a href="#regheap-v" class="headerlink" title="regheap.v"></a>regheap.v</h4><p>模块名：regheap<br>说明：寄存器堆（时钟上升沿触发）<br>输入接口：clk（时钟端）, we（写寄存器使能端）, rreg1（5位，读寄存器1地址）, rreg2（5位，读寄存器2地址）, wreg（5位，写寄存器的地址）, wdata（写入寄存器的数据）<br>输出接口：rdata1（32位，读寄存器1的数据）, rdata2（32位，读寄存器2的数据）<br>另：有部分为方便测试而添加的初始化寄存器的值的代码。  </p>
<h3 id="control（控制信号）"><a href="#control（控制信号）" class="headerlink" title="control（控制信号）"></a>control（控制信号）</h3><p>解析指令，生成对应的控制信号</p>
<h4 id="ALUctrl-v"><a href="#ALUctrl-v" class="headerlink" title="ALUctrl.v"></a>ALUctrl.v</h4><p>模块名：ALUctrl<br>说明：算逻部件控制器<br>输入接口：ALUOp（2位）, funct（6位，指令的5-0位）<br>输出接口：op（4位，对应的 alu 运算符编码）</p>
<h4 id="ctrl-v"><a href="#ctrl-v" class="headerlink" title="ctrl.v"></a>ctrl.v</h4><p>模块名：ctrl<br>说明：算逻部件控制器<br>输入接口：op（6位，指令的31-26位）<br>输出接口：RegDst, RegWrite, ALUSrc, MemRead, MemWrite, MemtoReg, Jump, Branch, ALUOp（各种控制信号，其中 ALUOp 为2位）</p>
<h3 id="mips-v（处理器部分）"><a href="#mips-v（处理器部分）" class="headerlink" title="mips.v（处理器部分）"></a>mips.v（处理器部分）</h3><p>模块名：mips<br>说明：单周期处理器（时钟上升沿触发）<br>输入接口：clk（时钟端）, rst（重置信号）  </p>
<h3 id="testbench-v（测试代码）"><a href="#testbench-v（测试代码）" class="headerlink" title="testbench.v（测试代码）"></a>testbench.v（测试代码）</h3><p>模块名：testbench<br>说明：生成时钟信号测试部件可行性  </p>
<p><a href="https://github.com/HaleLu/mips" target="_blank" rel="noopener">详见 Github</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MIPS </tag>
            
            <tag> Verilog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈最长公共子序列算法及其优化（1）]]></title>
      <url>https://HaleLu.github.io/2016/05/Something-About-Longest-Common-Subsequences-1/</url>
      <content type="html"><![CDATA[<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="基本算法描述"><a href="#基本算法描述" class="headerlink" title="基本算法描述"></a>基本算法描述</h3><p>最长公共子序列（LCS）问题是一种经典的动态规划（DP）问题。</p>
<a id="more"></a>

<p>假设两个序列为 s1 和 s2 （假设下标从 0 开始），原先我们的算法是用 f[i][j] 表示 s1[1..i] 和 s2[1..j] 的最长公共子序列长度。<br>那么，我们可以得到状态转移方程：  </p>
<p>f[i][j] = max{f[i-1][j], f[i][j-1]) (i&gt;0 &amp;&amp; j&gt;0 &amp;&amp; s1[i] != s2[j])<br>f[i][j] = max{f[i-1][j], f[i][j-1], f[i-1][j-1] + 1} (i&gt;0 &amp;&amp; j&gt;0 &amp;&amp; s1[i] == s2[j])<br>f[i][j] = 0 (i==0 || j==0)</p>
<p>递推即可得到答案。</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>假设两个序列长度分别为 n 和 m ，则原算法的时间复杂度显然可见是 O(n·m) 的。<br>空间复杂度上由于开了一个 f[0..n][0..m] 的数组，所以复杂度也是 O(n·m) 的。<br>当然，由于每一维度的 f 数组只和上一维度有关，所以空间复杂度可以压缩到 O(m) 。<em>(此处的分析有误，在下一文中对空间压缩的方法给出了具体讨论)</em></p>
<h2 id="一种新思路"><a href="#一种新思路" class="headerlink" title="一种新思路"></a>一种新思路</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>定义一种阈值数组 T[0..n][0..n]，T[i][k] 表示在序列 s2 中匹配 s1[1..i]，寻找到 k 项匹配的最小下标值。<br>换句话说，即满足 s1[1..i] 和 s2[1..j] 有 k 项匹配的最小 j 值。</p>
<p>e.g.:<br>s1 = “abcbdda”<br>s2 = “badbabd”<br>则 T[5,1] 表示在 s2 中找到能与 s1[1..5] 公共子序列长度为1的最小下标。显然第一个即可满足，所以 T[5,1] = 1 。<br>同理，T[5,2] = 3，T[5,3] = 6，T[5,4] = 7，T[5,5] = ∞ 。  </p>
<p>显然，数组 T 在第二维上是递增的。且 T[i][k-1] &lt; T[i+1][k] ≤ T[i][k] 。<br>则可得递推方程：  </p>
<p><code>T[i+1][k] = min{j} (s1[i+1]==s2[j] &amp;&amp; T[i][k-1] &lt; j ≤ T[i][k])</code><br><code>T[i+1][k] = T[i][k] (不存在上述条件的 j 时)</code></p>
<p>算法正确性在此不做证明。</p>
<p>据此我们找到最后一列中满足 T[n][k] != ∞ 的最大 k 值即为 LCS 答案。<br>对应的算法伪代码：<br><img src="http://halelu.github.io/2016/05/Something-About-Longest-Common-Subsequences-1/Figure-1.png" alt></p>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>此时的时间复杂度为O((n^2)log n)，空间复杂度一样是可以压缩到 O(n)。</p>
<h2 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h2><h3 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h3><p>建立一个匹配表，事先将 s1 数组中的元素去和 s2 进行匹配，得到匹配表。</p>
<p>e.g.:<br>s1 = “abcbdda”<br>s2 = “badbabd”</p>
<p>则对应匹配表为：<br>MATCHLIST[1] = &lt;5,2&gt;<br>MATCHLIST[2] = &lt;6,4,1&gt;<br>MATCHLIST[3] = &lt;&gt;<br>MATCHLIST[4] = MATCHLIST[2]<br>MATCHLIST[5] = &lt;7,3&gt;<br>MATCHLIST[6] = MATCHLIST[5]<br>MATCHLIST[7] = MATCHLIST[1]  </p>
<p>对应的算法伪代码：<br><img src="http://halelu.github.io/2016/05/Something-About-Longest-Common-Subsequences-1/Figure-2.png" alt></p>
<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>时间复杂度 O((r+n)log n) （ n 表示字符串长度，r 表示两个字符串间能匹配的次数），最坏复杂度为 O(n^2 log n)。<br>空间复杂度 O(r+n)。<br>具体分析如下：</p>
<h4 id="Step-1：整理匹配表"><a href="#Step-1：整理匹配表" class="headerlink" title="Step 1：整理匹配表"></a>Step 1：整理匹配表</h4><p>　　可使用带序号的排序。时间复杂度 O(nlog n)，空间复杂度 O(n)。</p>
<h4 id="Step-2：初始化"><a href="#Step-2：初始化" class="headerlink" title="Step 2：初始化"></a>Step 2：初始化</h4><p>　　时间：O(n)</p>
<h4 id="Step-3：比较和匹配"><a href="#Step-3：比较和匹配" class="headerlink" title="Step 3：比较和匹配"></a>Step 3：比较和匹配</h4><p>　　时间：O(n + rlog n)</p>
<h4 id="Step-4-倒序恢复最长子序列"><a href="#Step-4-倒序恢复最长子序列" class="headerlink" title="Step 4: 倒序恢复最长子序列"></a>Step 4: 倒序恢复最长子序列</h4><p>　　时间：最坏 O(n)，空间：O(r)</p>
<h2 id="论文来自"><a href="#论文来自" class="headerlink" title="论文来自"></a>论文来自</h2><p><em>A Fast Algorithm for Computer Longest Common Subsequences</em><br>　　—— James W.Hunt (Stanford University) &amp; Thomas G.Szymanski (Princeton University)</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ModelSim Student Edition 安装指南]]></title>
      <url>https://HaleLu.github.io/2016/05/Modelsim-Setup/</url>
      <content type="html"><![CDATA[<p>由于学习计算机组成与设计的课程需要，我们利用 ModelSim 来进行计算机的仿真设计。此文整理了安装的步骤与教训。</p>
<a id="more"></a>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先去<a href="https://www.mentor.com/products/fv/modelsim/" target="_blank" rel="noopener"> 官网 </a>找到 ModelSim ，正版太贵又不愿用盗版，所以我们使用 Student Edition 。</p>
<p>找到学生版的<a href="https://www.mentor.com/company/higher_ed/modelsim-student-edition" target="_blank" rel="noopener">链接：https://www.mentor.com/company/higher_ed/modelsim-student-edition</a>，找到 <a href="http://s3.mentor.com/fv/modelsim-pe_student_edition.exe" target="_blank" rel="noopener">Download Student Edition</a> 下载安装包（也可以戳这里）。</p>
<p>记得仔细阅读页面上的 Additional Information 。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完成后照着 .exe 文件的步骤安装，注意：</p>
<p><strong>安装路径中不可出现空格！</strong></p>
<p>别问我是怎么知道的。<br>血的教训！</p>
<p>安装完成后会弹出一个窗口，如果你仔细阅读了 Additional Information 应该就知道了，我们需要在这个页面中填写个人信息和邮箱，申请一个 license 文件。</p>
<p>要注意有些邮箱会过滤国外信件，避免使用（比如我航）。</p>
<p>填写完成后，过一会（大概 5 min）你会收到一个邮件，把邮件的附件（一个 .dat 文件）复制进你的安装目录。<br>完成~</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ModelSim </tag>
            
            <tag> 计算机组成与设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSCPC 2016 赛后笔记]]></title>
      <url>https://HaleLu.github.io/2016/05/JSCPC-2016-Note/</url>
      <content type="html"><![CDATA[<p>今天参加了一场 JSCPC ，靠队友带飞了。为了今后可以不拖队友后腿，我决定写题解。</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>这是一道模拟题，翻译莫斯密码。<br>先是强行手打莫斯密码表（只含 ‘.’ 和 ‘-‘ ）<br>然后一个 ‘.’ 为一个 ‘=’ ；一个 ‘-‘ 转为 ‘===’；每两个符号间加一个 ‘.’；<br>然后每两个字母间加’…’；<br>每两个单词间加’…….’；<br>Over  </p>
<p>//代码过于繁琐并且没什么价值不再手打。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>n 个结点二叉树（ i 的子节点是 2i 和 2i+1 ）<br>求中序遍历的第 x 个值。（1 ≤ x ≤ n ≤ 10000）</p>
<p>由于 n 的范围不算大，所以强行中序就好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span>*r &lt;= n) deal(<span class="number">2</span>*r);</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">	x--;</span><br><span class="line">	<span class="keyword">if</span> (x==<span class="number">0</span>) &#123;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">		ans = r;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span>*r+<span class="number">1</span> &lt;= n) deal(<span class="number">2</span>*r+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> id=<span class="number">1</span>;id&lt;=T;id++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;x);</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		deal(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, id, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给 n （n ≤ 10）个格子涂色（颜色少于等于3种），如果考虑旋转对称可以涂多少种结果。（例如001和010和100算同一种）<br>由于数据量都不大（3^10 = 59049），所以考虑直接暴力。<br>扫一遍，如果这个数还没有被考虑过就轮换一圈做上标记，并结果数 +1 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="literal">false</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nn=k; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		nn *= k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nn;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!v[i]) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">int</span> ii=i;</span><br><span class="line">			v[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				ii = (ii%k)*(nn/k)+ii/k;</span><br><span class="line">				v[ii] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> id=<span class="number">1</span>;id&lt;=T;id++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">		deal();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, id, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>将四维的 1×1×1×2 的方块放进 2×2×4×n 四维空间（可旋转），问有多少种放置的方法。<br>暂时还是不会 QAQ  </p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>在 2×n 的网格里每次随机放置一个矩阵，问覆盖全图所需次数的数学期望。<br>同上  </p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>有 n 个人，每个人初始有 a[i]（1≤i≤n） 的钱，相互间通过给钱来似的所有人钱一样多，然而每次给钱需要交倍率为 k 的税（交易额 × k ），问最终每人最多多少钱。<br>我们队使用的是二分。<br>答案 ans 应该满足 (1-k)*∑(a[i]-ans)(1≤i≤n &amp;&amp; a[i]&gt;ans) == ∑(ans-a[i])(1≤i≤n &amp;&amp; ans&gt;a[i])</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans,k;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;<span class="number">0</span>? x:-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">double</span> s1=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> s2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]&gt;m) s1 += a[i] - m;</span><br><span class="line">		<span class="keyword">else</span> s2 += m - a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	s1 *= (<span class="number">1</span>-k);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">abs</span>(s1-s2) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">		ans = m;</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s1 &gt; s2)</span><br><span class="line">		deal(m,r);</span><br><span class="line">	<span class="keyword">else</span> deal(l,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> id=<span class="number">1</span>;id&lt;=T;id++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;k);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">		deal(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d: %lf\n"</span>, id, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>猜数游戏。 B 想一个数（1 到 n），A 猜对了可以从 B 那里赢1刀，如果 A 猜了 x 而 B 想的是 x+1 则 A 要支付1刀给 B 。<br>B 使用随机数发生器，同时 B 能决定每个数字的分布。而 A 知道 B 的决定，所以 A 会挑选一个获利期望最大的选择。<br>B 现在要将 A 的获利最小化，问最小化的 A 的获利期望是多少。</p>
<p>问题模型简化为：<br>∑(P[i]) = 1, 求 max{ P[i]-P[i+1] , P[n] } (1 ≤ i &lt; n) 的最小值。<br>记 <code>a[i]=P[i]-P[i+1](1 ≤ i &lt; n), a[n]=P[n]</code>，则有  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[1] + 2·a[2] + …… + (n-1)·a[n-1] + n·a[n] = 1,</span><br><span class="line">求： max&#123;a[i]&#125; (1 ≤ i ≤ n) 的最小值.</span><br></pre></td></tr></table></figure>

<p>显然取等号时有最小值，最小值为 2/(n·(n+1)).<br>所以输出2/(n·(n+1))即可。</p>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>给定 n 和 m ，求∑∑(i^2·j^2·gcd(i,j)) (1 ≤ i ≤ n, 1 ≤ j ≤ m).<br>要用到一个叫莫比乌斯函数的东西。暂时还没搞明白，搞清楚以后会在单独写一篇。</p>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>有两种公交线路，一种是每次2刀（A 类），一种是免费的（B 类）。给出所有线路和起点终点，求解出最小花费。<br>思路是将所有站点和线路相间建立无向图。若站点在线路上则连接站点和线路。若与 A 类线路连接，则边权为 1，若与 B 类线路连接则为 0.<br>然后一遍spfa过了。<br>代码再过两天补吧。</p>
<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p>这题真的是有意思，人肉机器学习。<br>题意大概是给了一段西班牙语，一段中文拼音，然后将会给一段 100 - 500 词的文本（从报纸、杂志上摘取），判断这段文本是什么语言（英语 / 西班牙语 / 拼音）。  </p>
<p>我们起初用一些 y、es 这样的单词来判断西班牙语；the、be 动词这些来判断英语，然而 WA 了。</p>
<p>队友后来开始统计词频，然而还是呵呵了。</p>
<p>最后的处理方式是：先查英文，出现特征词直接认定为 English；<br>接下来统计字长，出现长度大于6的单词认定不是中文拼音（拼音最长为6个字母）；<br>然后很诡异的作了一步判断首字母是不是元音字母的单词比例，大于 0.8 则断定为中文拼音（也不知道是不是这个操作起了效果我觉得不是然而队友这么写了并且过了那现在就无从得知了）；<br>接下来再用西班牙语特征词判断西班牙语；<br>还判断不出来就返回英文。<br>具体代码不写了，没什么意思。  </p>
<p>其实现在想想这个逻辑还是有问题的。但是不管怎么说，过了、拿到分了就行。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Intro]]></title>
      <url>https://HaleLu.github.io/2016/05/Android-Intro/</url>
      <content type="html"><![CDATA[<p>这是一个简单的 Android 开发入门介绍。</p>
<a id="more"></a>

<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>Android Studio (Eclipse)<br>我们这里使用 Android Studio.</p>
<h1 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h1><p>Android Studio<br>SDK </p>
<ul>
<li>Software Development Kit  </li>
<li>need use VPN</li>
</ul>
<p>Android Virtual Device  </p>
<ul>
<li>optional  </li>
<li>created with SDK</li>
</ul>
<p>Gradle </p>
<ul>
<li>auto download</li>
</ul>
<h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><h2 id="Gradle-Script"><a href="#Gradle-Script" class="headerlink" title="Gradle Script"></a>Gradle Script</h2><h3 id="build-gradle-Module-app"><a href="#build-gradle-Module-app" class="headerlink" title="build.gradle (Module:app)"></a>build.gradle (Module:app)</h3><p>此处保存主要的 app 支持的 Android 版本号。<br><code>compileSdkVersion</code> 指编译所用的 SDK 版本，一般要求高于 targetSdkVersion<br><code>minSdkVersion</code> 指支持的最小 SDK 版本<br><code>targetSdkVersion</code> 指目标SDK版本，即能保证支持的最高版本</p>
<h3 id="build-gradle-Project-ProjectName"><a href="#build-gradle-Project-ProjectName" class="headerlink" title="build.gradle (Project:ProjectName)"></a>build.gradle (Project:ProjectName)</h3><p><code>classpath</code> 表示使用的 gradle 版本，保存后自动下载，保持网络♂畅通。</p>
<h3 id="local-properties"><a href="#local-properties" class="headerlink" title="local.properties"></a>local.properties</h3><p><code>sdk.dir</code> 表示 SDK 的路径</p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>以 Gradle 2.1.0 为例：</p>
<h3 id="manifests"><a href="#manifests" class="headerlink" title="manifests"></a>manifests</h3><p>程序的各种声明</p>
<ul>
<li>声明程序包名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag"><span class="attr">package</span>=<span class="string">"com.example.companyName.packageName"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>申请权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.GET_ACCOUNTS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PROFILE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_CONTACTS"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Application 基本信息  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.NoTitleBar"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明 Activity 和 Service<br>放在 application 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"PackageName.ActivityName"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"PackageName.ServiceName"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>四大（五大）基本组件：</p>
<ul>
<li>Activity</li>
<li>Service</li>
<li>(Intend)</li>
<li>Content Provider</li>
<li>Broadcast Receiver</li>
</ul>
<p>App的程序，即逻辑代码，被放在不同的包中（类似 C# 中的 namespace ）  </p>
<p>所有的 Activity 均继承于 Activity 类，所有的 Service 均继承于 Service 类。 </p>
<p>事件驱动，通过 On动作 方法处理事件。</p>
<p>不同的 Activity 和 Service 之间通过 Intend 去连接。  </p>
<p>Activity 使用 setContentView 获取 res 中对应的界面文件来设置界面。  </p>
<p>使用 R 来获取 res 中的具体值。</p>
<h3 id="res"><a href="#res" class="headerlink" title="res"></a>res</h3><p>存放所有资源文件  </p>
<ul>
<li>drawable 图片的布局文件  </li>
<li>layout 界面的布局文件  </li>
<li>menu 菜单界面的布局文件  </li>
<li>mipmap 图片资源文件  </li>
<li>values 各种资源字符串等（通过 R 访问获取）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生活笔记（2016-05-06）]]></title>
      <url>https://HaleLu.github.io/2016/05/Note-1/</url>
      <content type="html"><![CDATA[<p>搞了个大新闻。 </p>
<a id="more"></a> 

<h3 id="CCF"><a href="#CCF" class="headerlink" title="CCF"></a>CCF</h3><p>真的是捡了个大便宜吧，莫名其妙就成了 CCF 南航学生分会的主席。  </p>
<p>一个学会的会旗竟然放在我的柜子里，想想真的是有一点不可思议。  </p>
<p>肩上的担子重啊。  </p>
<p>祝我这次真的能做好吧。  </p>
<p>顺便也重新思考了一下之后的路。开发？科研？好像又开始犹豫了。</p>
<h3 id="琐事"><a href="#琐事" class="headerlink" title="琐事"></a>琐事</h3><p>终于还是下定决心买了电池，断电后不能用电脑真的很麻烦。  </p>
<p>这几天事情其实还不算少，下周三的动态规划又该讲了，还有周二晚上要考概率论，周末还得给大一的讲 Android 。  </p>
<p>其他时间可能会好好复习刷题了。</p>
<p>祝我顺利。</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[EF 测试：不同对象的同一外键是否指向同一对象]]></title>
      <url>https://HaleLu.github.io/2016/05/Test-for-EF-Whether-Shared-Object-When-Having-the-Same-Foreign-Keys/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在一对多关系中，例如一个 Class 对多个 Student ，使用 ToList() 取出一个 List 的 Student 对象，<br>那么 List 中的 Student 对象外键对应的 Class 到底是各自独立，还是会共用一个对象？<br>那么分开取出的 Student 们对应的 Class 共用吗？<br>加上 AsNoTracking() 方法呢？</p>
<a id="more"></a>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><h3 id="model-定义"><a href="#model-定义" class="headerlink" title="model 定义"></a>model 定义</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; Students &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class Class &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DbContext-的继承和重写"><a href="#DbContext-的继承和重写" class="headerlink" title="DbContext 的继承和重写"></a>DbContext 的继承和重写</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppDbContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Class&gt; Classes &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Student&gt; Students &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        optionsBuilder.UseSqlServer(<span class="string">@"Server=(localdb)\mssqllocaldb;Database=EFGetStarted.ConsoleAppFortest.DbForTest;Trusted_Connection=True"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dbContext = <span class="keyword">new</span> AppDbContext();</span><br><span class="line">    dbContext.Database.EnsureCreated();</span><br><span class="line"></span><br><span class="line">    dbContext.Classes.RemoveRange(dbContext.Classes);</span><br><span class="line">    dbContext.Students.RemoveRange(dbContext.Students);</span><br><span class="line">    dbContext.SaveChanges();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> Class &#123; Number = <span class="string">"001"</span> &#125;;</span><br><span class="line">    c.Students.Add(<span class="keyword">new</span> Student()</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">"Hale Lu"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    c.Students.Add(<span class="keyword">new</span> Student()</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">"PM Extra"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dbContext.Classes.Add(c);</span><br><span class="line">    dbContext.SaveChanges();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"AsNoTracking:"</span>);</span><br><span class="line">    <span class="keyword">var</span> studentsAsNoTracking = dbContext.Students.Include(s =&gt; s.Class).AsNoTracking().ToList();</span><br><span class="line">    Console.WriteLine(<span class="string">"修改前："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[0].Class.Number = "</span> + studentsAsNoTracking[<span class="number">0</span>].Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[1].Class.Number = "</span> + studentsAsNoTracking[<span class="number">1</span>].Class.Number);</span><br><span class="line">    studentsAsNoTracking[<span class="number">0</span>].Class.Number = <span class="string">"002"</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">"修改后："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[0].Class.Number = "</span> + studentsAsNoTracking[<span class="number">0</span>].Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[1].Class.Number = "</span> + studentsAsNoTracking[<span class="number">1</span>].Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"ToList方法查询结果的外键对象"</span> + (studentsAsNoTracking[<span class="number">0</span>].Class.Number == studentsAsNoTracking[<span class="number">1</span>].Class.Number ? <span class="string">""</span> : <span class="string">"不"</span>) + <span class="string">"共用一个对象"</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aAsNoTracking = dbContext.Students.Include(s =&gt; s.Class).AsNoTracking().First();</span><br><span class="line">    <span class="keyword">var</span> bAsNoTracking = dbContext.Students.Include(s =&gt; s.Class).AsNoTracking().Last();</span><br><span class="line">    Console.WriteLine(<span class="string">"修改前："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"a.Class.Number = "</span> + aAsNoTracking.Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"b.Class.Number = "</span> + bAsNoTracking.Class.Number);</span><br><span class="line">    aAsNoTracking.Class.Number = <span class="string">"003"</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">"修改后："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"a.Class.Number = "</span> + aAsNoTracking.Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"b.Class.Number = "</span> + bAsNoTracking.Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"不同的方法查询结果的外键对象"</span> + (aAsNoTracking.Class.Number == bAsNoTracking.Class.Number ? <span class="string">""</span> : <span class="string">"不"</span>) + <span class="string">"共用一个对象"</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    Console.WriteLine(<span class="string">"不加AsNoTracking:"</span>);</span><br><span class="line">    <span class="keyword">var</span> students = dbContext.Students.Include(s =&gt; s.Class).ToList();</span><br><span class="line">    Console.WriteLine(<span class="string">"修改前："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[0].Class.Number = "</span> + students[<span class="number">0</span>].Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[1].Class.Number = "</span> + students[<span class="number">1</span>].Class.Number);</span><br><span class="line">    students[<span class="number">0</span>].Class.Number = <span class="string">"002"</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">"修改后："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[0].Class.Number = "</span> + students[<span class="number">0</span>].Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"students[1].Class.Number = "</span> + students[<span class="number">1</span>].Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"ToList方法查询结果的外键对象"</span> + (students[<span class="number">0</span>].Class.Number == students[<span class="number">1</span>].Class.Number ? <span class="string">""</span> : <span class="string">"不"</span>) + <span class="string">"共用一个对象"</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = dbContext.Students.Include(s =&gt; s.Class).First();</span><br><span class="line">    <span class="keyword">var</span> b = dbContext.Students.Include(s =&gt; s.Class).Last();</span><br><span class="line">    Console.WriteLine(<span class="string">"修改前："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"a.Class.Number = "</span> + a.Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"b.Class.Number = "</span> + b.Class.Number);</span><br><span class="line">    a.Class.Number = <span class="string">"003"</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">"修改后："</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"a.Class.Number = "</span> + a.Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"b.Class.Number = "</span> + b.Class.Number);</span><br><span class="line">    Console.WriteLine(<span class="string">"不同的方法查询结果的外键对象"</span> + (a.Class.Number == b.Class.Number ? <span class="string">""</span> : <span class="string">"不"</span>) + <span class="string">"共用一个对象"</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">AsNoTracking:</span><br><span class="line">修改前：</span><br><span class="line">students[0].Class.Number = 001</span><br><span class="line">students[1].Class.Number = 001</span><br><span class="line">修改后：</span><br><span class="line">students[0].Class.Number = 002</span><br><span class="line">students[1].Class.Number = 002</span><br><span class="line">ToList方法查询结果的外键对象共用一个对象</span><br><span class="line"></span><br><span class="line">修改前：</span><br><span class="line">a.Class.Number = 001</span><br><span class="line">b.Class.Number = 001</span><br><span class="line">修改后：</span><br><span class="line">a.Class.Number = 003</span><br><span class="line">b.Class.Number = 001</span><br><span class="line">不同的方法查询结果的外键对象不共用一个对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不加AsNoTracking:</span><br><span class="line">修改前：</span><br><span class="line">students[0].Class.Number = 001</span><br><span class="line">students[1].Class.Number = 001</span><br><span class="line">修改后：</span><br><span class="line">students[0].Class.Number = 002</span><br><span class="line">students[1].Class.Number = 002</span><br><span class="line">ToList方法查询结果的外键对象共用一个对象</span><br><span class="line"></span><br><span class="line">修改前：</span><br><span class="line">a.Class.Number = 002</span><br><span class="line">b.Class.Number = 002</span><br><span class="line">修改后：</span><br><span class="line">a.Class.Number = 003</span><br><span class="line">b.Class.Number = 003</span><br><span class="line">不同的方法查询结果的外键对象共用一个对象</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>不加 AsNoTracking() 的情况下，所有的同一外键指向同一对象；<br>加 AsNoTracking() 的情况下，分开取出的同一外键指向不同的对象，通过 List 方式取出的同一外键指向相同对象。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> Entity Framework </tag>
            
            <tag> C# </tag>
            
            <tag> 外键 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新建一个 .NET 5 的控制台应用]]></title>
      <url>https://HaleLu.github.io/2016/05/DotNET-5-And-Entity-Framework-7/</url>
      <content type="html"><![CDATA[<p>我们常用 .NET 做 Web 应用，然而有时需要做一些逻辑上的测试（例如测试EF 7），所以我们有时会选择使用 ConsoleApp 来简单测试一些东西。<br>此文记录 ConsoleApp 的创建以及 EF 7 的配置过程。  </p>
<a id="more"></a>

<h2 id="新建-NET-的-Web-应用"><a href="#新建-NET-的-Web-应用" class="headerlink" title="新建 .NET 的 Web 应用"></a>新建 .NET 的 Web 应用</h2><p>首先，我们从 Visual Studio 2015 新建一个控制台应用程序（如图）。<br><img src="http://halelu.github.io/2016/05/DotNET-5-And-Entity-Framework-7/Figure-1.png" alt></p>
<h2 id="安装-Entity-Framework-7"><a href="#安装-Entity-Framework-7" class="headerlink" title="安装 Entity Framework 7"></a>安装 Entity Framework 7</h2><p>我们此处以Entity Framework For Microsoft SQL Server 为例。  </p>
<h3 id="安装-EntityFramework-MicrosoftSqlServer-程序包"><a href="#安装-EntityFramework-MicrosoftSqlServer-程序包" class="headerlink" title="安装 EntityFramework.MicrosoftSqlServer 程序包"></a>安装 EntityFramework.MicrosoftSqlServer 程序包</h3><p>可以手动在 工具 ‣ NuGet 包管理器 ‣ 管理解决方案的 NuGet 包 中搜索 EntityFramework.MicrosoftSqlServer 并选择安装，也可以选择 工具 ‣ NuGet 包管理器 ‣ 程序包管理器控制台 ，通过 Install-Package 命令 手动添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Install-Package EntityFramework.MicrosoftSqlServer –Pre</span><br></pre></td></tr></table></figure>

<p>这样就安装好了 EF 7 For SQL Server 的依赖库。</p>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>需要在自己定义的 DbContext 类中重写 OnConfiguring 方法。</p>
<p>此处以 在 (localdb)\mssqllocaldb 上创建一个名叫 EFGetStarted.ConsoleAppFortest.DbForTest 的数据库 为例。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppDbContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Visual Studio 2015 | Use the LocalDb 12 instance created by Visual Studio</span></span><br><span class="line">        optionsBuilder.UseSqlServer(<span class="string">@"Server=(localdb)\mssqllocaldb;Database=EFGetStarted.ConsoleAppFortest.DbForTest;Trusted_Connection=True"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来有两种方案，代码创建和手动添加 Migration。</p>
<h3 id="代码创建-Migration"><a href="#代码创建-Migration" class="headerlink" title="代码创建 Migration"></a>代码创建 Migration</h3><p>在创建完自己的 DbContext 对象后，通过调用该对象的 Database.EnsureCreated() 方法保证 Migration 被创建。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dbContext = <span class="keyword">new</span> AppDbContext();</span><br><span class="line">    dbContext.Database.EnsureCreated();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时配置便已经完成，可以运行了。</p>
<h3 id="手动添加-Migration"><a href="#手动添加-Migration" class="headerlink" title="手动添加 Migration"></a>手动添加 Migration</h3><p>手动添加 Migration 需要安装一个包并注册一个命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Install-Package EntityFramework.Commands –Pre</span><br></pre></td></tr></table></figure>

<p>并在 project.json 的 commands 里添加</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"ef": "EntityFramework.Commands"</span><br></pre></td></tr></table></figure>

<p>接着就可以在 NuGet 命令行里添加 Migration 了（新的 Migration 命名为 MyFirstMigration ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Add-Migration MyFirstMigration</span><br><span class="line">PM&gt; Update-Database</span><br></pre></td></tr></table></figure>

<p>我在执行 Add-Migration 的时候出现了一点意外，无法识别这一命令，于是我直接打开了 工作目录/src/项目名称/ 文件夹，在这里使用了命令行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工作目录/src/项目名称&gt;dnx ef migrations add MyFirstMigration</span><br><span class="line">工作目录/src/项目名称&gt;dnx ef database update</span><br></pre></td></tr></table></figure>

<p>此时就在用户文件夹下生成了对应的数据库文件。</p>
<p>这时，配置工作全部完成。</p>
<p>当下次修改了数据库结构时，需重新创建 Migration 并 Update 。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> Entity Framework </tag>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Something About Dijkstra (4)]]></title>
      <url>https://HaleLu.github.io/2016/05/Something-About-Dijkstra-4/</url>
      <content type="html"><![CDATA[<h2 id="斐波那契堆"><a href="#斐波那契堆" class="headerlink" title="斐波那契堆"></a>斐波那契堆</h2><p>斐波那契堆是一种相对松散的堆结构。它的存储结构并不是一棵树，而是一个森林，并且每棵树都是一个符合堆结构的多叉树。<br>它的特点是只在删除掉顶点以后整理堆的结构。并且通过做标记的形式保持堆的平衡。<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-1.png" alt></p>
<a id="more"></a>

<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>直接插入对应结点，松散排列。<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-2.gif" alt></p>
<h3 id="DeleteMin"><a href="#DeleteMin" class="headerlink" title="DeleteMin"></a>DeleteMin</h3><p>删除顶点后先直接将所有子节点作为一棵树直接放进堆，然后进行整理。<br>整理的方式是，将rank（即根节点的孩子数）相同的树合并为一棵树。  </p>
<p>//别问我为什么没做成 gif ，因为没有 PS ，而且懒。  </p>
<p><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-1.png" alt>  </p>
<p>去掉顶点并直接将子节点作为独立的树：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-2.png" alt>  </p>
<p>开始合并操作：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-3.png" alt>  </p>
<p>将树的根节点按照rank依次放进一个指针数组：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-4.png" alt>  </p>
<p>发现已经有相同rank的根节点则进行合并：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-5.png" alt>  </p>
<p>不断合并直到rank唯一：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-6.png" alt>  </p>
<p><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-7.png" alt>  </p>
<p>继续：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-8.png" alt>  </p>
<p><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-9.png" alt>  </p>
<p>合并：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-3-10.png" alt>  </p>
<p>到这里，整个堆的根节点都放进数组，整理完成。</p>
<h3 id="DecreaseKey"><a href="#DecreaseKey" class="headerlink" title="DecreaseKey"></a>DecreaseKey</h3><p>此过程需要用到之前定义的 mark 属性，它表示这一结点是否已经被删除过子节点。通过这一标记来尽量保证树的平衡，避免出现“链”的结构。  </p>
<p>具体操作如下：  </p>
<p>首先减小某一顶点的值，然后观察其是否是小于父节点：<br>　　若无父节点，则看是否要更新 min 指针；<br>　　若依然大于父节点，则不做修改；<br>　　若小于父节点，则剪断改分支，并尝试对父节点做标记；<br>　　　　若父节点已经有标记，则剪断父节点并递归对其父节点做标记，直到可以做标记或已经是根节点为止。  </p>
<p><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-1.png" alt>  </p>
<p>将46减小为29：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-2.png" alt><br>小于父节点，无需修改  </p>
<p>将29减小为15：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-3.png" alt>  </p>
<p>小于父节点，剪断，并做标记：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-4.png" alt>  </p>
<p>24被标记：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-5.png" alt>  </p>
<p>将35减小为5：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-6.png" alt>  </p>
<p>小于父节点，剪断，并做标记：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-7.png" alt>  </p>
<p>父节点已经被标记一次了，所以剪断父节点，并对其父节点做标记：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-8.png" alt>  </p>
<p>发现其父节点也已经被标记了，所以再次剪断父节点并对其父节点做标记：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-9.png" alt>  </p>
<p>由于父节点是根节点，所以不再做标记：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-4/Figure-4-10.png" alt>  </p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>节点数</td>
</tr>
<tr>
<td>rank(x)</td>
<td>结点 x 的孩子数</td>
</tr>
<tr>
<td>rank(H)</td>
<td>堆 H 的最大 rank</td>
</tr>
<tr>
<td>trees(H)</td>
<td>堆 H 中树的数量</td>
</tr>
<tr>
<td>marks(H)</td>
<td>堆 H 中已标记的点数</td>
</tr>
</tbody></table>
<p>定义一个势函数： Φ(H)  = trees(H) + 2 marks(H)</p>
<ul>
<li><p>Insert：</p>
<ul>
<li>时间复杂度： O(1)</li>
<li>势函数变化： + 1</li>
<li>均摊时间复杂度： O(1)</li>
</ul>
</li>
<li><p>Delete Min：</p>
<ul>
<li><p>O(rank(H))  + O(trees(H)) </p>
<ul>
<li>O(rank(H))将最小值的孩子合并到根节点列表中</li>
<li>O(rank(H)) + O(trees(H)) 更新最小值</li>
<li>O(rank(H)) + O(trees(H)) 巩固森林</li>
</ul>
</li>
<li><p>势函数变化：O(rank(H)) - trees(H)</p>
<ul>
<li>trees(H’) ≤ rank(H) + 1 因为没有两个树有相同的rank</li>
<li>△Φ(H) ≤ rank(H) + 1 - trees(H)</li>
</ul>
</li>
<li><p>均摊时间复杂度： O(rank(H))</p>
</li>
</ul>
</li>
<li><p>Decrease Key：</p>
<ul>
<li><p>O(c) （c 表示剪断次数）</p>
<ul>
<li>O(1) 改变权值</li>
<li>O(1) 剪断并放到根节点列表</li>
</ul>
</li>
<li><p>势函数变化：O(1) - c</p>
<ul>
<li>trees(H’) = trees(H) + c</li>
<li>marks(H’) ≤ marks(H) - c + 2</li>
<li>△Φ ≤ c  +  2 (-c + 2)  =  4 - c</li>
</ul>
</li>
<li><p>均摊时间复杂度： O(1)</p>
</li>
</ul>
</li>
</ul>
<p>可以证明，rank(H) ≤ log Φ (|V|)（其中Φ表示(1 + √5) / 2 ≈ 1.618），由于证明过程有点复杂这里不再说明。<br>所以最终复杂度为O( ( 1 + log Φ (|V|) )|V| + |E| )</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Fibonacci堆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Something About Dijkstra (3)]]></title>
      <url>https://HaleLu.github.io/2016/05/Something-About-Dijkstra-3/</url>
      <content type="html"><![CDATA[<h2 id="k-ary-Heap（k叉堆）"><a href="#k-ary-Heap（k叉堆）" class="headerlink" title="k-ary Heap（k叉堆）"></a>k-ary Heap（k叉堆）</h2><p>简单点说，即将原本堆的实现形式从二叉树改为 k 叉树。  </p>
<a id="more"></a>


<p>k 叉树的 Insert 和 DecreaseKey 操作的复杂度为 O(log k (V))，DeleteMin 的复杂度为 O(k log k (V))，具体的对比如下表所示：  </p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>Insert,DecreaseKey</th>
<th>DeleteMin</th>
</tr>
</thead>
<tbody><tr>
<td>链表</td>
<td>O(1)</td>
<td>O(V)</td>
</tr>
<tr>
<td>二叉堆</td>
<td>O(log (V))</td>
<td>O(log (V))</td>
</tr>
<tr>
<td>k 叉堆</td>
<td>O(log k (V))</td>
<td>O(k log k (V))</td>
</tr>
<tr>
<td>斐波那契堆</td>
<td>O(1) amortized</td>
<td>O(log V)</td>
</tr>
</tbody></table>
<h2 id="对-Dijkstra-的时间优化"><a href="#对-Dijkstra-的时间优化" class="headerlink" title="对 Dijkstra 的时间优化"></a>对 Dijkstra 的时间优化</h2><p>对一个 Dijkstra 算法来说，如果图为 G(V,E)，一般需要 |V| 次 Insert、|V| 次 DeleteMin 和 |E| 次 DecreaseKey，所以对二叉堆来说总复杂度为 O( (2|V|+|E|) log (V) )，而 k 叉堆为 O( ( (k+1)|V|+|E| ) log k (V) )。</p>
<p>通常我们 k 的值会取 |E| / |V|，那么k 叉堆复杂度就是 O( ( |V|+2|E| ) log (|E| / |V|) (V) )。<br>在 |E| / |V| &gt; 2 的情况下，显然k叉堆是可以起到优化复杂度的效果的。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> k叉堆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Something About Dijkstra (2)]]></title>
      <url>https://HaleLu.github.io/2016/05/Something-About-Dijkstra-2/</url>
      <content type="html"><![CDATA[<p>看的第二篇论文是一篇叫做《A Parallel Algorithm for the Single-Source Shortest Path Problem》的论文。<br>（其实没怎么看懂，欢迎明白的和我讨论这是什么意思。）  </p>
<a id="more"></a>

<h2 id="Dijkstra-算法的并行化"><a href="#Dijkstra-算法的并行化" class="headerlink" title="Dijkstra 算法的并行化"></a>Dijkstra 算法的并行化</h2><h3 id="Gabow’s-Scaling-Algorithm"><a href="#Gabow’s-Scaling-Algorithm" class="headerlink" title="Gabow’s Scaling Algorithm"></a>Gabow’s Scaling Algorithm</h3><p>核心思想是一次考虑一位（bit），本质是一种按位的 Dijkstra 。<br>先将图按最高位（i = log2( max{ range(w) } )， i表示当前位） Dijkstra 一次，接下来每次用前 i 位的距离进行 Dijkstra 并左移一位。<br>因为可以反复寻找最短路径，所以保证了最终的路径最短。</p>
<h2 id="Give-up"><a href="#Give-up" class="headerlink" title="Give up"></a>Give up</h2><p>好吧我放弃了。因为实在是不了解并行化编程，花了两天也实在无法吃透这篇论文。<br>有人后来明白了欢迎留言评论。<br>我算是在这留了个坑吧。【摊手】</p>
<h2 id="新命题"><a href="#新命题" class="headerlink" title="新命题"></a>新命题</h2><p>放弃这一篇，转而去写 k 叉堆了。接下来会写两篇，一篇是 k 叉堆，一篇是斐波那契堆。<br>原谅我实在太弱。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Something About Dijkstra (1)]]></title>
      <url>https://HaleLu.github.io/2016/05/Something-About-Dijkstra-1/</url>
      <content type="html"><![CDATA[<p>这两天因为需要看了两篇 Dijkstra 的论文，将思想整理出来以供学习。</p>
<a id="more"></a>

<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>Dijkstra 算法的具体细节不再赘述，本质上是一种贪心算法，通过不断添加距离源点最短的点并刷新距离来求解。  </p>
<h2 id="稀疏图的压缩"><a href="#稀疏图的压缩" class="headerlink" title="稀疏图的压缩"></a>稀疏图的压缩</h2><h3 id="Virtual-Node"><a href="#Virtual-Node" class="headerlink" title="Virtual Node"></a>Virtual Node</h3><p><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-1/Figure-1.png" alt><br>如图，通过添加点减少边的数量（子图必须是二部图）</p>
<h3 id="Superedges"><a href="#Superedges" class="headerlink" title="Superedges"></a>Superedges</h3><p><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-1/Figure-2.png" alt><br>如图，合并相似点（邻接点相同、距离均相近）</p>
<h3 id="动态-Dijkstra-压缩"><a href="#动态-Dijkstra-压缩" class="headerlink" title="动态 Dijkstra 压缩"></a>动态 Dijkstra 压缩</h3><p>先将所有点按度数排序（压进优先队列），每次弹出一个顶点，把它的 Dijkstra 最短路的所有路径加入新图G’中。<br>当G’的压缩率（G’的边数/G的边数）达到某一要求值时结束循环。  </p>
<p>讲道理，看到这里的时候我是崩溃的。这压缩能用？<br>边数：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-1/Figure-3.png" alt="边数"><br>随机两点间最短距离：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-1/Figure-4.png" alt="随机两点间最短路和原图的比"><br>答案准确度（随机两点间最短路和原图的比）：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-1/Figure-5.png" alt="随机两点间最短路和原图的比"><br>和原图的 Dijkstra 运行时间比：<br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-1/Figure-6.png" alt="和原图的 Dijkstra 运行时间比"><br><img src="http://halelu.github.io/2016/05/Something-About-Dijkstra-1/Figure-7.png" alt="和原图的 Dijkstra 运行时间比"><br>感觉作用不大啊。。  </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>试图压缩稀疏图的想法并不靠谱。压缩率在0.9的时候还能接受。然而做一次压缩所需要的时间耗费太过巨大，所以并不推荐使用图压缩。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[A New Beginning]]></title>
      <url>https://HaleLu.github.io/2016/05/A-New-Beginning/</url>
      <content type="html"><![CDATA[<h3 id="絮絮叨叨"><a href="#絮絮叨叨" class="headerlink" title="絮絮叨叨"></a>絮絮叨叨</h3><p>前几天在 Facebook 上说自己太水，要开始写博客。  </p>
<p>上午（其实已经是昨天上午了）的时候准备给大一的讲 git ，偶然发现 Github 可以搭网站。 </p>
<p>傍晚的时候PM突然也用 Github 搭出了 Blog 。  </p>
<p>那就动手咯~  </p>
<a id="more"></a>

<h3 id="搭站"><a href="#搭站" class="headerlink" title="搭站"></a>搭站</h3><p>照着 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a> 文档；<br>装上 Node.js 和 Git ；  </p>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>再然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>一通乱搞。</p>
<p>换个 theme ，改改 _config.yml ；<br>git 一下，再部署一下 deploy ；<br>跑一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>然后就开始创建博客了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>看起来好像挺简单。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>虽然是搭好了，但还是得好好看看 md ，毕竟以后都得用这语言写博客。  </p>
<p>搭建这个 blog 算是一个开始吧。今后好好写代码。  </p>
<p>Android &amp; .NET &amp; C/C++ &amp; 算法</p>
<p>祝我这次不再断更。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 搭站 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
