<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="阅读,Spring,Java,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="书接上文">
<meta name="keywords" content="阅读,Spring,Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring进阶 - IoC容器(2)">
<meta property="og:url" content="https://HaleLu.github.io/2020/04/spring-2/index.html">
<meta property="og:site_name" content="Move your idea forward.">
<meta property="og:description" content="书接上文">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-06-03T14:18:42.426Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring进阶 - IoC容器(2)">
<meta name="twitter:description" content="书接上文">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6279916590628603000,
      author: '（博主大人~）'
    }
  };
</script>

  <title> Spring进阶 - IoC容器(2) | Move your idea forward. </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-77199457-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Move your idea forward.</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hale Lu's Blog</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Spring进阶 - IoC容器(2)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-04-17T23:18:11+08:00" content="2020-04-17">
              2020-04-17
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/04/spring-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/spring-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2020/04/spring-2/" class="leancloud_visitors" data-flag-title="Spring进阶 - IoC容器(2)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>书接<a href="https://halelu.github.io/2020/02/spring-1/">上文</a></p>
<a id="more"></a>

<h2 id="自定义-bean-的行为-Nature"><a href="#自定义-bean-的行为-Nature" class="headerlink" title="自定义 bean 的行为(Nature)"></a>自定义 bean 的行为(Nature)</h2><p>Spring Framework 提供了许多可用于自定义 bean 行为的接口。依次讲这三种接口：</p>
<h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>想要介入容器的 bean 生命周期管理，可以实现 Spring InitializingBean 和 DisposableBean 接口。前者调用 afterPropertiesSet()初始化，后者调用 destroy() 销毁 ​​bean 。</p>
<p>JSR-250 规范中的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注释通常被认为是在现代 Spring 应用程序中接收生命周期回调的最佳实践。使用这些注释可以使 bean 解耦于这些 Spring 的接口。详见下文。</p>
<p>如果不想使用 JSR-250 规范的注释但仍想解耦，可以使用 init-method 和 destroy-method。</p>
<p>在内部，Spring Framework 使用 BeanPostProcessor 实现来处理它可以找到的任何回调接口并调用对应的方法。如果需要自定义其他 Spring 默认不提供的功能或生命周期行为，可以 BeanPostProcessor 自己实现。</p>
<p>除了初始化和销毁 ​​ 回调之外，Spring 管理的对象还可以实现 Lifecycle 接口，以便这些对象可以参与启动和关闭过程，这是由容器自身的生命周期驱动的。</p>
<p>接下来讲生命周期回调接口。</p>
<h4 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h4><p>org.springframework.beans.factory.InitializingBean 接口允许在容器设置 bean 的所有必要属性后进行初始化工作。InitializingBean 接口规定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>当然，上文说了，并不推荐使用 InitializingBean 接口，更好的做法是使用 <code>@PostConstruct</code> 方法或者指定 POJO 初始化方法。可以使用 XML 中的 init-method 属性或者 <code>@Bean</code> 注解的 initMethod 指定一个返回 void 且无参的方法作为初始化方法。</p>
<h4 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h4><p>对应的 org.springframework.beans.factory.DisposableBean 接口规定了一个销毁前执行的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>同理，建议 <code>@PreDestroy</code> 和 destroy-method 的 XML 配置或 <code>@Bean</code> 的 destroyMethod 属性。</p>
<h4 id="默认初始化和析构方法"><a href="#默认初始化和析构方法" class="headerlink" title="默认初始化和析构方法"></a>默认初始化和析构方法</h4><p>你可以将所有的初始化、销毁的方法使用相同的命名（比如 init、initialize、dispose 等），那么就可以定义默认初始化和析构方法。</p>
<p>举例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blogService"</span> <span class="attr">class</span>=<span class="string">"com.something.DefaultBlogService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogDao"</span> <span class="attr">ref</span>=<span class="string">"blogDao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 容器保证在为 bean 提供所有依赖项后立即调用已配置的初始化回调，所以初始化回调会在 AOP 作用之前。首先完全创建 bean，然后配置带有拦截器链的 AOP 代理。所以在 init 方法上使用拦截器可能会导致和预想不一致，因为这样会导致目标 bean 的生命周期与代理或拦截器耦合，代码与原始目标 bean 杂糅的语义就会难以预测。</p>
<h5 id="组合生命周期机制"><a href="#组合生命周期机制" class="headerlink" title="组合生命周期机制"></a>组合生命周期机制</h5><p>如果使用了多种生命周期机制，他们的先后顺序如下：</p>
<ol>
<li>用注释方法注释 <code>@PostConstruct</code></li>
<li>InitializingBean 接口定义的 <code>afterPropertiesSet()</code> 回调</li>
<li>自定义配置的 <code>init()</code> 方法</li>
</ol>
<p>Destroy 方法以相同的顺序调用：</p>
<ol>
<li>用注释方法注释 <code>@PreDestroy</code></li>
<li>DisposableBean 接口定义的 <code>destroy()</code> 回调</li>
<li>自定义配置的 <code>destroy()</code> 方法</li>
</ol>
<p>如果是同一个函数，那么只会执行一次。</p>
<h4 id="启动和关闭回调"><a href="#启动和关闭回调" class="headerlink" title="启动和关闭回调"></a>启动和关闭回调</h4><p>Lifecycle 接口为任何有生命周期要求的对象（例如启动和停止某些后台进程）定义了基本的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何 Spring 管理的对象都可以实现 Lifecycle 接口。当 ApplicationContext 接收到启动和停止信号时（例如，对于运行时的停止/重启场景），它将这些调用级联到容器内定义的所有 Lifecycle 实现，这个过程由 LifecycleProcessor 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LifecycleProcessor 是 Lifecycle 接口的扩展。它又添加了另外两种方法来响应刷新和关闭的容器。</p>
<p>值得注意的是，常规 <code>org.springframework.context.Lifecycle</code> 接口是显式启动和停止通知的简单合约，并不意味着在上下文刷新时自动启动。要对特定 bean 的自动启动（包括启动阶段）进行细粒度控制，需要实现 <code>org.springframework.context.SmartLifecycle</code>。</p>
<p>如果要控制顺序，可以再继承 Phased 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SmartLifecycle</code> 就继承了这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phase 表示相位，启动时从低相位开始执行，停止时低相位最后停止。换句话说，<code>Integer.MIN_VALUE</code> 相位的第一个开始、最后一个停止，而 <code>Integer.MAX_VALUE</code> 最后启动并首先停止。未定义的相位默认为 0。</p>
<p>SmartLifecycle 定义了 stop 回调方法。任何实现在关闭过程完成之后都必须调用其 <code>callback</code> 的 <code>run()</code> 方法，这样就可以在必要时启用异步关闭。LifecycleProcessor 接口的默认实现 DefaultLifecycleProcessor 等待每个阶段内对象组的超时值来调用该回调，默认的每阶段超时为 30 秒。也可以通过定义名为 lifecycleProcessor 的 bean 来覆盖默认生命周期处理器实例（不定义就是默认的 DefaultLifecycleProcessor）。如果只想修改超时，则定义以下内容就足够了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleProcessor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.DefaultLifecycleProcessor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutPerShutdownPhase"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在非-Web-应用程序中优雅地关闭-Spring-IoC-容器"><a href="#在非-Web-应用程序中优雅地关闭-Spring-IoC-容器" class="headerlink" title="在非 Web 应用程序中优雅地关闭 Spring IoC 容器"></a>在非 Web 应用程序中优雅地关闭 Spring IoC 容器</h4><p>Spring 的基于 Web 的 ApplicationContext 实现已经可以在相关 Web 应用程序关闭时正常关闭 Spring IoC 容器。本节仅适用于非 Web 应用程序。</p>
<p>如果在非 Web 应用程序环境中使用 Spring 的 IoC 容器（例如，在客户机桌面环境中），请使用 JVM 注册 shutdown hook。这样做可确保正常关闭并在单例 bean 上调用相关的 destroy 方法，以便释放所有资源。我们依然必须正确配置和实现这些 destroy 回调。</p>
<p>要注册 shutdown hook，需要调用接口 <code>registerShutdownHook()</code> 上声明的 ConfigurableApplicationContext 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a shutdown hook for the above context...</span></span><br><span class="line">        ctx.registerShutdownHook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// app runs here...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// main method exits, hook is called prior to the app shutting down...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationContextAware-和-BeanNameAware"><a href="#ApplicationContextAware-和-BeanNameAware" class="headerlink" title="ApplicationContextAware 和 BeanNameAware"></a>ApplicationContextAware 和 BeanNameAware</h3><p>当 ApplicationContext 创建实现 org.springframework.context.ApplicationContextAware 接口的对象实例时，将为该实例提供对该 ApplicationContext 的引用。 ApplicationContextAware 接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，bean 可以通过 ApplicationContext 接口以编程方式操作创建它们的 ApplicationContext，或者通过将引用转换为此接口的已知子类（例如 ConfigurableApplicationContext，包括其他功能）。一种作用是可以操作其他 bean。有时这种能力很有用。但是通常我们应该避免使用它，因为它会将代码耦合到 Spring 且不遵循 IoC 规范，其中协作者作为属性提供给 bean。 ApplicationContext 还提供对文件资源的访问，发布应用程序事件和对 MessageSource 的访问，详见下文。</p>
<p>从 Spring 2.5 开始，自动装配是另一种获取 ApplicationContext 引用的方法。“传统”构造函数和 byType 自动装配模式（见上文的自动装配协作者）可以分别为构造函数参数或 setter 方法参数提供 ApplicationContext 类型的依赖关系。 为了获得更大的灵活性，包括自动装配字段和多参数方法的能力，我们可以使用基于注释的新自动装配功能。如果带有 <code>@Autowired</code> 注解的字段，构造函数或方法需要 ApplicationContext 类型的参数，那么 ApplicationContext 将会被注入。详见下文的 <code>@Autowired</code> 注解。</p>
<p>BeanNameAware 可以获取到该类实现的 bean 的 name，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会在全体普通 bean 属性定义之后但在初始化回调之前（例如 InitializingBean，afterPropertiesSet 或自定义 init 方法）之前调用回调。</p>
<h3 id="其他-Aware-接口"><a href="#其他-Aware-接口" class="headerlink" title="其他 Aware 接口"></a>其他 Aware 接口</h3><table>
<thead>
<tr>
<th>名称</th>
<th>注入的依赖</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ApplicationContextAware</td>
<td>ApplicationContext</td>
<td></td>
</tr>
<tr>
<td>ApplicationEventPublisherAware</td>
<td>封闭 ApplicationContext 的事件发布者</td>
<td></td>
</tr>
<tr>
<td>BeanClassLoaderAware</td>
<td>用于加载 bean 类的类加载器</td>
<td></td>
</tr>
<tr>
<td>BeanFactoryAware</td>
<td>BeanFactory</td>
<td></td>
</tr>
<tr>
<td>BeanNameAware</td>
<td>声明的 bean 的名称</td>
<td></td>
</tr>
<tr>
<td>BootstrapContextAware</td>
<td>运行容器的资源适配器 BootstrapContext，仅在 JCA-aware ApplicationContext 的实例中可用</td>
<td></td>
</tr>
<tr>
<td>LoadTimeWeaverAware</td>
<td>用于在加载时处理类定义的 weaver</td>
<td></td>
</tr>
<tr>
<td>MessageSourceAware</td>
<td>用于解析消息的策略（支持参数化和国际化）</td>
<td></td>
</tr>
<tr>
<td>NotificationPublisherAware</td>
<td>Spring JMX 通知发布者</td>
<td></td>
</tr>
<tr>
<td>ResourceLoaderAware</td>
<td>用于对资源进行低级访问的加载器</td>
<td></td>
</tr>
<tr>
<td>ServletConfigAware</td>
<td>运行容器的 ServletConfig，仅在 web-aware Spring ApplicationContext 中可用</td>
<td></td>
</tr>
<tr>
<td>ServletContextAware</td>
<td>运行容器的 ServletContext，仅在 web-aware Spring ApplicationContext 中可用</td>
<td></td>
</tr>
</tbody></table>
<p>再次提醒，使用这些接口会将代码耦合到 Spring API 且不遵循 IoC 规范。除非是需要以代码方式访问容器的基础架构 bean，否则不建议使用这些方式。</p>
<h2 id="bean-定义的继承"><a href="#bean-定义的继承" class="headerlink" title="bean 定义的继承"></a>bean 定义的继承</h2><p>bean 定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子 bean 定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用继承 bean 定义可以节省大量的输入。这是一种模板模型。</p>
<p>在 ApplicationContext 级别上，子 bean 定义使用 ChildBeanDefinition 类表示，大多数时候我们并不用在这个级别上去做定义。以下是一个简单定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">abstract</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithDifferentClass"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子 bean 定义从父级继承 scope，构造函数参数值，属性值和方法覆盖并带有添加新值的选项。指定的 scope，初始化方法，销毁方法或静态工厂方法设置都会覆盖相应的父设置。</p>
<p>也有些不会被继承：依赖、自动装配模式、依赖检查、单例、懒加载。</p>
<p>前面的示例通过使用 abstract 属性将父 bean 定义显式标记为 abstract。 如果父定义未指定类，则需要将父 bean 定义显式标记为 abstract，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithClass"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个父 bean 不能单独实例化。标记为 abstract 的 bean 只做模板 bean 定义。如果尝试强行 getBean 则会报错。容器的 <code>preInstantiateSingletons()</code> 方法会忽略 abstract 的 bean 定义。</p>
<p><em>注：ApplicationContext 默认情况下预先实例化所有单例。因此，重要的是（至少对于单例 bean），如果你有一个（父）bean 定义，你只打算用作模板，并且这个定义指定了一个类，你必须确保将 abstract 属性设置为 true 否则应用程序上下文将实际（尝试）预先实例化 abstract bean。</em></p>
<h2 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h2><p>通常，应用程序开发人员不需要继承 ApplicationContext 实现类。 相反，可以通过插入特殊集成接口的实现来扩展 Spring IoC 容器。 接下来的几节将介绍这些集成接口。</p>
<h3 id="使用-BeanPostProcessor-自定义-bean"><a href="#使用-BeanPostProcessor-自定义-bean" class="headerlink" title="使用 BeanPostProcessor 自定义 bean"></a>使用 BeanPostProcessor 自定义 bean</h3><p>BeanPostProcessor 接口实现举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simply return the instantiated bean as-is</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanPostProcessor 接口允许用户实现自己的（或覆盖容器的默认）实例化逻辑、依赖关系解析逻辑等。如果要在 Spring 容器完成实例化，配置和初始化 bean 之后实现某些自定义逻辑，则可以插入一个或多个自定义 BeanPostProcessor 实现。多个 BeanPostProcessor 实例可以通过实现 Ordered 接口并设置 order 属性来控制执行顺序。</p>
<p>BeanPostProcessor 实例的范围是每个容器的范围。 仅当我们使用容器层次结构时，这才是相关的。 如果在一个容器中定义 BeanPostProcessor，它只对该容器中的 bean 进行后处理。 换句话说，在一个容器中定义的 bean 不会被另一个容器中定义的 BeanPostProcessor 进行后处理，即使两个容器都是同一层次结构的一部分。</p>
<p>如果要更改的是 bean 定义，我们可以使用 BeanFactoryPostProcessor，详见下文。</p>
<p>org.springframework.beans.factory.config.BeanPostProcessor 接口由两个回调方法组成。当这样的类被注册为容器的后处理器（post-processor）时，对于容器创建的每个 bean 实例，后处理器在容器初始化方法之前从容器中获取回调（比如 <code>InitializingBean.afterPropertiesSet()</code> 或 bean 声明的 init 方法）。后处理器可以对 bean 实例执行任何操作，甚至可以让它忽略回调。bean 后处理器通常用于检查回调接口，或者用来将 bean 包装成代理。一些 Spring AOP 的基础设施类就是用 bean 后处理器实现的，以便提供代理包装逻辑。</p>
<p>ApplicationContext 会自动检测所有实现 BeanPostProcessor 接口的 bean，并将他们注册为后处理器，以便稍后在创建 bean 时调用。后处理器可以用任何 bean 注册方式部署在容器中。</p>
<p>注意，在配置类上使用 <code>@Bean</code> 工厂方法声明 BeanPostProcessor 时，工厂方法的返回类型应该是实现类本身，或者至少是 org.springframework.beans.factory.config.BeanPostProcessor 接口，指示该 bean 的后处理器性质。否则，ApplicationContext 无法在完全创建之前按类型自动检测到它。由于 BeanPostProcessor 需要尽早实例化以便应用于上下文中其他 bean 的初始化，因此这种早期类型检测至关重要。</p>
<h4 id="以编程方式注册-BeanPostProcessor-实例"><a href="#以编程方式注册-BeanPostProcessor-实例" class="headerlink" title="以编程方式注册 BeanPostProcessor 实例"></a>以编程方式注册 BeanPostProcessor 实例</h4><p>虽然 BeanPostProcessor 注册的推荐方法是通过 ApplicationContext 自动检测（如前所述），但也可以使用 addBeanPostProcessor 方法以编程方式对 ConfigurableBeanFactory 注册它们。当您需要在注册前评估条件逻辑或甚至跨层次结构中的上下文复制 Bean 后处理器时，这非常有用。 但请注意，以编程方式添加的 BeanPostProcessor 实例不遵循 Ordered 接口。这里，注册的顺序决定了执行的顺序。另请注意，以编程方式注册的 BeanPostProcessor 实例始终在通过自动检测注册的实例之前处理，而不管任何显式排序。</p>
<h4 id="BeanPostProcessor-实例和-AOP-自动代理"><a href="#BeanPostProcessor-实例和-AOP-自动代理" class="headerlink" title="BeanPostProcessor 实例和 AOP 自动代理"></a>BeanPostProcessor 实例和 AOP 自动代理</h4><p>BeanPostProcessor 是不能使用 AOP 的。实现 BeanPostProcessor 接口的类是特殊的，容器会对它们进行不同的处理。作为 ApplicationContext 的特殊启动阶段的一部分，它们直接引用的所有 BeanPostProcessor 实例和 bean 都在启动时实例化。接下来，所有 BeanPostProcessor 实例都以排序方式注册，并应用于容器中的所有其他 bean。因为 AOP 自动代理是作为 BeanPostProcessor 本身实现的，所以 BeanPostProcessor 实例和它们直接引用的 bean 都不符合自动代理的条件，因此没有编入方法。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simply return the instantiated bean as-is</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/lang</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/lang/spring-lang.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">"messenger"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">script-source</span>=<span class="string">"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple Is Just So Dreamy."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    when the above bean (messenger) is instantiated, this custom</span></span><br><span class="line"><span class="comment">    BeanPostProcessor implementation will output the fact to the system console</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"scripting.InstantiationTracingBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"scripting/beans.xml"</span>);</span><br><span class="line">        Messenger messenger = (Messenger) ctx.getBean(<span class="string">"messenger"</span>);</span><br><span class="line">        System.out.println(messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bean&apos;sensenger&apos;创建：org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></td></tr></table></figure>

<p>将回调接口或注释与自定义 BeanPostProcessor 实现结合使用是扩展 Spring IoC 容器的常用方法。一个例子是 Spring 的 RequiredAnnotationBeanPostProcessor —— 一个 Spring 提供的 BeanPostProcessor 实现，它保证用 <code>@Required</code>（或者其他自定义的）注释标记的 bean 上的属性一定有值注入。</p>
<h2 id="使用-BeanFactoryPostProcessor-定制配置项元数据"><a href="#使用-BeanFactoryPostProcessor-定制配置项元数据" class="headerlink" title="使用 BeanFactoryPostProcessor 定制配置项元数据"></a>使用 BeanFactoryPostProcessor 定制配置项元数据</h2><p>我们看到的下一个扩展点是 org.springframework.beans.factory.config.BeanFactoryPostProcessor。此接口的语义类似于 BeanPostProcessor 的语义，但有一个主要区别：BeanFactoryPostProcessor 对 bean 配置元数据进行操作。也就是说，Spring IoC 容器允许 BeanFactoryPostProcessor 读取配置元数据，并可能在容器实例化除 BeanFactoryPostProcessor 实例之外的任何 bean 之前更改它。</p>
<p>您可以配置多个 BeanFactoryPostProcessor 实例，并且可以通过设置 order 属性来控制这些 BeanFactoryPostProcessor 实例的运行顺序。但是，如果 BeanFactoryPostProcessor 实现 Ordered 接口，则只能设置此属性。如果编写自己的 BeanFactoryPostProcessor，则应考虑实现 Ordered 接口。有关更多详细信息，请参阅 BeanFactoryPostProcessor 和 Ordered 接口的 javadoc。</p>
<p>如果要更改实际的 bean 实例（即，从配置项元数据创建的对象），则需要使用 BeanPostProcessor（前面在使用 BeanPostProcessor 定制 Bean 中进行了描述）。虽然技术上可以在 BeanFactoryPostProcessor 中使用 bean 实例（例如，通过使用 <code>BeanFactory.getBean()</code>），但这样做会导致过早的 bean 实例化，从而违反标准的容器生命周期。这可能会导致负面影响，例如绕过 bean 后期处理。</p>
<p>此外，BeanFactoryPostProcessor 实例的范围是每个容器的范围。仅当您使用容器层次结构时，这才有意义。如果在一个容器中定义 BeanFactoryPostProcessor，则它仅应用于该容器中的 bean 定义。一个容器中的 Bean 定义不会被另一个容器中的 BeanFactoryPostProcessor 实例后处理，即使两个容器都是同一层次结构的一部分。</p>
<p>BeanFactoryPostProcessor 在 ApplicationContext 中声明时自动执行，以便将更改应用于定义容器的配置元数据。Spring 包含许多预定义的 bean 工厂后处理器，例如 PropertyOverrideConfigurer 和 PropertyPlaceholderConfigurer。您还可以使用自定义 BeanFactoryPostProcessor —— 例如，注册自定义属性编辑器。</p>
<p>ApplicationContext 自动检测部署到其中的任何实现 BeanFactoryPostProcessor 接口的 bean。它在适当的时候使用这些 bean 作为 bean factory post-processor。您可以像配置其他 bean 一样配置这些 post-processor bean。</p>
<h3 id="示例：类名替换器-PropertyPlaceholderConfigurer"><a href="#示例：类名替换器-PropertyPlaceholderConfigurer" class="headerlink" title="示例：类名替换器 PropertyPlaceholderConfigurer"></a>示例：类名替换器 PropertyPlaceholderConfigurer</h3><p>您可以使用 PropertyPlaceholderConfigurer 将 bean 定义中的属性值分离到外部 Java Properties 文件中。这样做可以使部署应用程序的人员自定义不同环境的属性，例如数据库 URL 和密码，而不会出现修改主 XML 定义文件或容器文件的复杂性或风险。</p>
<p>下面的基于 XML 的配置元数据片段，其中 DataSource 定义了占位符值：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/something/jdbc.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该示例显示了从外部属性文件配置的属性。在运行时，PropertyPlaceholderConfigurer 应用于替换 DataSource 的某些属性的元数据。要替换的值被指定为 <code>${property-name}</code> 形式的占位符，它遵循 Ant 和 log4j 以及 JSP EL 样式。</p>
<p>实际值来自标准 Java Properties 格式的另一个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>

<p>然后 <code>${jdbc.username}</code> 字符串在运行时将替换为值’sa’，其他占位符值也是类似。PropertyPlaceholderConfigurer 检查 bean 定义的大多数属性和属性中的占位符。此外，您可以自定义占位符前缀和后缀。</p>
<p>使用 Spring 2.5 中引入的 context 命名空间，您可以使用专用配置元素配置属性占位符。 您可以在 location 属性中以逗号分隔列表的形式提供一个或多个位置，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:com/something/jdbc.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>PropertyPlaceholderConfigurer 不仅在您指定的属性文件中查找属性。 默认情况下，如果它在指定的属性文件中找不到属性，它还会检查 Java System 属性。 您可以通过使用以下三个受支持的整数值之一设置 configurer 的 systemPropertiesMode 属性来自定义此行为：</p>
<ul>
<li>never （0）：从不检查系统属性。</li>
<li>fallback（1）：如果在指定的属性文件中无法解析，则检查系统属性。这是默认值。</li>
<li>override（2）：在尝试指定的属性文件之前，首先检查系统属性。这使系统属性可以覆盖任何其他属性源。</li>
</ul>
<p>有关 <a href="https://docs.spring.io/spring-framework/docs/5.1.8.RELEASE/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html" target="_blank" rel="noopener">PropertyPlaceholderConfigurer</a> 更多信息，请参阅 javadoc。</p>
<p>另，你甚至可以使用 PropertyPlaceholderConfigurer 替换类名称，这在您必须在运行时选择特定实现类时有时很有用。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/something/strategy.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>custom.strategy.class=com.something.DefaultStrategy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceStrategy"</span> <span class="attr">class</span>=<span class="string">"$&#123;custom.strategy.class&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果在运行时无法将类解析为有效类， 在即将创建 bean 时，bean 的解析将失败。对于非懒加载的 bean，这会发生在 ApplicationContext 的 <code>preInstantiateSingletons()</code> 阶段期间。</p>
<h3 id="示例：PropertyOverrideConfigurer"><a href="#示例：PropertyOverrideConfigurer" class="headerlink" title="示例：PropertyOverrideConfigurer"></a>示例：PropertyOverrideConfigurer</h3><p>PropertyOverrideConfigurer 是另一个 bean 工厂后处理器，类似于 PropertyPlaceholderConfigurer，但与后者不同，原始定义可以具有默认值，或者根本不具有 bean 属性的值。如果重写的 Properties 文件没有某个 bean 属性的条目，则使用默认的上下文定义。</p>
<p>需要注意的是，bean 定义不会感知到被覆盖，因此无法从 XML 定义文件中立即看出正在使用覆盖配置器。 如果多个 PropertyOverrideConfigurer 实例为同一个 bean 属性定义了不同的值，那么根据覆盖机制，最后一个实例将生效。</p>
<p>属性文件配置行采用以下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanName.property=value</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql:mydb</span><br></pre></td></tr></table></figure>

<p>复合属性名称也是支持的，只要路径的每个组件（重写的最终属性除外）都已经非空（可能由构造函数初始化）。在下面的示例中，tom bean 的 fred 属性的 bob 属性的 sammy 属性设置为 123：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tom.fred.bob.sammy = 123</span><br></pre></td></tr></table></figure>

<p>使用 Spring 2.5 中引入的 context 命名空间，可以使用专用配置元素配置属性覆盖，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"classpath:override.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-FactoryBean-自定义实例化逻辑"><a href="#使用-FactoryBean-自定义实例化逻辑" class="headerlink" title="使用 FactoryBean 自定义实例化逻辑"></a>使用 FactoryBean 自定义实例化逻辑</h3><p>你可以为本身为工厂的对象实现 org.springframework.beans.factory.FactoryBean 接口。</p>
<p>FactoryBean 接口在 Spring IoC 容器实例化逻辑中是可拔插的。如果 bean 的初始化代码相对复杂，更适合以 Java 代码表达，而不是（可能）冗长的 XML，那么我们可以创建自己的 FactoryBean，在该类中编写复杂的初始化，然后将自定义 FactoryBean 插入容器中。</p>
<p>FactoryBean 接口有三个方法：</p>
<ul>
<li><p><code>Object getObject()</code>：返回此工厂创建的对象的实例。可以共享实例，具体取决于此工厂是返回单例还是原型。</p>
</li>
<li><p><code>boolean isSingleton()</code>：如果此 FactoryBean 返回单例，则返回 true，否则返回 false。</p>
</li>
<li><p><code>Class getObjectType()</code>：返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 null。</p>
</li>
</ul>
<p>FactoryBean 概念和接口被用在 Spring Framework 中的许多位置。Spring 提供了 50 多个 FactoryBean 接口的实现。</p>
<p>如果需要向容器询问实际的 FactoryBean 实例本身，那么在调用 ApplicationContext 的 <code>getBean()</code> 方法时需要加上＆符号作为 bean 的 id 前缀。比如，对于 id 为 myBean 的 FactoryBean，在容器上调用 <code>getBean(&quot;myBean&quot;)</code> 将返回 FactoryBean 的产品，调用 getBean（“＆myBean”）将返回 FactoryBean 实例本身。</p>
<h2 id="基于注解的容器配置"><a href="#基于注解的容器配置" class="headerlink" title="基于注解的容器配置"></a>基于注解的容器配置</h2><p>这里有一个讨论，配置 Spring 的注解是否比 XML 更好？</p>
<p>注解在其声明中提供了大量上下文，从而可以使配置更短更简洁。而 XML 可以在不触及源代码或重新编译它们的情况下连接组件。<br>有些人更喜欢将注入靠近源，也有人认为有注解的类不再是 POJO，而且配置变得分散且难以控制。</p>
<p>无论选择如何，Spring 都可以兼顾两种风格，甚至可以将它们混合在一起。值得指出的是，通过其 JavaConfig 选项，Spring 允许以非侵入方式使用注释，而无需触及目标组件源代码，并且在工具方面，Spring Tool Suite 支持所有配置样式。</p>
<p>基于注释的配置提供了 XML 设置的替代方案，该配置依赖于字节码元数据来连接组件而不是角括号声明。开发人员不是使用 XML 来描述 bean 连接，而是通过在相关的类，方法或字段声明上使用注释将配置移动到组件类本身。如示例中所述：RequiredAnnotationBeanPostProcessor，将 BeanPostProcessor 与注释结合使用是扩展 Spring IoC 容器的常用方法。例如，Spring 2.0 引入了使用 <code>@Required</code> 注释强制执行所需属性的可能性。 Spring 2.5 使得有可能采用相同的通用方法来驱动 Spring 的依赖注入。从本质上讲，<code>@Autowired</code> 注释提供的功能与自动装配协作者中描述的相同，但具有更细粒度的控制和更广泛的适用性。Spring 2.5 还增加了对 JSR-250 注释的支持，例如 <code>@PostConstruct</code> 和 <code>@PreDestroy</code>。Spring 3.0 增加了对 javax.inject 包中包含的 JSR-330（Java 的依赖注入）注释的支持，例如 <code>@Inject</code> 和 <code>@Named</code>。有关这些注释，详见下文。</p>
<p><em>注:注解注入在 XML 注入之前执行。因此，对于同事通过这两种方法注入的属性，XML 配置会覆盖注解的配置。</em></p>
<p>和之前一样，可以将它们注册为单独的 bean 定义，但也可以通过在基于 XML 的 Spring 配置中包含以下标记来隐式注册它们（请注意包含 context 命名空间）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（隐式注册的 post-processors 包括 AutowiredAnnotationBeanPostProcessor， CommonAnnotationBeanPostProcessor， PersistenceAnnotationBeanPostProcessor，和前面提到的 RequiredAnnotationBeanPostProcessor。）</p>
<p><code>&lt;context:annotation-config/&gt;</code> 仅在定义它的同一应用程序上下文中查找 bean 上的注释。这意味着，如果将 <code>&lt;context:annotation-config/&gt;</code> 放在 DispatcherServlet 的 WebApplicationContext 中，它只检查控制器中有 <code>@Autowired</code>注解的 bean，而不检查您的服务。有关更多信息，请参阅 DispatcherServlet。</p>
<h3 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h3><p>@Required 注释可以用于 bean 属性 setter 方法，如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解表示被修饰的 bean 属性必须在配置时通过 bean 定义中的显式属性值，或通过 autowiring 装配。 如果被修饰的 bean 属性没有被填充，容器就会抛出异常，以后避免以后抛出 NullPointerException 等。不过最好还是将断言放入 bean 类本身（比如 init 方法内），这样如果在容器外部使用类，这样做也会强制执行那些必需的引用和值。</p>
<p><em>注：<code>@Required</code> 注释从 Spring Framework 5.1 开始正式弃用，最好使用构造函数注入所需的设置（或者自定义实现 <code>InitializingBean.afterPropertiesSet()</code> 以及 bean 属性的 setter 方法）。</em></p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>在本节所包含的示例中，可以使用 JSR 330 的@Inject 注释代替 Spring 的@Autowired 注释。</p>
<p>@Autowired 注解可以用于构造函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring Framework 4.3 开始，如果目标 bean 只定义了一个构造函数入口，则不再需要在这样的构造函数上使用@Autowired 注释。但是，如果有多个构造器可用，则必须注释至少一个构造器以告诉容器使用哪一个。</p>
<p>@Autowired 注解也可用于“传统” setter 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至是具有任意名称和多个参数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></span><br><span class="line"><span class="function"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以应用于字段，甚至可以将它与构造函数混合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注：确保目标组件（例如，MovieCatalog 或 CustomerPreferenceDao）始终按照用于@Autowired 注释注入点的类型声明。否则，由于在运行时未找到类型匹配，注入可能会失败。</em></p>
<p><em>对于通过类路径扫描找到的 XML 定义的 bean 或组件类，容器通常预先知道具体类型。但是，对于 <code>@Bean</code> 工厂方法，您需要确保声明的返回类型足够准确。对于实现多个接口的组件或可能由其实现类型引用的组件，请考虑在工厂方法上声明最具体的返回类型（至少与引用 bean 的注入点所需的特定类型一致）。</em></p>
<p>甚至可以用于数组，ApplicationContext 会提供符合类型的所有 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乃至 Collection 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果希望数组或列表中的项按特定顺序排序，可以实现 <code>org.springframework.core.Ordered</code> 接口或使用 <code>@Order</code> 或标准 <code>@Priority</code> 注解。否则，它们的顺序遵循容器中相应目标 bean 定义的注册顺序。</p>
<p>您可以在目标类级别和 <code>@Bean</code> 方法上声明 <code>@Order</code> 注解，可能是通过单个 bean 定义（在多个定义使用相同 bean 类的情况下）。<code>@Order</code> 值可能影响注入时的优先级，但要注意这并不会影响启动的顺序，这是由依赖关系和 <code>@DependsOn</code> 声明正交决定的。</p>
<p>请注意，标准的 <code>javax.annotation.Priority</code> 注释在 <code>@Bean</code> 级别不可用，因为它无法在方法上声明。它的语义可以通过 <code>@Order</code> 值或是指定 <code>@Primary</code> 在同类型的某一个 bean 上实现。</p>
</blockquote>
<p>即使是 Map，只要 key 类型是 String，也可以被自动装配。Map 值包含所有期望类型的 bean，并且键包含相应的 bean 名称，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，当给定注入点没有匹配的候选 bean 时，自动装配会失败。对于声明的数组，集合或映射，至少需要一个匹配元素。</p>
<p>默认情况下 <code>@Autowired</code> 注解的方法和字段是必须的依赖项。我们也可以通过修改 required 参数来改为非必要，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，如果依赖项（可能是多个参数依赖项中的某一个）无法注入，那么这个被注解的方法都完全不会被调用（比如上文的 setMovieFinder）。</p>
<p>注入构造函数和工厂方法参数是一种特殊情况，因为 <code>@Autowired</code> 上的 <code>required</code> 标志具有一些不同的含义，因为 Spring 的构造函数解析算法可能要处理多个构造函数。默认情况下构造函数和工厂方法参数需要保证有效，但在单构造函数场景中有一些特殊规则，例如，如果多元素注入点（数组，集合，Map）没有匹配的 bean 可用，则解析为空(empty)的实例。这样所有的依赖关系都可以在同一个多参的构造函数中声明，比如可以声明为一个没有 <code>@Autowired</code> 注解的公共构造函数。</p>
<blockquote>
<p>每个类只能标记一个带 required 注解的构造函数，但可以标注多个非 required 注解的构造函数。在这种情况下，每个构造函数都是可选的，Spring 会使用满足依赖性的“最贪心”（具有最多参数的构造函数）的构造函数。构造函数解析算法与具有重载构造函数的非注释类相同，只是将候选者缩小到带注释的构造函数。</p>
<p>建议使用 <code>@Autowired</code> 的 <code>required</code> 属性而不是 setter 方法的 <code>@Required</code> 注释。<code>required</code> 属性表示该属性不是自动装配所必需的。如果无法自动装配，则会忽略该属性。另一方面，<code>@Required</code> 更强大，因为它要求容器必须通过任意容器支持的方式设置属性。如果未定义任何值，则会引发相应的异常。</p>
</blockquote>
<p>另外，Java 8 提供了 java.util.Optional 特性来解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring Framework 5.0 开始，还可以使用 <code>@Nullable</code> 注释（任何包中的任何类型的注释 - 比如 JSR-305 中的<code>javax.annotation.Nullable</code> ）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(@Nullable MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以将 <code>@Autowired</code> 用于众所周知的可解析依赖项的接口：BeanFactory，ApplicationContext，Environment，ResourceLoader，ApplicationEventPublisher 和 MessageSource。 这些接口及其扩展接口（如 ConfigurableApplicationContext 或 ResourcePatternResolver）将自动解析，无需特殊设置。 以下示例自动装配 ApplicationContext 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Autowired</code>，<code>@Inject</code>，<code>@Value</code> 和 <code>@Resource</code> 注解由 BeanPostProcessor 实现处理。 这意味着我们不能在自己的 BeanPostProcessor 或 BeanFactoryPostProcessor 类型中应用这些注释。必须使用 XML 或 Spring @Bean 方法显式地“连接”这些类型。</p>
<h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>由于按类型自动装配可能会导致多个候选项，因此通常需要对选择过程进行更多控制。实现这一目标的一种方法是使用 Spring 的 <code>@Primary</code> 注释。<code>@Primary</code> 表示当多个 bean 可以自动装配到单值依赖项时，应该优先选择特定的 bean。如果候选项中只存在一个 primary 的 bean，那么它就是自动装配的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">firstMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">secondMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MovieRecommender 将会自动装配 firstMovieCatalog</p>
<h3 id="限定符微调自动装配"><a href="#限定符微调自动装配" class="headerlink" title="限定符微调自动装配"></a>限定符微调自动装配</h3><p><code>@Primary</code> 可以确定一个主要候选者。当您需要更准确控制选择过程时，可以使用 Spring 的 <code>@Qualifier</code> 注释。您可以将限定符值与特定参数相关联，缩小类型匹配集，以便为每个参数选择特定的 bean。有个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"main"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(@Qualifier(<span class="string">"main"</span>)</span> MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="function">            CustomerPreferenceDao customerPreferenceDao) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为降级，bean 名称被视为默认 qualifier 的值。因此，您可以使用 bean 的 id 得到相同的匹配结果。但是，虽然您可以使用此约定来按名称引用特定 bean，限定符值在类型匹配集中只是具有缩小的语义，它们在语义上不表示对唯一 bean id 的引用。良好的限定符值是 main 或 EMEA 或 persistent，类似这些，不同于自动生成的 bean id。</p>
<p>限定符也适用于类型化集合，比如前面的 <code>Set&lt;MovieCatalog&gt;</code>。在这种情况下，根据声明的限定符，所有匹配的 bean 都作为集合注入。这意味着限定符不必是唯一的，它们只是一个过滤条件。例如，您可以使用相同的限定符值 <code>action</code> 定义多个 MovieCatalog bean，所有这些 bean 都注入到使用 <code>@Qualifier(&quot;action&quot;)</code> 注解的 <code>Set&lt;MovieCatalog&gt;</code> 中。</p>
<blockquote>
<p>在类型匹配候选项中，根据目标 bean 名称选择限定符值，在注入点不需要 <code>@Qualifier</code> 注释。如果没有其他解析指示符（例如限定符或主要标记），则对于非唯一依赖性情况，Spring 会将注入点名称（即字段名称或参数名称）与目标 bean 名称进行匹配，然后选择同名的候选人，如果有的话。</p>
<p>也就是说，如果您打算按名称表达注释驱动的注入，请不要主要使用 <code>@Autowired</code>，即使它能够在类型匹配候选项中通过 bean 名称进行选择。相反，使用 JSR-250 <code>@Resource</code> 注释，该注释在语义上定义为通过其唯一名称标识特定目标组件，声明的类型与匹配过程无关。 <code>@Autowired</code> 具有相当不同的语义：在按类型选择候选 bean 之后，仅在那些类型选择的候选项中考虑指定的字符串限定符值（例如，将 <code>account</code> 限定符与标记有相同限定符标签的 bean 匹配）。</p>
<p>对于自身定义为集合，Map 或数组类型的 bean，<code>@Resource</code> 是一个很好的解决方案，通过唯一名称引用特定的集合或数组 bean。也就是说，从 4.3 版本开始，只要元素类型信息保存在 <code>@Bean</code> 返回类型签名或集合继承层次结构中，您就可以通过 Spring 的 <code>@Autowired</code> 类型匹配算法匹配 Map 和数组类型。在这种情况下，您可以使用限定符值在相同类型的集合中进行选择，如上一段所述。</p>
<p>从 4.3 开始，<code>@Autowired</code> 还会考虑自引用注入（即，引用回到当前注入的 bean）。请注意，自我注入是一种后备。对其他组件的常规依赖性始终具有优先权。从这个意义上说，自我引用并不参与常规的候选人选择，因此从不是主要的。相反，它们总是最低优先级。在实践中，您应该仅使用自引用作为最后的手段（例如，通过 bean 的事务代理调用同一实例上的其他方法）。考虑在这种情况下将受影响的方法分解为单独的委托 bean。或者，您可以使用 <code>@Resource</code>，它可以通过其唯一名称获取代理回到当前 bean。</p>
<p><code>@Autowired</code> 适用于字段，构造函数和多参数方法，允许在参数级别缩小限定符注释。相比之下，<code>@Resource</code> 仅支持字段和具有单个参数的 bean 属性 setter 方法。因此，如果注射目标是构造函数或多参数方法，则应该使用限定符。</p>
</blockquote>
<p>我们可以创建自己的自定义限定符注释，需要定义注释并在定义中提供 <code>@Qualifier</code> 注释，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Genre &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Genre</span>(<span class="string">"Action"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComedyCatalog</span><span class="params">(@Genre(<span class="string">"Comedy"</span>)</span> MovieCatalog comedyCatalog) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，您可以提供候选 bean 定义的信息。 您可以将 <code>&lt;qualifier/&gt;</code> 标记添加为 <code>&lt;bean/&gt;</code> 标记的子元素，然后指定与自定义限定符注释匹配的类型和值。 类型与注释的完全限定类名匹配。或者，为方便起见，如果不存在冲突名称的风险，您可以使用短类名称。以下示例演示了这两种方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"Genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"example.Genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Genre</span>(<span class="string">"Action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个后文会细讲。</p>
<p>在某些情况下，使用没有值的注释可能就足够了。当注释用于更通用的目的并且可以应用于多种不同类型的依赖项时，这可能很有用。例如，您可以提供可在没有 Internet 连接时搜索的脱机目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Offline &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Offline</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog offlineCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以定义除简单值属性之外或代替简单值属性接受命名属性的自定义限定符注释。如果随后在要自动装配的字段或参数上指定了多个属性值，则 bean 定义必须匹配所有此类属性值才能被视为自动装配候选：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">genre</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Format <span class="title">format</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Action"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Comedy"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.DVD, genre=<span class="string">"Action"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.BLURAY, genre=<span class="string">"Comedy"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型微调自动装配"><a href="#泛型微调自动装配" class="headerlink" title="泛型微调自动装配"></a>泛型微调自动装配</h3><p>除了<code>@Qualifier</code>注释之外，您还可以使用 Java 泛型类型作为隐式的限定形式。例如，假设您具有以下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设前面的 bean 实现了一个通用接口（即 <code>Store&lt;String&gt;</code> 和 <code>Store&lt;Integer&gt;</code>），你可以 <code>@Autowire</code> Store 接口，并将泛型用作限定符，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span></span><br></pre></td></tr></table></figure>

<p>通用限定符也适用于自动装配列表，Map 实例和数组。以下示例自动装配通用 List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span></span><br><span class="line"><span class="comment">// Store&lt;String&gt; beans will not appear in this list</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h3 id="使用-CustomAutowireConfigurer"><a href="#使用-CustomAutowireConfigurer" class="headerlink" title="使用 CustomAutowireConfigurer"></a>使用 CustomAutowireConfigurer</h3><p>CustomAutowireConfigurer 是一个 BeanFactoryPostProcessor，它允许注册自己的自定义限定符注释类型，即使它们没有使用 Spring 的 <code>@Qualifier</code> 注释进行注释。 以下示例显示如何使用 CustomAutowireConfigurer：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customAutowireConfigurer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.CustomAutowireConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customQualifierTypes"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example.CustomQualifier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>AutowireCandidateResolver 通过以下方式确定 autowire 候选者：</p>
<ul>
<li><p>每个 bean 定义的 autowire-candidate 值</p>
</li>
<li><p><code>&lt;beans/&gt;</code>元素上可用的任何 default-autowire 候选模式</p>
</li>
<li><p>存在 <code>@Qualifier</code> 注释以及使用 CustomAutowireConfigurer 注册的任何自定义注释</p>
</li>
</ul>
<p>当多个 bean 有资格作为 autowire 候选者时，“primary”的确定如下：当候选者中刚好只有一个 bean 定义的 primary 属性设置为 true，就选择它。</p>
<h3 id="使用-Resource-注入"><a href="#使用-Resource-注入" class="headerlink" title="使用 @Resource 注入"></a>使用 @Resource 注入</h3><p>Spring 还通过对字段或 bean 属性 setter 方法使用 JSR-250 <code>@Resource</code> 注释（javax.annotation.Resource）来支持注入。这是 Java EE 中的常见模式：例如，在 JSF 管理的 bean 和 JAX-WS 端点中。Spring 也支持 Spring 管理对象的模式。</p>
<p><code>@Resource</code> 采用名称属性。默认情况下，Spring 将该值解释为要注入的 bean 名称。换句话说，它遵循按名称语义，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"myMovieFinder"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未明确指定名称，则默认名称是从字段名称或 setter 方法派生的。如果是字段，则采用字段名称。在 setter 方法的情况下，它采用 bean 属性名称。下面的例子将把 movieFinder bean 注入其 setter 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释中的 name 由 ApplicationContext 解析为 bean 名称，由 CommonAnnotationBeanPostProcessor 拿到该名称。如果显式配置 Spring 的 SimpleJndiBeanFactory，则可以通过 JNDI 解析名称。但是，我们建议您依赖于默认行为并使用 Spring 的 JNDI 查找功能来保证间接级别。</p>
</blockquote>
<p>在某些特殊情况下 <code>@Resource</code> 不指定明确的名称，与 <code>@Autowired</code> 类似，<code>@Resource</code> 会不看名称，使用主要类型匹配，这些情况包括以下类：BeanFactory， ApplicationContext，ResourceLoader，ApplicationEventPublisher 和 MessageSource 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-PostConstruct-和-PreDestroy"><a href="#使用-PostConstruct-和-PreDestroy" class="headerlink" title="使用 @PostConstruct 和 @PreDestroy"></a>使用 @PostConstruct 和 @PreDestroy</h3><p>CommonAnnotationBeanPostProcessor 不仅识别 <code>@Resource</code> 注释，还识别 JSR-250 生命周期注释：<code>javax.annotation.PostConstruct</code> 和<code>javax.annotation.PreDestroy</code>。在 Spring 2.5 中引入，对这些注释的支持提供了<a href="#初始化回调">初始化回调</a>和<a href="#销毁回调">销毁回调</a>中描述的生命周期回调机制的替代方法。假如 CommonAnnotationBeanPostProcessor 在 ApplicationContext 中注册，那么带有这些注释的方法会在相应的 Spring 生命周期接口方法或显式声明的回调方法的同时被调用。在以下示例中，缓存在初始化时预填充并在销毁时清除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// populates the movie cache upon initialization...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// clears the movie cache upon destruction...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关组合各种生命周期机制的效果的详细信息，参见上文<a href="#组合生命周期机制">组合生命周期机制</a>。</p>
<blockquote>
<p>与 <code>@Resource</code> 一样，<code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注释类型是 JDK 6 到 8 的标准 Java 库的一部分。但是，整个 javax.annotation 包与 JDK 9 中的核心 Java 模块分离，最终在 JDK 11 中删除。如果需要，现在需要通过 Maven Central 获取 javax.annotation-api 组件，并添加到应用程序的类路径中。</p>
</blockquote>
<h2 id="类路径扫描和托管组件"><a href="#类路径扫描和托管组件" class="headerlink" title="类路径扫描和托管组件"></a>类路径扫描和托管组件</h2><p>本章中的大多数示例都使用 XML 来指定在 Spring 容器中生成每个 BeanDefinition 的配置。 上一节（基于注释的容器配置）演示了如何通过源级注释提供大量配置元数据。但是，即使在这些示例中，基本 bean 定义也在 XML 文件中显式定义，而注释仅驱动依赖项注入。本节介绍通过扫描类路径隐式检测候选组件的选项。候选组件是与筛选条件匹配的类，并且具有向容器注册的相应 bean 定义。这消除了使用 XML 执行 bean 注册的需要。相反，您可以使用注释（比如<code>@Component</code>），AspectJ 类型表达式或您自己的自定义筛选条件来选择哪些类具有向容器注册的 bean 定义。</p>
<blockquote>
<p>从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能是核心 Spring Framework 的一部分。这使您可以使用 Java 而不是使用传统的 XML 文件来定义 bean。看看的@Configuration，@Bean， @Import，和@DependsOn 注释有关如何使用这些新功能的例子。</p>
</blockquote>
<h3 id="Component-和更多的-Stereotype-注释"><a href="#Component-和更多的-Stereotype-注释" class="headerlink" title="@Component 和更多的 Stereotype 注释"></a>@Component 和更多的 Stereotype 注释</h3><p><code>@Repository</code> 注解是实现存储库的角色或构造型（也称为数据访问对象或 DAO）的任何类的标记。 该标记的用途包括自动翻译异常，详见“异常翻译”。</p>
<p>Spring 提供了进一步的构造型注释：<code>@Component</code>，<code>@Service</code> 和 <code>@Controller</code>。<code>@Component</code> 是任何 Spring 托管组件的通用构造型。 <code>@Repository</code>，<code>@Service</code> 和<code>@Controller</code> 是 <code>@Component</code> 的特化，用于更具体的用例（分别在持久层，服务层和表示层中）。因此，您可以使用 <code>@Component</code> 来注释组件类，但是通过使用 <code>@Repository</code>，<code>@Service</code> 或 <code>@Controller</code> 来注释组件类，您的类更适合于通过工具进行处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 <code>@Repository</code>，<code>@Service</code> 和 <code>@Controller</code> 在 Spring 框架的将来版本中也可以带有其他语义。因此，如果在服务层使用 <code>@Component</code> 或 <code>@Service</code> 之间进行选择，则 <code>@Service</code> 显然是更好的选择。同样，如前所述，<code>@Repository</code> 已被支持作为持久层中自动异常转换的标记。</p>
<h3 id="使用元注释和组合注释"><a href="#使用元注释和组合注释" class="headerlink" title="使用元注释和组合注释"></a>使用元注释和组合注释</h3><p>Spring 提供的许多注释都可以在您自己的代码中用作元注释。元注释是可以应用于另一个注释的注释。例如，前面提到的 <code>@Service</code> 注释使用 <code>@Component</code> 进行元注释，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Service</code> 的处理方式与 <code>@Component</code> 相同。</p>
<p>您还可以组合元注释来创建“组合注释”。 例如，Spring MVC 中的 <code>@RestController</code> 批注由 <code>@Controller</code> 和 <code>@ResponseBody</code> 组成。</p>
<p>此外，组合注释可以选择从元注释中重新声明属性，以允许自定义。当您只希望公开元注释属性的子集时，此功能特别有用。例如，Spring 的 <code>@SessionScope</code>注释将作用域名称硬编码为会话，但仍允许自定义 proxyMode。以下清单显示了 <code>SessionScope</code> 批注的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_SESSION)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SessionScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for &#123;<span class="doctag">@link</span> Scope#proxyMode&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Defaults to &#123;<span class="doctag">@link</span> ScopedProxyMode#TARGET_CLASS&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = Scope.class)</span><br><span class="line">    <span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionScopedService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以覆盖 proxyMode 的值，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope</span>(proxyMode = ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionScopedUserService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动检测类并注册-Bean-定义"><a href="#自动检测类并注册-Bean-定义" class="headerlink" title="自动检测类并注册 Bean 定义"></a>自动检测类并注册 Bean 定义</h3><p>Spring 可以自动检测构造型类，并向 ApplicationContext 注册相应的 BeanDefinition 实例。 例如，以下两个类别有资格进行这种自动检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要自动检测这些类并注册相应的 bean，您需要添加 @ComponentScan 到@Configuration 类中，其中 basePackages 属性是两个类的公共父包。（或者，您可以指定一个逗号分隔，分号分隔或空格分隔的列表，其中包括每个类的父包。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为简便起见，前面的示例可能使用了 注释的 value 属性（即 <code>@ComponentScan(&quot;org.example&quot;)</code> ）。</p>
</blockquote>
<blockquote>
<p>扫描类路径包需要在类路径中存在相应的目录条目。使用 Ant 构建 JAR 时，请确保未激活 JAR 任务的仅文件开关。此外，在某些环境中，可能不会基于安全策略公开类路径目录，例如，在 JDK 1.7.0_45 及更高版本上的独立应用程序（这需要在清单中设置“受信任的库”-请参阅 <a href="https://stackoverflow.com/Questions/19394570/java-jre-7u45-breaks-classloader-getresources）。" target="_blank" rel="noopener">https://stackoverflow.com/Questions/19394570/java-jre-7u45-breaks-classloader-getresources）。</a><br>在 JDK 9 的模块路径（Jigsaw）上，Spring 的类路径扫描通常可以按预期进行。但是，请确保将组件类导出到 module-info 描述符中。如果您期望 Spring 调用您的类的非公共成员，请确保它们是“打开的”（也就是说，它们使用 opens 声明而不是描述符中的 exports 声明 module-info）。</p>
</blockquote>
<p>此外，当您使用 component-scan 元素时，AutowiredAnnotationBeanPostProcessor 和 CommonAnnotationBeanPostProcessor 都隐式包括在内。这意味着将自动检测这两个组件并将它们连接在一起，而这一切都不需要 XML 中提供的任何 bean 配置元数据。</p>
<blockquote>
<p>您可以通过将注释配置属性包括为 false 来禁用 AutowiredAnnotationBeanPostProcessor 和 CommonAnnotationBeanPostProcessor 的注册。</p>
</blockquote>
<h3 id="使用过滤器自定义扫描"><a href="#使用过滤器自定义扫描" class="headerlink" title="使用过滤器自定义扫描"></a>使用过滤器自定义扫描</h3><p>默认情况下，只有使用 <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code> 进行注释的类或使用 <code>@Component</code> 进行注释的自定义注释是可以被检测到的候选组件。但是，您可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为 <code>@ComponentScan</code> 批注的 includeFilters 或 excludeFilters 参数（或作为 component-scan 元素的 include-filter 或 exclude-filter 子元素）。每个过滤器元素都需要 type 和 expression 属性。 下表描述了过滤选项：</p>
<table>
<thead>
<tr>
<th>过滤器类型</th>
<th>范例表达</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>注释（默认）</td>
<td>org.example.SomeAnnotation</td>
<td>在目标组件的类型级别上存在的注释。</td>
</tr>
<tr>
<td>分配</td>
<td>org.example.SomeClass</td>
<td>目标组件可分配给（扩展或实现）的类（或接口）。</td>
</tr>
<tr>
<td>AspectJ</td>
<td>org.example..*Service+</td>
<td>目标组件要匹配的 AspectJ 类型表达式。</td>
</tr>
<tr>
<td>正则表达式</td>
<td>org.example.Default.*</td>
<td>要与目标组件类名称匹配的正则表达式。</td>
</tr>
<tr>
<td>自定义</td>
<td>org.example.MyTypeFilter</td>
<td>org.springframework.core.type.TypeFilter 接口的自定义实现。</td>
</tr>
</tbody></table>
<p>以下示例显示了忽略所有 <code>@Repository</code> 注释并改为使用“存根”存储库的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>,</span><br><span class="line">        includeFilters = <span class="meta">@Filter</span>(type = FilterType.REGEX, pattern = <span class="string">".*Stub.*Repository"</span>),</span><br><span class="line">        excludeFilters = <span class="meta">@Filter</span>(Repository.class))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以通过在注释上设置 <code>useDefaultFilters = false</code> 或通过将 <code>use-default-filters=“false”</code> 作为 <code>&lt;component-scan/&gt;</code> 元素的属性来禁用默认过滤器。这将禁用对<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code> 或 <code>@Configuration</code> 注释的类的自动检测。</p>
<h3 id="在组件中定义-Bean-元数据"><a href="#在组件中定义-Bean-元数据" class="headerlink" title="在组件中定义 Bean 元数据"></a>在组件中定义 Bean 元数据</h3><p>Spring 组件还可以将 bean 定义元数据贡献给容器。您可以 <code>@Bean</code> 使用与在带 <code>@Configuration</code> 注释的类中定义 Bean 元数据相同的注释来执行此操作。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"public"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"publicInstance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Component method implementation omitted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一类是 Spring 组件，在其 <code>doWork()</code> 方法中具有特定于应用程序的代码。 但是，它也提供了一个具有工厂方法的 bean 定义，该工厂方法引用了方法 <code>publicInstance()</code>。<code>@Bean</code> 批注标识工厂方法和其他 bean 定义属性，例如通过 <code>@Qualifier</code> 批注的限定符。可以指定其他的方法级别注释比如 <code>@Scope</code>，<code>@Lazy</code> 和自定义限定符注释。</p>
<blockquote>
<p>除了用于组件初始化的角色外，您还可以将 <code>@Lazy</code> 批注放置在标有 <code>@Autowired</code> 或 <code>@Inject</code> 的注入点上。在这种情况下，它导致了惰性解析代理的注入。</p>
</blockquote>
<p>如前所述，除了支持自动装配的字段和方法，还支持自动装配@Bean 方法。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"public"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"publicInstance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use of a custom qualifier and autowiring of method parameters</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TestBean <span class="title">protectedInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"public"</span>)</span> TestBean spouse,</span></span><br><span class="line"><span class="function">            @<span class="title">Value</span><span class="params">(<span class="string">"#&#123;privateInstance.age&#125;"</span>)</span> String country) </span>&#123;</span><br><span class="line">        TestBean tb = <span class="keyword">new</span> TestBean(<span class="string">"protectedInstance"</span>, <span class="number">1</span>);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        <span class="keyword">return</span> tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TestBean <span class="title">privateInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"privateInstance"</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@RequestScope</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">requestScopedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"requestScopedInstance"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例将 String 方法参数国家/地区自动连线到另一个名为 privateInstance 的 bean 上 age 属性的值。Spring Expression Language 元素通过符号 <code>＃{&lt;expression&gt;}</code> 定义属性的值。对于 <code>@Value</code> 批注，表达式解析程序已预先配置为在解析表达式文本时查找 bean 名称。</p>
<p>从 Spring Framework 4.3 开始，您还可以声明类型为 InjectionPoint 的工厂方法参数（或更具体的子类：DependencyDescriptor），以访问触发当前 bean 创建的请求注入点。请注意，这仅适用于实际创建的 Bean 实例，不适用于注入现有实例。因此，此功能对原型范围的 bean 最有意义。对于其他作用域，factory 方法仅在给定作用域中看到触发创建新 bean 实例的注入点（例如，触发创建惰性单例 bean 的依赖项）。 在这种情况下，可以将提供的注入点元数据与语义一起使用。 以下示例显示了如何使用 InjectionPoint：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">prototypeInstance</span><span class="params">(InjectionPoint injectionPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"prototypeInstance for "</span> + injectionPoint.getMember());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常规 Spring 组件中的 <code>@Bean</code> 方法的处理方式与 Spring <code>@Configuration</code> 类中的 <code>@Bean</code> 方法不同。区别在于，<code>@Component</code> 类没有使用 CGLIB 来拦截方法和字段的调用。 CGLIB 代理是一种调用 <code>@Configuration</code> 类中 <code>@Bean</code> 方法中的方法或字段的方法，用于创建 Bean 元数据引用以协作对象。此类方法不是使用常规 Java 语义调用的，而是通过容器进行的，以提供通常的生命周期管理和 Spring Bean 的代理，即使通过 <code>@Bean</code> 方法的编程调用引用其他 Bean 时也是如此。相反，在普通 <code>@Component</code> 类内的 <code>@Bean</code> 方法中调用方法或字段具有标准 Java 语义，而无需特殊的 CGLIB 处理或其他约束。</p>
<blockquote>
<p>您可以将 <code>@Bean</code> 方法声明为静态方法，从而允许在不将其包含配置类创建为实例的情况下调用它们。在定义后处理器 Bean（例如 BeanFactoryPostProcessor 或 BeanPostProcessor 类型）时，这特别有意义，因为此类 Bean 在容器生命周期的早期进行了初始化，并且应避免在那时触发配置的其他部分。</p>
<p>由于技术限制，对静态 <code>@Bean</code> 方法的调用永远不会被容器拦截，即使在 <code>@Configuration</code> 类中也是如此（如本节前面所述），由于技术限制：CGLIB 子类只能覆盖非静态方法。结果，直接调用另一个 <code>@Bean</code> 方法具有标准的 Java 语义，从而导致直接从工厂方法本身直接返回一个独立的实例。</p>
<p>@Bean 方法的 Java 语言可见性不会对 Spring 容器中的最终 bean 定义产生直接影响。您可以在非 <code>@Configuration</code> 类中自由声明自己的工厂方法，也可以在任何地方声明静态方法。但是，<code>@Configuration</code> 类中的常规 <code>@Bean</code> 方法必须是可重写的——即，不得将它们声明为 private 或 final。</p>
<p>还可以在给定组件或配置类的基类上以及在由组件或配置类实现的接口中声明的 Java 8 默认方法上发现 <code>@Bean</code> 方法。这为组合复杂的配置安排提供了很大的灵活性，从 Spring 4.2 开始，通过 Java 8 默认方法甚至可以进行多重继承。</p>
<p>最后，一个类可以为同一个 bean 保留多个 <code>@Bean</code> 方法，这取决于在运行时可用的依赖关系，从而可以使用多个工厂方法。这与在其他配置方案中选择“最贪婪”的构造函数或工厂方法的算法相同：在构造时选择具有最大可满足依赖关系数量的变量，类似于容器在多个 <code>@Autowired</code> 构造函数之间进行选择的方式。</p>
</blockquote>
<h3 id="命名自动检测的组件"><a href="#命名自动检测的组件" class="headerlink" title="命名自动检测的组件"></a>命名自动检测的组件</h3><p>在扫描过程中自动检测到组件时，其 bean 名称由该扫描程序已知的 BeanNameGenerator 策略生成。 默认情况下，任何包含名称值的 Spring 构造型注释（<code>@Component</code>，<code>@Repository</code>，<code>@Service</code> 和 <code>@Controller</code>）都会将该名称提供给相应的 bean 定义。</p>
<p>如果这样的注释不包含名称，value 或者不包含任何其他检测到的组件（例如，通过自定义过滤器发现的组件），则缺省 bean 名称生成器将返回未大写的非限定类名称。例如，如果检测到以下组件类，则名称为 myMovieLister 和 movieFinderImpl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"myMovieLister"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果您不想依赖默认的 Bean 命名策略，则可以提供自定义 Bean 命名策略。首先，实现 BeanNameGenerator 接口，并确保包括默认的无参构造函数。然后，在配置扫描器时提供完全限定的类名，如以下示例注释和 Bean 定义所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, nameGenerator = MyNameGenerator.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name-generator</span>=<span class="string">"org.example.MyNameGenerator"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作为一般规则，每当其他组件可能对其进行显式引用时，请考虑使用注释指定名称。另一方面，只要容器负责接线，自动生成的名称就足够了。</p>
<h3 id="提供自动检测组件的范围"><a href="#提供自动检测组件的范围" class="headerlink" title="提供自动检测组件的范围"></a>提供自动检测组件的范围</h3><p>通常，与 Spring 管理的组件一样，自动检测到的组件的默认且最常见的作用域是单例。 但是，有时您需要使用@Scope 批注指定的其他范围。 您可以在注释中提供范围的名称，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Scope</code> 注释仅在具体的 bean 类（对于带注释的组件）或工厂方法（对于 <code>@Bean</code> 方法）上进行内省。 与 XML bean 定义相反，没有 bean 定义继承的概念，并且在类级别的继承层次结构与元数据目的无关。</p>
<p>有关特定于 Web 的范围的详细信息，例如 Spring 上下文中的“request”或“session”，请参见 Request，Session，Application 和 WebSocket Scope。与这些作用域的预构建批注一样，您也可以使用 Spring 的元注释方法来组成自己的作用域注释：例如，用@Scope(“prototype”)，进行元注释的自定义注释，也可能会声明自定义作用域代理模式。</p>
<blockquote>
<p>要提供用于范围解析的自定义策略，而不是依赖于基于注释的方法，可以实现该 ScopeMetadataResolver 接口。确保包括默认的无参数构造函数。然后，可以在配置扫描程序时提供完全限定的类名，如以下注释和 Bean 定义示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, scopeResolver = MyScopeResolver.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">scope-resolver</span>=<span class="string">"org.example.MyScopeResolver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用某些非单作用域时，可能有必要为作用域对象生成代理。在范围 Bean 中将推理描述为依赖项。为此，在 component-scan 元素上可以使用 scoped-proxy 属性。三个可能的值是：no，interfaces，和 targetClass。例如，以下配置生成标准的 JDK 动态代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, scopedProxy = ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">scoped-proxy</span>=<span class="string">"interfaces"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="提供带有注释的限定符元数据"><a href="#提供带有注释的限定符元数据" class="headerlink" title="提供带有注释的限定符元数据"></a>提供带有注释的限定符元数据</h3><p>在@Qualifier 注释中讨论与预选赛微调基于注解的自动连接。该部分中的示例演示了如何使用@Qualifier 注释和自定义限定符注释在解析自动装配候选时提供细粒度的控制。由于这些示例基于 XML Bean 定义，因此通过使用 XML 中的元素的 qualifier 或 meta 子元素，在候选 Bean 定义上提供了限定符元数据 bean。当依靠类路径扫描来自动检测组件时，可以在候选类上为限定符元数据提供类型级别的注释。下面的三个示例演示了此技术：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"Action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Genre</span>(<span class="string">"Action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Offline</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与大多数基于注释的替代方法一样，请记住，注释元数据绑定到类定义本身，而 XML 的使用允许相同类型的多个 bean 提供其限定符元数据的变体，因为该元数据是按-instance 而不是按类。</p>
</blockquote>
<h3 id="生成候选组件的索引"><a href="#生成候选组件的索引" class="headerlink" title="生成候选组件的索引"></a>生成候选组件的索引</h3><p>尽管类路径扫描非常快，但可以通过在编译时创建静态候选列表来提高大型应用程序的启动性能。在这种模式下，作为组件扫描目标的所有模块都必须使用此机制。</p>
<blockquote>
<p>您现有的 <code>@ComponentScan</code> 或 <code>&lt;context:component-scan&gt;</code> 指令必须保持原样，以请求上下文扫描某些软件包中的候选对象。当 ApplicationContext 检测到这样的索引时，它将自动使用它而不是扫描类路径。</p>
</blockquote>
<p>要生成索引，请向每个包含组件的模块添加附加依赖关系，这些组件是组件扫描指令的目标。以下示例显示了如何使用 Maven 进行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于 Gradle 4.5 和更早版本，应在 <code>compileOnly</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">"org.springframework:spring-context-indexer:5.1.8.RELEASE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Gradle 4.6 及更高版本，应在 <code>annotationProcessor</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    annotationProcessor <span class="string">"org.springframework:spring-context-indexer:5.1.8.RELEASE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程将生成一个 <code>META-INF/spring.components</code> 包含在 jar 文件中的文件。</p>
<blockquote>
<p>在 IDE 中使用此模式时，<code>spring-context-indexer</code> 必须将其注册为注释处理器，以确保在更新候选组件时索引是最新的。</p>
<p><code>META-INF/spring.components</code>在类路径上找到 <code>a</code> 时，索引将自动启用。如果某个索引对于某些库（或用例）部分可用，但无法为整个应用程序构建，则可以通过将设置 <code>spring.index.ignore</code>为 <code>true</code>，来回退到常规的类路径安排（好像根本没有索引）属性或 <code>spring.properties</code> 类路径根目录下的文件中。</p>
</blockquote>
<h2 id="使用-JSR-330-标准注释"><a href="#使用-JSR-330-标准注释" class="headerlink" title="使用 JSR 330 标准注释"></a>使用 JSR 330 标准注释</h2><p>从 Spring 3.0 开始，Spring 提供对 JSR-330 标准注释（依赖注入）的支持。这些注释的扫描方式与 Spring 注释的扫描方式相同。要使用它们，您需要在类路径中有相关的 jar。</p>
<blockquote>
<p>如果使用 Maven，<code>javax.inject</code> 则可以在标准 Maven 存储库（<a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/）中找到该工件。您可以将以下依赖项添加到文件" target="_blank" rel="noopener">https://repo1.maven.org/maven2/javax/inject/javax.inject/1/）中找到该工件。您可以将以下依赖项添加到文件</a> pom.xml 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="与-Inject-和的依赖注入-Named"><a href="#与-Inject-和的依赖注入-Named" class="headerlink" title="与 @Inject 和的依赖注入 @Named"></a>与 @Inject 和的依赖注入 @Named</h2><p>除了 <code>@Autowired</code>，您可以使用 <code>@javax.inject.Inject</code> 以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMovies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder.findMovies(...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与一样 <code>@Autowired</code>，您可以 <code>@Inject</code> 在字段级别，方法级别和构造函数参数级别使用。此外，您可以将注入点声明为 <code>Provider</code>，以允许按需访问范围更短的 bean，或者通过 <code>Provider.get()</code> 调用延迟访问其他 bean 。以下示例提供了先前示例的变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Provider&lt;MovieFinder&gt; movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(Provider&lt;MovieFinder&gt; movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMovies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder.get().findMovies(...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要为应该注入的依赖项使用限定名称，则应使用 <code>@Named</code> 批注，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(@Named(<span class="string">"main"</span>)</span> MovieFinder movieFinder) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与一样 <code>@Autowired</code>，<code>@Inject</code> 也可以与 <code>java.util.Optional</code> 或一起使用<code>@Nullable</code>。这在这里更为适用，因为 <code>@Inject</code> 它没有 <code>required</code> 属性。以下示例展示了如何使用 <code>@Inject</code> 和 <code>@Nullable</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(@Nullable MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Named-和-ManagedBean：-Component-注释的标准等效项"><a href="#Named-和-ManagedBean：-Component-注释的标准等效项" class="headerlink" title="@Named 和 @ManagedBean：@Component 注释的标准等效项"></a>@Named 和 @ManagedBean：@Component 注释的标准等效项</h3><p>代替@Component，您可以使用@javax.inject.Named 或 javax.annotation.ManagedBean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span>(<span class="string">"movieListener"</span>)  <span class="comment">// @ManagedBean("movieListener") could be used as well</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>@Component</code> 不指定组件名称的情况下使用非常常见。<code>@Named</code> 可以类似的方式使用，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>@Named</code>或 <code>@ManagedBean</code> 时，可以使用与使用 Spring 注释完全相同的方式来使用组件扫描，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与相比@Component，JSR-330 @Named 和 JSR-250 ManagedBean 注释是不可组合的。您应该使用 Spring 的构造型模型来构建自定义组件注释。</p>
</blockquote>
<h3 id="JSR-330-标准注释的局限性"><a href="#JSR-330-标准注释的局限性" class="headerlink" title="JSR-330 标准注释的局限性"></a>JSR-330 标准注释的局限性</h3><p>当使用标准注释时，您应该知道某些重要功能不可用，如下表所示：</p>
<p>表 6. Spring 组件模型元素与 JSR-330 变体</p>
<table>
<thead>
<tr>
<th>Spring</th>
<th>javax.inject.*</th>
<th>javax.inject 限制/注释</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>@Inject</td>
<td>@Inject 没有“必填”属性。可以与 Java 8 一起使用 Optional。</td>
</tr>
<tr>
<td>@Component</td>
<td>@Named / @ManagedBean</td>
<td>JSR-330 不提供可组合的模型，仅提供一种识别命名组件的方法。</td>
</tr>
<tr>
<td>@Scope(“singleton”)</td>
<td>@Singleton</td>
<td>JSR-330 的默认范围类似于 Spring 的 prototype。但是，为了使其与 Spring 的默认默认值保持一致，默认情况下，在 Spring 容器中声明的 JSR-330 bean 是 a singleton。为了使用之外的范围 singleton，您应该使用 Spring 的@Scope 注释。<code>javax.inject</code> 还提供了 @Scope 批注。不过，此仅用于创建自己的注释。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>@Qualifier / @Named</td>
<td>javax.inject.Qualifier 只是用于构建自定义限定符的元注释。具体的 String 限定词（例如@Qualifier 带有值的 Spring 的限定词）可以通过关联 javax.inject.Named。</td>
</tr>
<tr>
<td>@Value</td>
<td>-</td>
<td>没有等效</td>
</tr>
<tr>
<td>@Required</td>
<td>-</td>
<td>没有等效</td>
</tr>
<tr>
<td>@Lazy</td>
<td>-</td>
<td>没有等效</td>
</tr>
<tr>
<td>ObjectFactory</td>
<td>Provider</td>
<td>javax.inject.Provider 是 Spring 的直接替代方法 ObjectFactory，只是 get()方法名称较短。它也可以与 Spring @Autowired 或非注释构造函数和 setter 方法结合使用。</td>
</tr>
</tbody></table>
<h2 id="基于-Java-的容器配置"><a href="#基于-Java-的容器配置" class="headerlink" title="基于 Java 的容器配置"></a>基于 Java 的容器配置</h2><p>本节介绍如何在 Java 代码中使用注释来配置 Spring 容器。它包括以下主题：</p>
<ul>
<li>基本概念：<code>@Bean</code> 和 <code>@Configuration</code></li>
<li>使用实例化 Spring 容器 AnnotationConfigApplicationContext</li>
<li>使用@Bean 注释</li>
<li>使用@Configuration 注释</li>
<li>组成基于 Java 的配置</li>
<li>Bean 定义配置文件</li>
<li>PropertySource 抽象化</li>
<li>运用 @PropertySource</li>
<li>声明中的占位符解析</li>
</ul>
<h3 id="基本概念：-Bean-和-Configuration"><a href="#基本概念：-Bean-和-Configuration" class="headerlink" title="基本概念：@Bean 和 @Configuration"></a>基本概念：<code>@Bean</code> 和 <code>@Configuration</code></h3><p>Spring 的新 Java 配置支持中的主要构件是 <code>@Configuration</code> 注释的类和 <code>@Bean</code> 注释的方法。</p>
<p><code>@Bean</code>批注用于指示方法实例化，配置和初始化要由 Spring IoC 容器管理的新对象。 对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code> XML 配置的人来说，<code>@Bean</code> 注释与 <code>&lt;bean/&gt;</code>元素具有相同的作用。 您可以将 <code>@Bean</code> 批注方法与任何 Spring <code>@Component</code> 一起使用。 但是，它们最常与 <code>@Configuration</code> bean 一起使用。</p>
<p>用注释类 <code>@Configuration</code> 表示其主要目的是作为 Bean 定义的来源。此外，<code>@Configuration</code> 类允许通过调用 <code>@Bean</code> 同一类中的其他方法来定义 Bean 之间的依赖关系。最简单的 <code>@Configuration</code> 类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一 <code>AppConfig</code> 类等效于以下 Spring <code>&lt;beans/&gt;</code> XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"com.acme.services.MyServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>完整的 <code>@Configuration</code> 与“精简” <code>@Bean</code> 模式？</p>
<p>如果在未使用 <code>@Configuration</code> 注释的类中声明 <code>@Bean</code> 方法，则将它们称为以“精简”模式进行处理。在 <code>@Component</code> 或是甚至在简单的旧类中声明的 Bean 方法被认为是“精简版”，其中包含类的主要目的不同，而 <code>@Bean</code> 方法在那里具有某种优势。例如，服务组件可以通过每个适用组件类上的其他 <code>@Bean</code> 方法将管理视图公开给容器。在这种情况下，<code>@Bean</code> 方法是一种通用的工厂方法机制。</p>
<p>与完整的 <code>@Configuration</code> 不同，精简 <code>@Bean</code> 方法无法声明 Bean 之间的依赖关系。取而代之的是，它们在其包含组件的内部状态上进行操作，并且还可以根据其可能声明的参数进行操作。因此，此类 <code>@Bean</code> 方法不应调用其他 <code>@Bean</code> 方法。实际上，每个此类方法仅是用于特定 bean 引用的工厂方法，而没有任何特殊的运行时语义。这里的积极副作用是，不必在运行时应用 CGLIB 子类，因此在类设计方面没有任何限制（即，包含类可能是 final 修饰之类的）。</p>
<p>在常见情况下，<code>@Bean</code> 方法将在 <code>@Configuration</code> 类中声明，以确保始终使用“完全”模式，因此跨方法引用将重定向到容器的生命周期管理。这样可以防止通过常规 Java 调用意外地调用同一 <code>@Bean</code> 方法，从而有助于减少在“精简”模式下运行时难以追查的细微错误。</p>
</blockquote>
<p>以下各节将详细讨论 <code>@Bean</code> 和 <code>@Configuration</code> 批注。 但是，首先，我们介绍了使用基于 Java 的配置来创建 spring 容器的各种方法。</p>
<h3 id="使用实例化-Spring-容器-AnnotationConfigApplicationContext"><a href="#使用实例化-Spring-容器-AnnotationConfigApplicationContext" class="headerlink" title="使用实例化 Spring 容器 AnnotationConfigApplicationContext"></a>使用实例化 Spring 容器 AnnotationConfigApplicationContext</h3><p>以下各节介绍了 Spring 3.0 中引入的 Spring 的 AnnotationConfigApplicationContext。这种通用的 ApplicationContext 实现不仅能够接受 <code>@Configuration</code> 类作为输入，而且还可以接受普通的 <code>@Component</code> 类和带有 JSR-330 元数据注释的类。</p>
<p>当提供 <code>@Configuration</code> 类作为输入时，<code>@Configuration</code> 类本身将注册为 Bean 定义，并且该类中所有已声明的 <code>@Bean</code> 方法也将注册为 Bean 定义。</p>
<p>提供 <code>@Component</code> 和 JSR-330 类时，它们将注册为 bean 定义，并且假定在必要时在这些类中使用了诸如 <code>@Autowired</code> 或 <code>@Inject</code> 之类的 DI 元数据。</p>
<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>与实例化 ClassPathXmlApplicationContext 时将 Spring XML 文件用作输入的方式几乎相同，您可以在实例化 AnnotationConfigApplicationContext 时将 <code>@Configuration</code> 类用作输入。如下面的示例所示，这允许完全不使用 XML 来使用 Spring 容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述，AnnotationConfigApplicationContext 不限于仅与 <code>@Configuration</code> 类一起使用。 可以将任何 <code>@Component</code> 或 JSR-330 带注释的类作为输入提供给构造函数，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的示例假定 MyServiceImpl，Dependency1 和 Dependency2 使用 Spring 依赖项注入注释，例如 <code>@Autowired</code>。</p>
<h4 id="通过使用-register-Class-lt-gt-…​-以编程方式构建容器"><a href="#通过使用-register-Class-lt-gt-…​-以编程方式构建容器" class="headerlink" title="通过使用 register(Class&lt;?&gt;…​) 以编程方式构建容器"></a>通过使用 register(Class&lt;?&gt;…​) 以编程方式构建容器</h4><p>您可以使用无参构造函数实例化 AnnotationConfigApplicationContext，然后使用 register() 方法对其进行配置。以编程方式构建 AnnotationConfigApplicationContext 时，此方法特别有用。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-scan-String…​-启用组件扫描"><a href="#使用-scan-String…​-启用组件扫描" class="headerlink" title="使用 scan(String…​) 启用组件扫描"></a>使用 scan(String…​) 启用组件扫描</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.acme"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.scan(<span class="string">"com.acme"</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>@Configuration</code> 类带有 <code>@Component</code> 元注解，因此是组件扫描的候选对象。在前面的示例中，假定 <code>AppConfig</code> 在 <code>com.acme</code> 包（或下面的任何包）中声明，那么在调用 <code>scan()</code> 时，<code>@Configuration</code> 类被检测到并注册，但不会注册其中的 <code>@Bean</code>。直到调用 <code>refresh()</code> 方法，其所有 <code>@Bean</code> 方法才都被处理并注册为容器内的 Bean 定义。</p>
<h4 id="支持-Web-应用程序的-AnnotationConfigWebApplicationContext"><a href="#支持-Web-应用程序的-AnnotationConfigWebApplicationContext" class="headerlink" title="支持 Web 应用程序的 AnnotationConfigWebApplicationContext"></a>支持 Web 应用程序的 AnnotationConfigWebApplicationContext</h4><p>AnnotationConfigWebApplicationContext = WebApplicationContext + AnnotationConfigApplicationContext，这个实现可以配置 Spring 的 <code>ContextLoaderListener</code> servlet 侦听器, Spring MVC 的 <code>DispatcherServlet</code> 等。以下 web.xml 代码片段配置了典型的 Spring MVC Web 应用程序 (注意 <code>contextClass</code> context-param and init-param 的使用):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">        instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">        fully-qualified @Configuration classes. Fully-qualified packages may also be</span></span><br><span class="line"><span class="comment">        specified for component-scanning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">            instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">            and fully-qualified @Configuration classes --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Bean-注解"><a href="#使用-Bean-注解" class="headerlink" title="使用 @Bean 注解"></a>使用 @Bean 注解</h3><p>@Bean 是方法级别的注解，类似 XML 中的 <code>&lt;bean/&gt;</code> 元素。同时支持提供 <code>&lt;bean/&gt;</code> 的属性，例如：init-method、destroy-method、autowiring。</p>
<p>你可以使用在有 <code>@Configuration</code> 或 <code>@Component</code> 注解的类内使用 <code>@Bean</code> 注释。</p>
<h4 id="声明一个-bean"><a href="#声明一个-bean" class="headerlink" title="声明一个 bean"></a>声明一个 bean</h4><p>要声明一个 bean，可以对方法进行 @Bean 注解。您可以使用此方法在 ApplicationContext 指定为该方法的返回值的类型内注册 Bean 定义。默认情况下，bean 名称与方法名称相同。以下示例显示了@Bean 方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferServiceImpl <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的配置与下面的 Spring XML 完全等效：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个声明都使一个名为 transferService 的 bean 在 ApplicationContext 中可用，并绑定到类型为 TransferServiceImpl 的对象实例，如以下文本镜像所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferService -&gt; com.acme.TransferServiceImpl</span><br></pre></td></tr></table></figure>

<p>您还可以使用接口（或基类）返回类型声明@Bean 方法，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这将高级类型预测的可见性限制为指定的接口类型（TransferService）。然后，使用仅一次使容器知道的完整类型（TransferServiceImpl），就可以实例化受影响的单例 bean。非惰性单例 bean 根据其声明顺序实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试按非声明类型进行匹配（例如@Autowired TransferServiceImpl，仅 transferService 在实例化 bean 后才解析）。</p>
<p>如果您通过声明的服务接口一致地引用类型，则@Bean 返回类型可以安全地加入该设计决策。但是，对于实现多个接口的组件或由其实现类型潜在引用的组件，声明可能的最具体的返回类型（至少与引用您的 bean 的注入点所要求的具体类型一样）更为安全。</p>
<h4 id="Bean-依赖"><a href="#Bean-依赖" class="headerlink" title="Bean 依赖"></a>Bean 依赖</h4><p>带@Bean 注释的方法可以具有任意数量的参数，这些参数描述构建该 bean 所需的依赖关系。例如，如果我们 TransferService 需要一个 AccountRepository，我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析机制与基于构造函数的依赖注入几乎相同。</p>
<h4 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h4><p>用@Bean 注释定义的任何类都支持常规的生命周期回调，并且可以使用 JSR-250 中的@PostConstruct 和@PreDestroy 注释。有关更多详细信息，请参见 JSR-250 注释。</p>
<p>常规 Spring 生命周期回调也得到完全支持。如果 bean 实现 InitializingBean，DisposableBean 或 Lifecycle，则容器将调用它们各自的方法。</p>
<p>也完全支持标准*Aware 接口集（例如 BeanFactoryAware， BeanNameAware， MessageSourceAware， ApplicationContextAware 等）。</p>
<p>该@Bean 注释支持指定任意初始化和销毁回调方法，就像 Spring XML 中的 init-method 和 destroy-method 属性的 bean 元素，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// initialization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// destruction logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"cleanup"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，使用 Java config 定义的具有公开关闭或停止方法的 bean 将自动加入销毁回调。如果你有一个公开的关闭或停止方法，但是你不希望在容器关闭时被调用，只需将@Bean（destroyMethod =””）添加到你的 bean 定义中即可禁用默认（推测）模式。 默认情况下，您可能希望通过 JNDI 获取资源，因为它的生命周期在应用程序之外进行管理。特别地，请确保始终为 DataSource 执行此操作，因为它已知在 Java EE 应用程序服务器上有问题。</p>
<p>默认情况下，您可能要对通过 JNDI 获取的资源执行此操作，因为其生命周期是在应用程序外部进行管理的。特别是，请确保始终对进行操作 DataSource，因为这在 Java EE 应用程序服务器上是有问题的。</p>
<p>以下示例显示了如何防止对的自动销毁回调 DataSource：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (DataSource) jndiTemplate.lookup(<span class="string">"MyDS"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，通过@Bean 方法，通常会选择使用编程来进行 JNDI 查找：要么使用 Spring 的 JndiTemplate/JndiLocatorDelegate 帮助类，要么直接使用 JNDI InitialContext，但不能使用 JndiObjectFactoryBean 变体来强制将返回类型声明为 FactoryBean 类型以代替目标的实际类型，它将使得在其他@Bean 方法中更难用于交叉引用调用这些在此引用提供资源的方法。<br>当然上面的 BeanOne 例子中，在构造期间直接调用 init()方法同样有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanOne beanOne = <span class="keyword">new</span> BeanOne();</span><br><span class="line">        beanOne.init();</span><br><span class="line">        <span class="keyword">return</span> beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您直接在 Java 中工作时，您可以对对象执行任何您喜欢的操作，并不总是需要依赖容器生命周期。</p>
<h4 id="指定-bean-的作用域"><a href="#指定-bean-的作用域" class="headerlink" title="指定 bean 的作用域"></a>指定 bean 的作用域</h4><h5 id="使用-Scope-注解"><a href="#使用-Scope-注解" class="headerlink" title="使用@Scope 注解"></a>使用@Scope 注解</h5><p>你可以指定@Bean 注解定义的 bean 应具有的特定作用域。你可以使用 Bean 作用域章节中的任何标准作用域。</p>
<p>默认的作用域是单例，但是你可以用@Scope 注解重写作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encryptor <span class="title">encryptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Scope-和-scope-代理"><a href="#Scope-和-scope-代理" class="headerlink" title="@Scope 和 scope 代理"></a>@Scope 和 scope 代理</h5><p>Spring 提供了一个通过范围代理来处理范围依赖的便捷方法。使用 XML 配置创建此类代理的最简单方法是元素。使用@Scope 注解配置 Java 中的 bean 提供了与 proxyMode 属性相似的支持。默认是没有代理（ScopedProxyMode.NO），但您可以指定 ScopedProxyMode.TARGET_CLASS 或 ScopedProxyMode.INTERFACES。</p>
<p>如果你使用 Java 将 XML 参考文档（请参阅上述链接）到范围的@Bean 中移植范围限定的代理示例，则它将如下所示<br>如果你将 XML 参考文档的 scoped 代理示例转化为 Java @Bean，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPreferences <span class="title">userPreferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Service <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserService service = <span class="keyword">new</span> SimpleUserService();</span><br><span class="line">    <span class="comment">// a reference to the proxied userPreferences bean</span></span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-Bean-命名"><a href="#自定义-Bean-命名" class="headerlink" title="自定义 Bean 命名"></a>自定义 Bean 命名</h4><p>默认情况下，配置类使用@Bean 方法的名称作为结果 bean 的名称。但是，可以使用 name 属性覆盖此功能，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"myThing"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean-别名"><a href="#Bean-别名" class="headerlink" title="Bean 别名"></a>Bean 别名</h4><p>如前文命名 bean 中所讨论的，有时希望为单个 Bean 提供多个名称，否则会导致 Bean 混淆。 为此 name，@Bean 注释的属性接受 String 数组。以下示例显示了如何为 bean 设置多个别名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(&#123;<span class="string">"dataSource"</span>, <span class="string">"subsystemA-dataSource"</span>, <span class="string">"subsystemB-dataSource"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean-描述"><a href="#Bean-描述" class="headerlink" title="Bean 描述"></a>Bean 描述</h4><p>有时，提供有关 bean 的更详细的文本描述会很有帮助。当出于监视目的而暴露（可能通过 JMX）bean 时，这特别有用。</p>
<p>要将说明添加到@Bean，可以使用 @Description 批注，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"Provides a basic example of a bean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-Configuration-注解"><a href="#使用-Configuration-注解" class="headerlink" title="使用 @Configuration 注解"></a>使用 <code>@Configuration</code> 注解</h3><p><code>@Configuration</code> 是类级别的注释，指示对象是 Bean 定义的源。 <code>@Configuration</code> 类通过公共 <code>@Bean</code> 注释方法声明 bean。 对 <code>@Configuration</code> 类的 <code>@Bean</code> 方法的调用也可以用于定义 Bean 之间的依赖关系。 有关一般性介绍，请参见[基本概念：<code>@Bean</code> 和 <code>@Configuration</code>](&lt;#基本概念：<code>@Bean</code>\ 和\ <code>@Configuration</code>&gt;)。</p>
<h4 id="注入-bean-间的依赖关系"><a href="#注入-bean-间的依赖关系" class="headerlink" title="注入 bean 间的依赖关系"></a>注入 bean 间的依赖关系</h4><p>当 bean 相互依赖时，表示依赖关系就像让一个 bean 方法调用另一个依赖一样简单，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne(beanTwo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仅当 <code>@Bean</code> 在 <code>@Configuration</code> 类中声明该方法时，此声明 bean 间依赖关系的方法才有效。您不能使用普通 <code>@Component</code> 类声明 bean 间的依赖关系。</p>
</blockquote>
<h4 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h4><p>如前所述，<a href="https://halelu.github.io/2019/07/spring-1/#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5">查找方法注入</a>是一项高级功能，您应该很少使用。在单例作用域的 bean 对原型作用域的 bean 有依赖性的情况下，这很有用。将 Java 用于这种类型的配置为实现这种模式提供了自然的方法。以下示例显示如何使用查找方法注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 Java 配置，可以创建一个覆盖 <code>CommandManager</code> 抽象 <code>createCommand()</code> 方法的子类，该方法将以某种方式查找新的（原型）命令对象。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> AsyncCommand <span class="title">asyncCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncCommand command = <span class="keyword">new</span> AsyncCommand();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommandManager <span class="title">commandManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with createCommand()</span></span><br><span class="line">    <span class="comment">// overridden to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有关基于-Java-的配置在内部如何工作的更多信息"><a href="#有关基于-Java-的配置在内部如何工作的更多信息" class="headerlink" title="有关基于 Java 的配置在内部如何工作的更多信息"></a>有关基于 Java 的配置在内部如何工作的更多信息</h4><p>考虑以下示例，该示例显示了一个带 <code>@Bean</code> 注释的方法被调用两次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">clientService1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">clientService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientDao <span class="title">clientDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clientDao()</code> 在 <code>clientService1()</code> 中被调用一次，并在 <code>clientService2()</code> 中被调用一次。由于此方法会创建一个 <code>ClientDaoImpl</code> 的新实例并返回它，因此通常希望有两个实例（每个服务一个）。那肯定是有问题的：在 Spring 中，实例化的 bean 默认情况下具有单例作用域。这就是神奇之处所在：所有 <code>@Configuration</code> 类在启动时都使用 CGLIB 进行了子类化。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器中是否有任何缓存（作用域）的 bean。</p>
<blockquote>
<p>根据 bean 的作用域，行为可能有所不同。我们在这里只谈论单例。</p>
</blockquote>
<blockquote>
<p>从 Spring 3.2 开始，不再需要将 CGLIB 添加到您的类路径中，因为 CGLIB 类已经被重新打包 <code>org.springframework.cglib</code> 并直接包含在 spring-core JAR 中。</p>
</blockquote>
<blockquote>
<p>由于 CGLIB 在启动时会动态添加功能，因此存在一些限制。特别是，配置类不能是 final。但是，从 4.3 版本开始，配置类上允许使用任何构造函数，包括 <code>@Autowired</code> 对默认注入使用或单个非默认构造函数声明。</p>
<p>如果您希望避免 CGLIB 施加的限制，请考虑 <code>@Bean</code> 在非 <code>@Configuration</code> 类上声明您的方法（例如，在普通 <code>@Component</code> 类上声明）。那么 <code>@Bean</code> 就不会截获方法之间的跨方法调用，因此您必须专门依赖那里的构造函数或方法级别的依赖项注入。</p>
</blockquote>
<h3 id="组成基于-Java-的配置"><a href="#组成基于-Java-的配置" class="headerlink" title="组成基于 Java 的配置"></a>组成基于 Java 的配置</h3><p>Spring 的基于 Java 的配置功能使您可以编写批注，这可以降低配置的复杂性。</p>
<h4 id="使用-Import-注释"><a href="#使用-Import-注释" class="headerlink" title="使用 @Import 注释"></a>使用 <code>@Import</code> 注释</h4><p>就像 <code>&lt;import/&gt;</code> 在 Spring XML 文件中使用该元素来帮助模块化配置一样，<code>@Import</code> 注释允许 <code>@Bean</code> 从另一个配置类加载定义，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigA.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，无需同时指定两者 <code>ConfigA.class</code> 和 <code>ConfigB.class</code> 实例化上下文，只需 <code>ConfigB</code> 显式提供，如以下示例所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">    A a = ctx.getBean(A.class);</span><br><span class="line">    B b = ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法简化了容器的实例化，因为只需要处理一个类，而无需在构造过程中记住大量潜在的 <code>@Configuration</code> 类。</p>
<p>从 Spring Framework 4.2 开始，<code>@Import</code> 还支持对常规组件类的引用，类似于 <code>AnnotationConfigApplicationContext.register</code> 方法。如果要通过使用一些配置类作为入口点来显式定义所有组件，从而避免组件扫描，则此功能特别有用。</p>
<h5 id="注入对导入-Bean-定义的依赖"><a href="#注入对导入-Bean-定义的依赖" class="headerlink" title="注入对导入@Bean 定义的依赖"></a>注入对导入@Bean 定义的依赖</h5><p>前面的示例有效，但过于简单。在大多数实际情况下，Bean 在配置类之间相互依赖。使用 XML 时，这不是问题，因为不涉及编译器，并且您可以声明 <code>ref=&quot;someBean&quot;</code> 并信任 Spring 在容器初始化期间对其进行处理。使用 <code>@Configuration</code> 类时，Java 编译器会在配置模型上施加约束，因为对其他 bean 的引用必须是有效的 Java 语法。</p>
<p>幸运的是，解决这个问题很简单。正如我们已经讨论的那样，一个 <code>@Bean</code> 方法可以具有任意数量的描述 Bean 依赖关系的参数。考虑以下具有多个 <code>@Configuration</code> 类的更真实的场景，每个类都取决于其他类中声明的 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有另一种方法可以达到相同的结果。 请记住，<code>@Configuration</code> 类最终仅是容器中的另一个 bean：这意味着它们可以利用 <code>@Autowired</code> 和 <code>@Value</code> 注入以及与任何其他 bean 相同的其他功能。</p>
<blockquote>
<p>确保以这种方式注入的依赖项只是最简单的一种。 <code>@Configuration</code> 类是在上下文初始化期间非常早地处理的，并且强制以这种方式注入依赖项可能导致意外的早期初始化。 如上例所示，尽可能使用基于参数的注入。</p>
<p>另外，通过 <code>@Bean</code> 使用 <code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 定义时要特别小心。 通常应将这些声明为静态 <code>@Bean</code> 方法，从而不触发其包含的配置类的实例化。 否则，<code>@Autowired</code> 和 <code>@Value</code> 可能不适用于配置类本身，因为该 bean 实例的创建可能比 <code>AutowiredAnnotationBeanPostProcessor</code> 要早。</p>
</blockquote>
<p>以下示例说明如何将一个 bean 自动连接到另一个 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryConfig</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仅从 Spring Framework 4.3 开始支持 <code>@Configuration</code> 类中的构造方法注入。还要注意，如果目标 bean 仅定义了一个构造函数，那么无需指定 <code>@Autowired</code> 。</p>
</blockquote>
<h5 id="便于浏览的完全合格的导入-bean"><a href="#便于浏览的完全合格的导入-bean" class="headerlink" title="便于浏览的完全合格的导入 bean"></a>便于浏览的完全合格的导入 bean</h5><p>在前面的场景中，使用 <code>@Autowired</code> 效果很好，并提供了所需的模块化，但是要确切确定声明自动装配的 Bean 定义的位置仍然有些模棱两可。例如，当开发人员查看时 ServiceConfig，您如何确切知道该 <code>@Autowired AccountRepository</code> bean 的声明位置？它在代码中不是明确的，这可能很好。请记住， Spring Tools for Eclipse 提供了可以渲染图形的工具，这些图形显示了所有接线的方式，这可能就是您所需要的。另外，您的 Java IDE 可以轻松找到该 AccountRepository 类型的所有声明和使用，并快速向您显示<code>@Bean</code> 返回该类型的方法的位置。</p>
<p>如果这种歧义是不可接受的，并且您希望从 IDE 内部直接从一个 <code>@Configuration</code> 类导航到另一个类，请考虑自动装配配置类本身。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepositoryConfig repositoryConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// navigate 'through' the config class to the @Bean method!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，在哪里定义了 <code>AccountRepository</code> 是完全显式的。但是，<code>ServiceConfig</code> 现在与 <code>RepositoryConfig</code> 紧密耦合。那是权衡。通过使用基于接口或基于抽象类的 <code>@Configuration</code> 类，可以在某种程度上缓解这种紧密耦合。考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepositoryConfig repositoryConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">AccountRepository <span class="title">accountRepository</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfig</span> <span class="keyword">implements</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, DefaultRepositoryConfig.class&#125;)  <span class="comment">// import the concrete config!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>ServiceConfig</code> 就具体而言松散耦合 <code>DefaultRepositoryConfig</code>，并且内置的 IDE 工具仍然有用：您可以轻松地获得实现的类型层次结构 <code>RepositoryConfig</code>。通过这种方式，导航 <code>@Configuration</code> 类及其依赖项与导航基于接口的代码的通常过程没有什么不同。</p>
<p>如果要影响某些 Bean 的启动创建顺序，请考虑将其中一些声明为 <code>@Lazy</code>（用于首次访问而不是在启动时创建）或声明为 <code>@DependsOn</code> 某些其他 Bean（确保在当前 Bean 之前创建特定的其他 Bean），后者的直接依赖意味着什么）。</p>
<h4 id="有条件地包含-Configuration-类或-Bean-方法"><a href="#有条件地包含-Configuration-类或-Bean-方法" class="headerlink" title="有条件地包含 @Configuration 类或 @Bean 方法"></a>有条件地包含 <code>@Configuration</code> 类或 <code>@Bean</code> 方法</h4><p>根据某些系统状态，有条件地启用或禁用完整的 <code>@Configuration</code> 类甚至单个 <code>@Bean</code> 方法通常很有用。一个常见的示例是仅在 Spring 环境中启用了特定配置文件后，才使用<code>@Profile</code> 批注来激活 Bean（有关详细信息，请参见后文 Bean 定义配置文件）。</p>
<p><code>@Profile</code> 批注实际上是通过使用更灵活的称为 <code>@Conditional</code> 的批注来实现的。 <code>@Conditional</code> 批注指示在注册 <code>@Bean</code> 之前应参考的特定 <code>org.springframework.context.annotation.Condition</code> 实现。</p>
<p><code>Condition</code> 接口的实现提供了一个 <code>matches(…)</code> 方法，该方法返回 <code>true</code> 或 <code>false</code>。例如，以下清单显示了用于 <code>@Profile</code> 的实际 <code>Condition</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read the @Profile annotation attributes</span></span><br><span class="line">    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object value : attrs.get(<span class="string">"value"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(((String[]) value))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关 <code>@Conditional</code> 更多详细信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/5.3.0-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html" target="_blank" rel="noopener">javadoc</a>。</p>
<h4 id="结合-Java-和-XML-配置"><a href="#结合-Java-和-XML-配置" class="headerlink" title="结合 Java 和 XML 配置"></a>结合 Java 和 XML 配置</h4><p>Spring 的 <code>@Configuration</code> 类支持并非旨在 100％ 完全替代 Spring XML。 某些工具（例如 Spring XML 名称空间）仍然是配置容器的理想方法。 在使用 XML 方便或有必要的情况下，您可以选择：使用“以 XML 为中心”的方式实例化容器，比如 <code>ClassPathXmlApplicationContext</code> ，或使用“以 Java 中心”的方式实例化容器，也就是使用 <code>AnnotationConfigApplicationContext</code> 和 <code>@ImportResource</code> 批注来根据需要导入 XML。</p>
<h5 id="以-XML-为中心的-Configuration-类使用"><a href="#以-XML-为中心的-Configuration-类使用" class="headerlink" title="以 XML 为中心的 @Configuration 类使用"></a>以 XML 为中心的 <code>@Configuration</code> 类使用</h5><p>最好从 XML 引导 Spring 容器并以 ad-hoc 方式包含 <code>@Configuration</code> 类。 例如，在使用 Spring XML 的大型现有代码库中，根据需要创建 <code>@Configuration</code> 类并从现有 XML 文件中将它们包含在内会变得更加容易。 在本节的后面，我们将介绍在这种“以 XML 为中心”的情况下使用 <code>@Configuration</code> 类的选项。</p>
<h6 id="将-Configuration-类声明为纯-Spring-lt-bean-gt-元素"><a href="#将-Configuration-类声明为纯-Spring-lt-bean-gt-元素" class="headerlink" title="将 @Configuration 类声明为纯 Spring &lt;bean/&gt; 元素"></a>将 <code>@Configuration</code> 类声明为纯 Spring <code>&lt;bean/&gt;</code> 元素</h6><p>请记住，<code>@Configuration</code> 类最终是容器中的 bean 定义。在本系列示例中，我们创建一个名为 <code>AppConfig</code> 的 <code>@Configuration</code> 类， 并将其包含在<code>system-test-config.xml</code> 中作为 <code>&lt;bean/&gt;</code> 定义。因为 <code>&lt;context:annotation-config/&gt;</code> 已打开，所以容器会识别 <code>@Configuration</code> 注释并正确处理 <code>AppConfig</code> 中声明的 <code>@Bean</code> 方法。</p>
<p>以下示例显示了 Java 中的普通配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了示例 <code>system-test-config.xml</code> 文件的一部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.acme.AppConfig"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下示例显示了一个可能的 <code>jdbc.properties</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:hsqldb:hsql://localhost/xdb</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/com/acme/system-test-config.xml"</span>);</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>system-test-config.xml</code> 文件中，<code>AppConfig</code> <code>&lt;bean/&gt;</code> 没有声明 <code>id</code> 元素。尽管申明一下是可以接受的，但由于没有其他 bean 引用过它，因此这是不必要的，并且不太可能通过名称从容器中显式获取。同样，<code>DataSource</code> 仅按类型自动对 Bean 进行接线，因此也并不严格要求 <code>id</code> 定义。</p>
</blockquote>
<h6 id="使用-lt-context：component-scan-gt-拾取-Configuration-类"><a href="#使用-lt-context：component-scan-gt-拾取-Configuration-类" class="headerlink" title="使用 &lt;context：component-scan/&gt;拾取 @Configuration 类"></a>使用 <code>&lt;context：component-scan/&gt;</code>拾取 <code>@Configuration</code> 类</h6><p>因为 <code>@Configuration</code> 用 <code>@Component</code> 进行元注释，所以 <code>@Configuration</code> 注释的类自动成为组件扫描的候选对象。使用与先前示例中描述的场景相同的场景，我们可以重新定义 <code>system-test-config.xml</code> 以利用组件扫描的优势。请注意，在这种情况下，我们无需显式声明 <code>&lt;context：annotation-config/&gt;</code>，因为 <code>&lt;context：component-scan/&gt;</code> 可启用相同的功能。</p>
<p>以下示例显示了修改后的 <code>system-test-config.xml</code> 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.acme"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Configuration-以类为中心的-XML-与-ImportResource"><a href="#Configuration-以类为中心的-XML-与-ImportResource" class="headerlink" title="@Configuration 以类为中心的 XML 与 @ImportResource"></a><code>@Configuration</code> 以类为中心的 XML 与 <code>@ImportResource</code></h5><p>在 <code>@Configuration</code> 类是配置容器的主要机制的应用程序中，仍然有必要至少使用一些 XML。在这些情况下，您可以使用 <code>@ImportResource</code> 并仅定义所需的 XML。这样做实现了一种“以 Java 为中心”的方法来配置容器，并将 XML 保持在最低限度。以下示例（包括配置类，定义 Bean 的 XML 文件，属性文件和主类）显示了如何使用 <code>@ImportResource</code> 批注来实现按需使用 XML 的以 Java 为中心的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:/com/acme/properties-config.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>properties-config.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>jdbc.properties：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:hsqldb:hsql://localhost/xdb</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环境抽象"><a href="#环境抽象" class="headerlink" title="环境抽象"></a>环境抽象</h2><p><code>Environment</code> 接口是集成在容器中的抽象，它对应用程序环境的两个关键方面进行建模：概要文件（profiles）和属性（properties）。</p>
<p>profile 是仅在给定概要文件处于活动状态时才向容器注册的 Bean 定义的命名逻辑组。可以将 Bean 通过 XML 定义还或注释方式分配给 profile。与 profile 相关的 <code>Environment</code> 对象的作用是确定当前哪些 profile（如果有）处于活动状态，以及默认情况下哪些 profile（如果有）应处于活动状态。</p>
<p>properties 在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：属性文件，JVM 系统属性，系统环境变量，JNDI，Servlet 上下文参数，ad-hoc <code>Properties</code> 对象，<code>Map</code> 对象等。<code>Environment</code> 对象与 properties 相关的作用是为用户提供方便的服务接口，用于配置属性源并从中解析属性。</p>
<h3 id="Bean-定义配置文件（profiles）"><a href="#Bean-定义配置文件（profiles）" class="headerlink" title="Bean 定义配置文件（profiles）"></a>Bean 定义配置文件（profiles）</h3><p>Bean 定义配置文件在核心容器中提供了一种机制，该机制允许在不同环境中注册不同的 Bean。“环境”一词对不同的用户可能具有不同的含义，并且此功能可以帮助解决许多用例，包括：</p>
<ul>
<li>在开发中针对内存中的数据源进行工作，而不是在进行 QA 或生产时从 JNDI 查找相同的数据源。</li>
<li>仅在将应用程序部署到性能环境中时注册监视相关的基础设施。</li>
<li>为客户 A 和客户 B 部署注册 bean 的自定义实现。</li>
</ul>
<p>考虑实际应用中需要使用的第一个用例 <code>DataSource</code>。在测试环境中，配置可能类似于以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">        .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">        .addScript(<span class="string">"my-schema.sql"</span>)</span><br><span class="line">        .addScript(<span class="string">"my-test-data.sql"</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，假设该应用程序的数据源已在生产应用程序服务器的 JNDI 目录中注册，请考虑如何将该应用程序部署到 QA 或生产环境中。 现在，我们的 <code>dataSource</code> bean 看起来像下面的清单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题是如何根据当前环境在使用这两种变体之间进行切换。 随着时间的流逝，Spring 用户已经设计出多种方法来完成此任务，通常依赖于系统环境变量和包含 <code>${placeholder}</code> 令牌的 XML <code>&lt;import/&gt;</code>语句的组合，这些语句根据值解析为正确的配置文件路径环境变量。 Bean 定义配置文件是一个核心容器功能，可提供此问题的解决方案。</p>
<p>如果我们概括前面特定于环境的 Bean 定义示例中所示的用例，那么最终需要在某些上下文中而不是在其他上下文中注册某些 Bean 定义。 您可能会说您要在情况 A 中注册一个特定的 bean 定义配置文件，在情况 B 中注册一个不同的配置文件。我们首先更新配置以反映这种需求。</p>
<h4 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用 @Profile"></a>使用 <code>@Profile</code></h4><p>@Profile 批注可让您指示一个或多个指定的配置文件处于活动状态时有资格注册的组件。 使用前面的示例，我们可以如下重写 dataSource 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"development"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandaloneDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JndiDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如前所述，对于 <code>@Bean</code> 方法，通常选择使用程序化 JNDI 查找，方法是使用 Spring 的 <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> 帮助器或前面展示的直接 JNDI <code>InitialContext</code> 用法，而不是 <code>JndiObjectFactoryBean</code> 变体，这将迫使您将返回类型声明为 <code>FactoryBean</code> 类型。</p>
</blockquote>
<p>配置文件字符串可以包含简单的配置文件名称（例如 <code>production</code>）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑（例如 <code>production &amp; us-east</code>）。概要文件表达式中支持以下运算符：</p>
<ul>
<li><code>!</code>: 非</li>
<li><code>&amp;</code>: 与</li>
<li><code>|</code>: 或</li>
</ul>
<blockquote>
<p>您不能在不使用括号的情况下混合使用 <code>&amp;</code> 和 <code>|</code> 运算符。例如，<code>production &amp; us-east | eu-central</code> 不是有效的表达式。它必须表示为 <code>production &amp; (us-east | eu-central)</code>。</p>
</blockquote>
<p>您可以将其<code>@Profile</code>用作元注释，以创建自定义的组合注释。以下示例定义了一个自定义 <code>@Production</code> 批注，您可以将其用作替代品 <code>@Profile(&quot;production&quot;)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Production &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果用 <code>@Configuration</code> 标记了一个类，则除非一个或多个指定的配置文件处于活动状态，否则将忽略与该类关联的 <code>@Profile</code> 所有 <code>@Bean</code> 方法和 <code>@Import</code> 注释。如果一个 <code>@Component</code> 或 <code>@Configuration</code> 类标记有 <code>@Profile({&quot;p1&quot;, &quot;p2&quot;})</code>，则除非已激活配置文件“p1”或“p2”，否则该类不会注册或处理。如果给定的配置文件以 非 运算符（<code>!</code>）为前缀，则仅在该配置文件不活动时才注册带注释的元素。例如，给定<code>@Profile({&quot;p1&quot;, &quot;!p2&quot;})</code>，如果配置文件“p1”处于活动状态或配置文件“p2”未处于活动状态，则会进行注册。</p>
</blockquote>
<p><code>@Profile</code> 也可以在方法级别声明为仅包括配置类的一个特定 Bean（例如，特定 Bean 的替代变体），如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">standaloneDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>@Bean</code> 方法上使用 <code>@Profile</code> 时，可能会出现特殊情况：对于具有 <code>@Bean</code> 相同 Java 方法名称的重载方法（类似于构造函数重载），<code>@Profile</code> 需要在所有重载方法上一致声明条件。如果条件不一致，则仅重载方法中第一个声明的条件有效。因此，<code>@Profile</code> 不能用于选择具有特定参数签名的重载方法。在创建时，相同 bean 的所有工厂方法之间的解析都遵循 Spring 的构造函数解析算法。</p>
<p>如果要使用不同的概要文件条件定义备用 bean，<code>@Bean</code> name 属性需要使用不同的 Java 方法名称来指向相同的 bean 名称，如前面的示例所示。如果参数签名都相同（例如，所有变体都具有无参工厂方法），则这是首先在有效 Java 类中表示这种排列的唯一方法（因为只能有一个特定名称和参数签名的方法）。</p>
</blockquote>
<h4 id="XML-Bean-定义配置文件"><a href="#XML-Bean-定义配置文件" class="headerlink" title="XML Bean 定义配置文件"></a>XML Bean 定义配置文件</h4><p>XML 对应项是元素的 profile 属性 <code>&lt;beans&gt;</code> 。我们前面的示例配置可以用两个 XML 文件重写，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以避免<code>&lt;beans/&gt;</code>在同一文件中拆分和嵌套元素，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other bean definitions --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-bean.xsd</code> 已被限制为仅允许这些元素作为文件中的最后一个元素。这应该有助于提供灵活性，而不会引起 XML 文件混乱。</p>
<blockquote>
<p>XML 对应项不支持前面描述的配置文件表达式。但是，可以通过使用<code>!</code>运算符来取消配置文件。也可以通过嵌套配置文件来应用逻辑“与”，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">&gt;     xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">&gt;     xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span><br><span class="line">&gt;     xmlns:jee=<span class="string">"http://www.springframework.org/schema/jee"</span></span><br><span class="line">&gt;     xsi:schemaLocation=<span class="string">"..."</span>&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     &lt;!-- other bean definitions --&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     &lt;beans profile=<span class="string">"production"</span>&gt;</span><br><span class="line">&gt;         &lt;beans profile=<span class="string">"us-east"</span>&gt;</span><br><span class="line">&gt;             &lt;jee:jndi-lookup id=<span class="string">"dataSource"</span> jndi-name=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span><br><span class="line">&gt;         &lt;/beans&gt;</span><br><span class="line">&gt;     &lt;/beans&gt;</span><br><span class="line">&gt; &lt;/beans&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在前面的示例中，如果 <code>production</code> 和 <code>us-east</code> profiles 都处于活动状态，则将显示 <code>dataSource</code> bean。</p>
</blockquote>
<h4 id="激活-profile"><a href="#激活-profile" class="headerlink" title="激活 profile"></a>激活 profile</h4><p>现在我们已经更新了配置，我们仍然需要指示 Spring 哪个配置文件处于活动状态。如果我们现在启动示例应用程序，则会看到 <code>NoSuchBeanDefinitionException</code> 抛出的错误，因为容器找不到名为 <code>dataSource</code> 的 Spring bean。</p>
<p>可以通过多种方式来激活配置文件，但最直接的方法是针对可通过 <code>ApplicationContext</code> 获得的 <code>Environment</code> API 以编程方式进行配置。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"development"</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure>

<p>另外，您还可以通过 <code>spring.profiles.active</code> 属性声明性地激活配置文件，可以通过系统环境变量，JVM 系统属性，<code>web.xml</code> 中的 servlet 上下文参数 或甚至作为 JNDI 中的条目来指定配置文件 （请参见 [<code>PropertySource</code> 抽象化](&lt;#<code>PropertySource</code>\ 抽象化&gt;)）。在集成测试中，可以通过使用 <code>spring-test</code> 模块中的 <code>@ActiveProfiles</code> 注释来声明活动配置文件 （请参阅(环境配置文件的上下文配置)[<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles]）。" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles]）。</a></p>
<p>请注意，profile 不是“非此即彼”的。您可以一次激活多个配置文件。通过编程，您可以为 <code>setActiveProfiles()</code> 方法提供多个配置文件名称，该方法接受 <code>String…</code>​ 变长参数。以下示例激活多个配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"profile1"</span>, <span class="string">"profile2"</span>);</span><br></pre></td></tr></table></figure>

<p>以声明方式，<code>spring.profiles.active</code> 可以接受以逗号分隔的配置文件名称列表，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=&quot;profile1,profile2&quot;</span><br></pre></td></tr></table></figure>

<h4 id="默认-profile"><a href="#默认-profile" class="headerlink" title="默认 profile"></a>默认 profile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"default"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有配置文件处于活动状态，则将创建上面的<code>dataSource</code>。您可以看到这是为一个或多个 bean 提供默认定义的一种方法。如果启用了任何配置文件，则默认配置文件将不适用。</p>
<p>您可以通过<code>Environment</code>上的<code>setDefaultProfiles()</code>，或者声明 <code>spring.profiles.default</code> 属性，来更改默认的配置文件的名称，。</p>
<h3 id="PropertySource-抽象"><a href="#PropertySource-抽象" class="headerlink" title="PropertySource 抽象"></a><code>PropertySource</code> 抽象</h3><p>Spring 的 <code>Environment</code> 抽象提供了对属性源可配置层次结构的搜索操作。考虑以下清单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">Environment env = ctx.getEnvironment();</span><br><span class="line"><span class="keyword">boolean</span> containsMyProperty = env.containsProperty(<span class="string">"my-property"</span>);</span><br><span class="line">System.out.println(<span class="string">"Does my environment contain the 'my-property' property? "</span> + containsMyProperty);</span><br></pre></td></tr></table></figure>

<p>在前面的代码片段中，我们看到了一种高级方式来询问 Spring 是否为当前环境定义了 <code>my-property</code> 属性。 为了解决这个问题，<code>Environment</code> 对象在一组 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/PropertySource.html" target="_blank" rel="noopener"><code>PropertySource</code></a> 对象上执行搜索。 <code>PropertySource</code> 是对键-值对源的简单抽象，Spring 的 <code>StandardEnvironment</code> 配置了两个 <code>PropertySource</code> 对象——一个代表 JVM 系统属性的集合（<code>System.getProperties()</code>），另一个代表系统环境变量的集合（<code>System.getenv()</code>）。</p>
<blockquote>
<p>这些默认属性源存在于 <code>StandardEnvironment</code> 中，供在独立应用程序中使用。<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html" target="_blank" rel="noopener"><code>StandardServletEnvironment</code></a> 用其他默认属性源（包括 <code>servlet</code> 配置和 <code>servlet</code> 上下文参数）填充。它可以有选择地启用 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jndi/JndiPropertySource.html" target="_blank" rel="noopener"><code>JndiPropertySource</code></a>。有关详细信息，请参见 javadoc。</p>
</blockquote>
<p>具体来说，当您使用<code>StandardEnvironment</code>时，<code>env.containsProperty(&quot;my-property&quot;)</code> 如果运行时存在 <code>my-property</code> 系统属性或 <code>my-property</code> 环境变量，则对的调用将返回 true 。</p>
<blockquote>
<p>执行的搜索是分层的。默认情况下，系统属性优先于环境变量。因此，如果<code>my-property</code>在调用期间在两个地方同时设置了 <code>env.getProperty(&quot;my-property&quot;)</code> 该属性，则系统属性值将“获胜”并返回。请注意，属性值不会合并，而是会被前面的条目完全覆盖。</p>
<p>对于常规 <code>StandardServletEnvironment</code>，完整层次结构如下，最高优先级条目位于顶部：</p>
<ol>
<li>ServletConfig 参数（如果适用，例如在 <code>DispatcherServlet</code> 上下文的情况下）</li>
<li>ServletContext 参数（<code>web.xml</code> 的 <code>context-param</code> 条目）</li>
<li>JNDI 环境变量（<code>java:comp/env/</code> 条目）</li>
<li>JVM 系统属性（-D 命令行参数）</li>
<li>JVM 系统环境（操作系统环境变量）</li>
</ol>
</blockquote>
<p>最重要的是，整个机制是可配置的。也许您有一个要集成到此搜索中的自定义属性源。为此，请实现并实例化自己的 <code>PropertySource</code> 实例并将其添加到 <code>Environment</code> 的 <code>PropertySourcescurrent</code> 集合中。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">MutablePropertySources sources = ctx.getEnvironment().getPropertySources();</span><br><span class="line">sources.addFirst(<span class="keyword">new</span> MyPropertySource());</span><br></pre></td></tr></table></figure>

<p>在前面的代码中，<code>MyPropertySource</code> 已在搜索中添加了最高优先级。如果它包含一个<code>my-property</code> 属性，则检测并返回该属性，超越其他 <code>PropertySource</code> 中的<code>my-property</code> 属性 。(<code>MutablePropertySources</code>)[<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/MutablePropertySources.html]" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/MutablePropertySources.html]</a> API 公开了许多方法，这些方法允许对属性源集进行精确操作。</p>
<h3 id="使用-PropertySource"><a href="#使用-PropertySource" class="headerlink" title="使用 @PropertySource"></a>使用 @PropertySource</h3><p><code>@PropertySource</code> 注解提供了一种添加<code>PropertySource</code> 到 Spring 的<code>Environment</code> 的便利和声明性的机制。</p>
<p>给定一个名为 <code>app.properties</code> 的文件，包含键-值对 <code>testbean.name=myTestBean</code>，下面的 <code>@Configuration</code> 类使用 <code>@PropertySource</code>，其方式是对 <code>testBean.getName()</code> 的调用返回 <code>myTestBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/myco/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestBean testBean = <span class="keyword">new</span> TestBean();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">"testbean.name"</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@PropertySource</code> 资源位置中存在的任何 <code>${…}</code> 占位符都是根据已经针对该环境注册的一组属性源来解析的，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestBean testBean = <span class="keyword">new</span> TestBean();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">"testbean.name"</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 <code>my.placeholder</code> 存在于已注册的属性源之一（例如，系统属性或环境变量）中，则占位符将解析为相应的值。如果不是，则 <code>default/path</code> 用作默认值。如果未指定默认值并且无法解析属性，则抛出 <code>IllegalArgumentException</code>。</p>
<p>根据 Java 8 的约定， <code>@PropertySource</code> 注释是可重复的。但是，所有此类<code>@PropertySource</code> 批注都需要在同一级别上声明，可以直接在配置类上声明，也可以在同一自定义批注中声明为元批注。不建议将直接注释和元注释混合使用，因为直接注释会覆盖元注释。</p>
<h3 id="声明中的占位符解析"><a href="#声明中的占位符解析" class="headerlink" title="声明中的占位符解析"></a>声明中的占位符解析</h3><p>从历史上看，元素中占位符的值只能根据 JVM 系统属性或环境变量来解析。这已不再是这种情况。由于 <code>Environment</code> 抽象是在整个容器中集成的，因此很容易通过它路由占位符的解析。这意味着您可以按照自己喜欢的任何方式配置解析过程。您可以更改搜索系统属性和环境变量的优先级，也可以完全删除它们。您还可以根据需要将自己的属性源添加到混合中。</p>
<p>具体而言，无论该 customer 属性在何处定义，只要该属性在 <code>Environment</code> 可用，以下语句均有效：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"com/bank/service/$&#123;customer&#125;-config.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注册一个-LoadTimeWeaver"><a href="#注册一个-LoadTimeWeaver" class="headerlink" title="注册一个 LoadTimeWeaver"></a>注册一个 <code>LoadTimeWeaver</code></h2><p>Spring 使用 <code>LoadTimeWeaver</code> 在将类加载到 Java 虚拟机（JVM）中时对其进行动态转换。</p>
<p>要启用加载时编织（load-time weaving），可以将 <code>@EnableLoadTimeWeaving</code> 添加到您的 <code>@Configuration</code> 类之一，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableLoadTimeWeaving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，对于 XML 配置，可以使用 context:load-time-weaver 元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为 <code>ApplicationContext</code> 配置后，该 <code>ApplicationContext</code> 中的任何 bean 都可以实现 <code>LoadTimeWeaverAware</code>，从而接收对加载时 weaver 实例的引用。 与 (Spring 的 JPA 支持)[<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#orm-jpa]结合使用时，该功能特别有用，因为在" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#orm-jpa]结合使用时，该功能特别有用，因为在</a> JPA 类转换中可能需要进行加载时编织。 有关更多详细信息，请查阅 (<code>LocalContainerEntityManagerFactoryBean</code>)[<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html]" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html]</a> javadoc。 有关 AspectJ 加载时编织的更多信息，请参见 Spring 框架中的 AspectJ 加载时编织。</p>
<h2 id="ApplicationContext-的其他功能"><a href="#ApplicationContext-的其他功能" class="headerlink" title="ApplicationContext 的其他功能"></a>ApplicationContext 的其他功能</h2><p>如本章介绍中所讨论的，<code>org.springframework.beans.factory</code> 包提供了用于管理和操纵 bean 的基本功能，包括以编程方式。<code>org.springframework.context</code> 包添加了 <code>ApplicationContext</code> 接口，该接口扩展了 <code>BeanFactory</code> 接口，此外还扩展了其他接口以提供更多面向应用程序框架的样式的附加功能。许多人以完全声明性的方式使用 <code>ApplicationContext</code>，甚至没有以编程方式创建它，而是依靠诸如 <code>ContextLoader</code> 之类的支持类来自动实例化 <code>ApplicationContext</code> 作为 Java EE Web 应用程序正常启动过程的一部分。</p>
<p>为了以更加面向框架的方式增强 <code>BeanFactory</code> 的功能，上下文包还提供以下功能：</p>
<p>通过 <code>MessageSource</code> 界面访问 i18n 样式的消息。</p>
<p>通过 <code>ResourceLoader</code> 接口访问资源，例如 URL 和文件。</p>
<p>通过使用 <code>ApplicationEventPublisher</code> 接口，将事件发布到实现 <code>ApplicationListener</code> 接口的 bean。</p>
<p>加载多个（分层）上下文，使每个上下文都通过 <code>HierarchicalBeanFactory</code> 接口集中在一个特定层上，例如应用程序的 Web 层。</p>
<h3 id="使用-MessageSource-实现国际化"><a href="#使用-MessageSource-实现国际化" class="headerlink" title="使用 MessageSource 实现国际化"></a>使用 MessageSource 实现国际化</h3><p><code>ApplicationContext</code> 接口扩展了一个称为 <code>MessageSource</code> 的接口，因此提供了国际化（“i18n”）功能。Spring 还提供了 <code>HierarchicalMessageSource</code> 接口，该接口可以分层解析消息。这些接口一起提供了 Spring 影响消息解析的基础。 这些接口上定义的方法包括：</p>
<ul>
<li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从 <code>MessageSource</code> 检索消息的基本方法。如果找不到针对指定语言环境的消息，则使用默认消息。使用标准库提供的 MessageFormat 功能，传入的所有参数都将成为替换值。</li>
<li><code>String getMessage(String code, Object[] args, Locale loc)</code>：与先前的方法基本相同，但有一个区别：无法指定默认消息。如果找不到该消息，则抛出 <code>NoSuchMessageException。</code></li>
<li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面方法中使用的所有属性也都包装在一个名为 <code>MessageSourceResolvable</code> 的类中，您可以在此方法中使用该类。</li>
</ul>
<p>加载 <code>ApplicationContext</code> 时，它将自动搜索在上下文中定义的 <code>MessageSource</code> bean。Bean 的 name 必须是 <code>messageSource</code>。如果找到了这样的 bean，则对先前方法的所有调用都将委派给消息源。 如果找不到消息源，则 <code>ApplicationContext</code> 尝试查找包含同名 bean 的父级。如果找到了，它将使用该 bean 作为 <code>MessageSource</code>。如果 <code>ApplicationContext</code> 找不到任何消息源，则将实例化一个空的 <code>DelegatingMessageSource</code>，以便能够接受对上述方法的调用。</p>
<p>Spring 提供了两个 <code>MessageSource</code> 实现，即 <code>ResourceBundleMessageSource</code> 和 <code>StaticMessageSource</code>。两者都实现 <code>HierarchicalMessageSource</code> 以便进行嵌套消息传递。 <code>StaticMessageSource</code> 很少使用，但是提供了将消息添加到源中的编程方式。下面的示例显示 <code>ResourceBundleMessageSource</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basenames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>format<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>exceptions<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>windows<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该示例假设您在类路径中定义了三个资源包，分别称为 format，exceptions 和 windows。解析消息的任何请求都通过 JDK 标准的通过 <code>ResourceBundle</code> 对象解析消息的方式来处理。就本示例而言，假定上述两个资源束文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in format.properties</span><br><span class="line">message=Alligators rock!</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in exceptions.properties</span><br><span class="line">argument.required=The &#123;0&#125; argument is required.</span><br></pre></td></tr></table></figure>

<p>下一个示例显示了执行 <code>MessageSource</code> 功能的程序。请记住，所有 <code>ApplicationContext</code> 实现也是 <code>MessageSource</code> 实现，因此可以转换为 <code>MessageSource</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    String message = resources.getMessage(<span class="string">"message"</span>, <span class="keyword">null</span>, <span class="string">"Default"</span>, Locale.ENGLISH);</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alligators rock!</span><br></pre></td></tr></table></figure>

<p>总而言之，<code>MessageSource</code> 是在名为 <code>beans.xml</code> 的文件中定义的，该文件位于类路径的根目录下。 <code>messageSource</code> bean 定义通过其 <code>basenames</code> 属性引用了许多资源包。列表中传递给 <code>basenames</code> 属性的三个文件在类路径的根目录下以文件形式存在，分别称为 <code>format.properties</code>，<code>exceptions.properties</code> 和 <code>windows.properties</code>。</p>
<p>下一个示例显示了传递给消息查找的参数。这些参数将转换为 <code>String</code> 对象，并插入到查找消息中的占位符中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this MessageSource is being used in a web application --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"exceptions"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- lets inject the above MessageSource into this POJO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"example"</span> <span class="attr">class</span>=<span class="string">"com.something.Example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messages"</span> <span class="attr">ref</span>=<span class="string">"messageSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageSource messages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessages</span><span class="params">(MessageSource messages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="keyword">this</span>.messages.getMessage(<span class="string">"argument.required"</span>,</span><br><span class="line">            <span class="keyword">new</span> Object [] &#123;<span class="string">"userDao"</span>&#125;, <span class="string">"Required"</span>, Locale.ENGLISH);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>execute()</code> 方法调用的结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The userDao argument is required.</span><br></pre></td></tr></table></figure>

<p>关于国际化(“i18n”)，Spring 的各种 <code>MessageSource</code> 实现遵循与标准 JDK <code>ResourceBundle</code> 相同的语言环境解析和后备规则。简而言之，继续前面定义的示例 <code>messageSource</code>，如果要针对英国（en-GB）语言环境解析消息，则可以分别创建名为 <code>format_en_GB.properties</code>，<code>exceptions_en_GB.properties</code> 和 <code>windows_en_GB.properties</code> 的文件。</p>
<p>通常，语言环境解析由应用程序的周围环境管理。在以下示例中，手动指定了针对其解析（英国）消息的语言环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in exceptions_en_GB.properties</span><br><span class="line">argument.required=Ebagum lad, the &apos;&apos;&#123;0&#125;&apos;&apos; argument is required, I say, required.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">    MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    String message = resources.getMessage(<span class="string">"argument.required"</span>,</span><br><span class="line">        <span class="keyword">new</span> Object [] &#123;<span class="string">"userDao"</span>&#125;, <span class="string">"Required"</span>, Locale.UK);</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述程序的结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ebagum lad, the &apos;userDao&apos; argument is required, I say, required.</span><br></pre></td></tr></table></figure>

<p>您还可以使用 <code>MessageSourceAware</code> 接口获取对已定义的任何 <code>MessageSource</code> 的引用。 创建和配置 bean 时，在 <code>ApplicationContext</code> 中实现 <code>MessageSourceAware</code> 接口的所有 bean 都会与应用程序上下文的 <code>MessageSource</code> 一起注入。</p>
<blockquote>
<p>作为 <code>ResourceBundleMessageSource</code> 的替代，Spring 提供了 <code>ReloadableResourceBundleMessageSource</code> 类。 此变体支持相同的包文件格式，但比基于标准 JDK 的 <code>ResourceBundleMessageSource</code> 实现更灵活。特别是，它允许从任何 Spring 资源位置（不仅从类路径）读取文件，并且支持捆绑属性文件的热重载（同时在它们之间有效地进行缓存）。有关详细信息，请参见 (<code>ReloadableResourceBundleMessageSource</code> javadoc)[<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html]。" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html]。</a></p>
</blockquote>
<h3 id="标准和自定义事件"><a href="#标准和自定义事件" class="headerlink" title="标准和自定义事件"></a>标准和自定义事件</h3><p>通过 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口提供 <code>ApplicationContext</code> 中的事件处理。 如果将实现 <code>ApplicationListener</code> 接口的 bean 部署到上下文中，则每次将 <code>ApplicationEvent</code> 发布到 <code>ApplicationContext</code> 时，都会通知该 bean。 本质上，这是标准的 Observer 设计模式。</p>
<blockquote>
<p>从 Spring 4.2 开始，事件基础结构得到了显着改进，并提供了基于注释的模型以及发布任意事件（即不一定从 ApplicationEvent 扩展的对象）的功能。发布此类对象后，我们会为您包装一个事件。</p>
</blockquote>
<p>下表描述了 Spring 提供的标准事件：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ContextRefreshedEvent</code></td>
<td>在初始化或刷新 <code>ApplicationContext</code> 时发布（例如，通过使用 <code>ConfigurableApplicationContext</code> 接口上的 <code>refresh()</code> 方法）。 在这里，“已初始化”是指所有 Bean 均已加载，检测到并激活了后处理器 Bean，已预先实例化单例并且可以使用 <code>ApplicationContext</code> 对象。 只要尚未关闭上下文，只要选定的 <code>ApplicationContext</code> 实际上支持这种“热”刷新，就可以多次触发刷新。例如，<code>XmlWebApplicationContext</code> 支持热刷新，但 <code>GenericApplicationContext</code> 不支持。</td>
</tr>
<tr>
<td><code>ContextStartedEvent</code></td>
<td>在 <code>ConfigurableApplicationContext</code> 接口上使用 <code>start()</code> 方法启动 <code>ApplicationContext</code> 时发布。在这里，“已启动”表示所有 Lifecycle bean 都收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动 Bean，但也可以用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。</td>
</tr>
<tr>
<td><code>ContextStoppedEvent</code></td>
<td>通过使用 <code>ConfigurableApplicationContext</code> 接口上的 <code>stop()</code> 方法停止 <code>ApplicationContext</code> 时发布。 在这里，“已停止”表示所有 <code>Lifecycle</code> bean 都收到一个明确的停止信号。 停止的上下文可以通过 <code>start()</code> 调用重新启动。</td>
</tr>
<tr>
<td><code>ContextClosedEvent</code></td>
<td>通过使用 <code>ConfigurableApplicationContext</code> 接口上的 <code>close()</code> 方法或通过 JVM 关闭钩子关闭 <code>ApplicationContext</code> 时发布。 在这里，“已关闭”意味着所有单例 bean 将被销毁。 关闭上下文后，它将达到使用寿命，无法刷新或重新启动。</td>
</tr>
<tr>
<td><code>RequestHandledEvent</code></td>
<td>一个特定于 Web 的事件，告诉所有 Bean HTTP 请求已得到服务。请求完成后，将发布此事件。此事件仅适用于使用 Spring 的 <code>DispatcherServlet</code> 的 Web 应用程序。</td>
</tr>
<tr>
<td><code>ServletRequestHandledEvent</code></td>
<td><code>RequestHandledEvent</code> 的子类，用于添加特定于 Servlet 的上下文信息。</td>
</tr>
</tbody></table>
<p>您还可以创建和发布自己的自定义事件。以下示例显示了一个简单的类，该类扩展了 Spring 的 <code>ApplicationEvent</code> 基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlackListEvent</span><span class="params">(Object source, String address, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accessor and other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要发布自定义的 <code>ApplicationEvent</code>，请在 <code>publishEvent()</code> 上调用方法 <code>ApplicationEventPublisher</code>。通常，这是通过创建一个实现 <code>ApplicationEventPublisherAware</code> 并注册为 Spring bean 的类来完成的。以下示例显示了此类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlackList</span><span class="params">(List&lt;String&gt; blackList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blackList = blackList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = publisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blackList.contains(address)) &#123;</span><br><span class="line">            publisher.publishEvent(<span class="keyword">new</span> BlackListEvent(<span class="keyword">this</span>, address, content));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// send email...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置时，Spring 容器检测到 <code>EmailService</code> 实现了 <code>ApplicationEventPublisherAware</code> 并自动调用 <code>setApplicationEventPublisher()</code>。实际上，传入的参数是 Spring 容器本身。您正在通过其 <code>ApplicationEventPublisher</code> 接口与应用程序上下文进行交互。</p>
<p>要接收自定义 <code>ApplicationEvent</code>，可以创建一个实现 <code>ApplicationListener</code> 的类并将其注册为 Spring Bean。 以下示例显示了此类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListNotifier</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">BlackListEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotificationAddress</span><span class="params">(String notificationAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notificationAddress = notificationAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>ApplicationListener</code> 通常使用您的自定义事件的类型（上一示例中的 <code>BlackListEvent</code>）进行参数化。这意味着 <code>onApplicationEvent()</code> 方法可以保持类型安全，从而避免了任何向下转换的需求。您可以根据需要注册任意数量的事件侦听器，但是请注意，默认情况下，事件侦听器会同步接收事件。这意味着 <code>publishEvent()</code> 方法将阻塞，直到所有侦听器都已完成对事件的处理为止。这种同步和单线程方法的一个优点是，当侦听器接收到事件时，如果有可用的事务上下文，它将在发布者的事务上下文内部进行操作。如果有必要采用其他发布事件的策略，请参阅 Spring 的 (<code>ApplicationEventMulticaster</code> 接口的 javadoc )[<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html]和配置选项的" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html]和配置选项的</a> (<code>SimpleApplicationEventMulticaster</code> 实现)[<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html]。" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html]。</a></p>
<p>以下示例显示了用于注册和配置上述每个类的 Bean 定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emailService"</span> <span class="attr">class</span>=<span class="string">"example.EmailService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blackList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.spammer@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.hacker@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>john.doe@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blackListNotifier"</span> <span class="attr">class</span>=<span class="string">"example.BlackListNotifier"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"notificationAddress"</span> <span class="attr">value</span>=<span class="string">"blacklist@example.org"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总而言之，当调用 <code>emailService</code> bean 的 <code>sendEmail()</code> 方法时，如果有任何电子邮件应列入黑名单，则将发布 <code>BlackListEvent</code> 类型的自定义事件。 <code>blackListNotifier</code> bean 被注册为 <code>ApplicationListener</code> 并接收 <code>BlackListEvent</code>，这时它可以通知适当的参与者。</p>
<blockquote>
<p>Spring 的事件机制旨在在同一应用程序上下文内在 Spring bean 之间进行简单的通信。 但是，对于更复杂的企业集成需求，单独维护的 Spring Integration 项目为基于著名的 Spring 编程模型构建轻量级，面向模式，事件驱动的架构提供了完整的支持。</p>
</blockquote>
<h4 id="基于注释的事件侦听器"><a href="#基于注释的事件侦听器" class="headerlink" title="基于注释的事件侦听器"></a>基于注释的事件侦听器</h4><p>从 Spring 4.2 开始，您可以使用 <code>@EventListener</code> 注释在托管 Bean 的任何公共方法上注册事件侦听器。<code>BlackListNotifier</code> 可改写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListNotifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotificationAddress</span><span class="params">(String notificationAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notificationAddress = notificationAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法签名再次声明其侦听的事件类型，但是这次使用灵活的名称，并且没有实现特定的侦听器接口。只要实际事件类型在其实现层次结构中解析您的通用参数，也可以通过通用类型来缩小事件类型。</p>
<p>如果您的方法应该侦听多个事件，或者您要完全不使用任何参数来定义它，则事件类型也可以在注释本身上指定。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleContextStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过使用定义 SpEL 表达式的注释的 <code>condition</code> 属性来添加其他运行时过滤，该注释应匹配以针对特定事件实际调用该方法。</p>
<p>以下示例显示了仅当事件的 <code>content</code> 属性等于 <code>my-event</code> 时，才可以重写我们的通知程序以进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(condition = <span class="string">"#blEvent.content == 'my-event'"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent blEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 SpEL 表达式都会根据专用上下文进行求值。 下表列出了可用于上下文的项目，以便您可以将它们用于条件事件处理：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位置</th>
<th>描述</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>事件</td>
<td>根对象</td>
<td>实际的 <code>ApplicationEvent</code>。</td>
<td><code>#root.event</code> 或 <code>event</code></td>
</tr>
<tr>
<td>参数数组</td>
<td>根对象</td>
<td>用于调用方法的参数（作为对象数组）。</td>
<td><code>#root.args</code> 或 <code>args</code>; <code>args[0]</code>访问第一个参数，等等。</td>
</tr>
<tr>
<td><em>参数名称</em></td>
<td>求值上下文</td>
<td>任何方法参数的名称。如果由于某种原因这些名称不可用（例如，由于在编译的字节码中没有调试信息），则也可以使用<code>#a&lt;#arg&gt;</code>语法（其中<code>&lt;#arg&gt;</code>代表参数索引（从 0 开始）。</td>
<td><code>#blEvent</code> 或 <code>#a0</code>（您也可以使用 <code>#p0</code> 或 <code>#p&lt;#arg&gt;</code> 参数符号作为别名</td>
</tr>
</tbody></table>
<p>请注意，即使您的方法签名实际上引用了已发布的任意对象，<code>root.event</code> 也使您可以访问基础事件。</p>
<p>如果由于处理一个事件而需要发布另一个事件，则可以更改方法签名以返回应发布的事件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListUpdateEvent <span class="title">handleBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress and</span></span><br><span class="line">    <span class="comment">// then publish a ListUpdateEvent...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异步侦听器不支持此功能。</p>
</blockquote>
<p>此新方法为上述方法处理的每个 <code>BlackListEvent</code> 发布一个新的 <code>ListUpdateEvent</code>。如果您需要发布多个事件，则可以返回事件的 <code>Collection</code>。</p>
<h4 id="异步侦听器"><a href="#异步侦听器" class="headerlink" title="异步侦听器"></a>异步侦听器</h4><p>如果希望特定的侦听器异步处理事件，则可以重用常规的 <code>@Async</code> 支持。 以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BlackListEvent is processed in a separate thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用异步事件时，请注意以下限制：</p>
<p>如果异步事件侦听器引发 <code>Exception</code>，则不会将其传播到调用方。有关更多详细信息，请参见 <code>AsyncUncaughtExceptionHandler</code>。</p>
<p>异步事件侦听器方法无法通过返回值来发布后续事件。如果您需要发布另一个事件作为处理的结果，请注入 (<code>ApplicationEventPublisher</code>)[<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html]" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html]</a> 以手动发布事件。</p>
<h4 id="侦听器排序"><a href="#侦听器排序" class="headerlink" title="侦听器排序"></a>侦听器排序</h4><p>如果需要先调用一个侦听器，则可以将 <code>@Order</code> 注释添加到方法声明中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">42</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一般事件"><a href="#一般事件" class="headerlink" title="一般事件"></a>一般事件</h4><p>您还可以使用泛型来进一步定义事件的结构。考虑使用 <code>EntityCreatedEvent&lt;T&gt;</code>，其中 T 是已创建的实际实体的类型。例如，您可以创建以下侦听器定义以仅接收 <code>Person</code> 的 <code>EntityCreatedEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPersonCreated</span><span class="params">(EntityCreatedEvent&lt;Person&gt; event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于类型擦除，只有在触发的事件解析了事件侦听器所依据的通用参数（即 <code>class PersonCreatedEvent extends EntityCreatedEvent&lt;Person&gt; {…}</code>）时，此方法才起作用。</p>
<p>在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很乏味（就像前面示例中的事件一样）。 在这种情况下，您可以实现 <code>ResolvableTypeProvider</code> 来指导框架超出运行时环境提供的范围。以下事件显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityCreatedEvent</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> <span class="keyword">implements</span> <span class="title">ResolvableTypeProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EntityCreatedEvent</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResolvableType <span class="title">getResolvableType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这不仅适用于 <code>ApplicationEvent</code>，而且适用于您作为事件发送的任何任意对象。</p>
</blockquote>
<h3 id="方便地访问低级资源"><a href="#方便地访问低级资源" class="headerlink" title="方便地访问低级资源"></a>方便地访问低级资源</h3><p>为了获得最佳用法和对应用程序上下文的理解，您应该熟悉 Spring 的 <code>Resource</code> 抽象，如参考资料所述。</p>
<p>应用程序上下文是 <code>ResourceLoader</code>，可用于加载 <code>Resource</code> 对象。<code>Resource</code> 本质上是 JDK <code>java.net.URL</code> 类的功能更丰富的版本。实际上，资源的实现在适当的地方包装了 <code>java.net.URL</code> 的实例。资源可以以透明的方式从几乎任何位置获取低级资源，包括从类路径、文件系统位置、可使用标准 URL 描述的任何位置以及一些其他变体。如果资源位置字符串是没有任何特殊前缀的简单路径，则这些资源的来源是特定的，并且适合于实际的应用程序上下文类型。</p>
<p>您可以配置部署到应用程序上下文中的 bean，以实现特殊的回调接口 <code>ResourceLoaderAware</code>，以便在初始化时自动调用，并将应用程序上下文本身作为 <code>ResourceLoader</code> 传入。您还可以公开 <code>Resource</code> 类型的属性，以用于访问静态资源。它们像其他任何属性一样注入其中。您可以将那些 <code>Resource</code> 属性指定为简单的 String 路径，并在部署 bean 时依靠从这些文本字符串到实际 <code>Resource</code> 对象的自动转换。</p>
<p>提供给 <code>ApplicationContext</code> 构造函数的一个或多个位置路径实际上是资源字符串，并且根据特定的上下文实现以简单的形式对其进行适当处理。例如，<code>ClassPathXmlApplicationContext</code> 将简单的位置路径视为类路径位置。您也可以使用带有特殊前缀的位置路径（资源字符串）来强制从类路径或 URL 中加载定义，而不管实际的上下文类型如何。</p>
<h3 id="Web-应用程序的便捷-ApplicationContext-实例化"><a href="#Web-应用程序的便捷-ApplicationContext-实例化" class="headerlink" title="Web 应用程序的便捷 ApplicationContext 实例化"></a>Web 应用程序的便捷 ApplicationContext 实例化</h3><p>您可以使用例如 <code>ContextLoader</code> 声明性地创建 <code>ApplicationContext</code> 实例。 当然，您还可以使用 <code>ApplicationContext</code> 实现之一以编程方式创建 <code>ApplicationContext</code> 实例。</p>
<p>您可以使用 <code>ApplicationContext</code> 来注册一个 <code>ContextLoaderListener</code>，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>侦听器检查 <code>contextConfigLocation</code> 参数。 如果参数不存在，那么侦听器将使用 <code>/WEB-INF/applicationContext.xml</code> 作为默认值。 当参数确实存在时，侦听器将使用预定义的定界符（逗号，分号和空格）来分隔 String，并将这些值用作搜索应用程序上下文的位置。此外还支持蚂 Ant 风格的路径模式。示例包括 <code>/WEB-INF/*Context.xml</code>（适用于所有名称以 <code>Context.xml</code> 结尾且位于 <code>WEB-INF</code> 目录中的文件）和 <code>/WEB-INF/**/*Context.xml</code>（适用于所有此类在 <code>WEB-INF</code> 的任何子目录中的文件）。</p>
<h3 id="将-Spring-ApplicationContext-部署为-Java-EE-RAR-文件"><a href="#将-Spring-ApplicationContext-部署为-Java-EE-RAR-文件" class="headerlink" title="将 Spring ApplicationContext 部署为 Java EE RAR 文件"></a>将 Spring <code>ApplicationContext</code> 部署为 Java EE RAR 文件</h3><p>可以将 Spring <code>ApplicationContext</code> 部署为 RAR 文件，并将上下文及其所有必需的 bean 类和库 JAR 封装在 Java EE RAR 部署单元中。这等效于引导独立的 <code>ApplicationContext</code>（仅托管在 Java EE 环境中）能够访问 Java EE 服务器功能。 RAR 部署是部署无头 WAR 文件的方案的一种更自然的选择——实际上，这种 WAR 文件没有任何 HTTP 入口点，仅用于在 Java EE 环境中引导 Spring <code>ApplicationContext</code>。</p>
<p>对于不需要 HTTP 入口点而仅由消息端点和计划的作业组成的应用程序上下文，RAR 部署是理想的选择。在这样的上下文中，Bean 可以使用应用程序服务器资源，例如 JTA 事务管理器和 JNDI 绑定的 JDBC <code>DataSource</code> 实例以及 JMS <code>ConnectionFactory</code> 实例，并且还可以在平台的 JMX 服务器上注册-通过 Spring 的标准事务管理以及 JNDI 和 JMX 支持工具。应用程序组件还可以通过 Spring 的 <code>TaskExecutor</code> 抽象与应用程序服务器的 JCA <code>WorkManager</code> 进行交互。</p>
<p>有关 RAR 部署中涉及的配置详细信息，请参见 (<code>SpringContextResourceAdapter</code> 类的 javadoc)[<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html]。" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html]。</a></p>
<p>对于将 Spring ApplicationContext 作为 Java EE RAR 文件的简单部署：</p>
<ol>
<li><p>将所有应用程序类打包到 RAR 文件（这是具有不同文件扩展名的标准 JAR 文件）中。将所有必需的库 JAR 添加到 RAR 归档文件的根目录中。添加一个 <code>META-INF/ra.xml</code> 部署描述符（如 javadoc 中的 <code>SpringContextResourceAdapter</code> 所示）和相应的 Spring XML bean 定义文件（通常为 <code>META-INF/applicationContext.xml</code>）。</p>
</li>
<li><p>将生成的 RAR 文件拖放到应用程序服务器的部署目录中。</p>
</li>
</ol>
<blockquote>
<p>此类 RAR 部署单元通常是独立的。它们不会将组件暴露给外界，甚至不会暴露给同一应用程序的其他模块。与基于 RAR 的 <code>ApplicationContext</code> 的交互通常是通过与其他模块共享的 JMS 目标进行的。例如，基于 RAR 的 <code>ApplicationContext</code> 还可以安排一些作业或对文件系统（或类似文件）中的新文件做出反应。如果需要允许来自外部的同步访问，则可以（例如）导出 RMI 端点，该端点可以由同一台计算机上的其他应用程序模块使用。</p>
</blockquote>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p><code>BeanFactory</code> API 为 Spring 的 IoC 功能提供了基础。它的特定合同主要用于与 Spring 的其他部分以及相关的第三方框架集成，并且它的 <code>DefaultListableBeanFactory</code> 实现是更高级别的 <code>GenericApplicationContext</code> 容器中的关键委托。</p>
<p><code>BeanFactory</code> 和相关接口（例如 <code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>）是其他框架组件的重要集成点。通过不需要任何注释，甚至不需要反射，它们可以在容器及其组件之间进行非常有效的交互。应用程序级 Bean 可以使用相同的回调接口，但通常更喜欢通过注释或通过编程配置进行声明式依赖注入。</p>
<p>请注意，核心 <code>BeanFactory</code> API 级别及其 <code>DefaultListableBeanFactory</code> 实现不对配置格式或要使用的任何组件注释进行假设。所有这些风味都是通过扩展（例如 <code>XmlBeanDefinitionReader</code> 和 <code>AutowiredAnnotationBeanPostProcessor</code>）引入的，并以核心元数据表示形式对共享 <code>BeanDefinition</code> 对象进行操作。这就是使 Spring 的容器如此灵活和可扩展的本质。</p>
<h3 id="BeanFactory-还是-ApplicationContext？"><a href="#BeanFactory-还是-ApplicationContext？" class="headerlink" title="BeanFactory 还是 ApplicationContext？"></a><code>BeanFactory</code> 还是 <code>ApplicationContext</code>？</h3><p>本节说明 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 容器级别之间的区别以及对引导的影响。</p>
<p>除非有充分的理由，否则应使用 <code>ApplicationContext</code>，除非将 <code>GenericApplicationContext</code> 及其子类 <code>AnnotationConfigApplicationContext</code> 作为自定义引导的常见实现，否则应使用 <code>ApplicationContext</code>。这些是用于所有常见目的的 Spring 核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册 Bean 定义和带注释的类，以及（从 5.0 版本开始）注册功能性 Bean 定义。</p>
<p>因为 <code>ApplicationContext</code> 包含 <code>BeanFactory</code> 的所有功能，所以通常建议在普通 <code>BeanFactory</code> 上使用，除非需要完全控制 Bean 处理的方案。在 <code>ApplicationContext</code>（例如 <code>GenericApplicationContext</code> 实现）中，按照约定（即，按 Bean 名称或 Bean 类型（尤其是后处理器））检测到几种 Bean，而普通的 <code>DefaultListableBeanFactory</code> 不知道任何特殊的 Bean。</p>
<p>对于许多扩展的容器功能，例如注释处理和 AOP 代理，<code>BeanPostProcessor</code> 扩展点是必不可少的。如果仅使用普通的 <code>DefaultListableBeanFactory</code>，则默认情况下不会检测到此类后处理器并将其激活。这种情况可能会造成混淆，因为您的 bean 配置实际上并没有错。而是在这种情况下，需要通过其他设置完全引导容器。</p>
<p>下表列出了 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 接口和实现所提供的功能。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>Bean 实例化/接线</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>集成生命周期管理</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>自动 BeanPostProcessor 注册</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>自动 BeanFactoryPostProcessor 注册</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>方便的 MessageSource 访问（用于国际化）</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>内置 ApplicationEvent 发布机制</td>
<td>没有</td>
<td>是</td>
</tr>
</tbody></table>
<p>要向 <code>DefaultListableBeanFactory</code> 显式注册 Bean 后处理器，需要以编程方式调用 <code>addBeanPostProcessor</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">// populate the factory with bean definitions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now register any needed BeanPostProcessor instances</span></span><br><span class="line">factory.addBeanPostProcessor(<span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor());</span><br><span class="line">factory.addBeanPostProcessor(<span class="keyword">new</span> MyBeanPostProcessor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// now start using the factory</span></span><br></pre></td></tr></table></figure>

<p>要将 <code>BeanFactoryPostProcessor</code> 应用于普通的 <code>DefaultListableBeanFactory</code>，您需要调用其 <code>postProcessBeanFactory</code> 方法，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(<span class="keyword">new</span> FileSystemResource(<span class="string">"beans.xml"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// bring in some property values from a Properties file</span></span><br><span class="line">PropertySourcesPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">cfg.setLocation(<span class="keyword">new</span> FileSystemResource(<span class="string">"jdbc.properties"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// now actually do the replacement</span></span><br><span class="line">cfg.postProcessBeanFactory(factory);</span><br></pre></td></tr></table></figure>

<p>在这两种情况下，显式的注册步骤都是不方便的，这就是为什么在 Spring 支持的应用程序中，各种 <code>ApplicationContext</code> 变量比普通的 <code>DefaultListableBeanFactory</code> 更为可取的原因，尤其是在典型企业设置中依赖 <code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 实例来扩展容器功能时。</p>
<blockquote>
<p><code>AnnotationConfigApplicationContext</code> 已注册了所有常见的注释后处理器，并且可以通过配置注释（例如 <code>@EnableTransactionManagement</code>）在幕后引入其他处理器。 在 Spring 基于注释的配置模型的抽象级别上，bean 后处理器的概念仅是内部容器详细信息。</p>
</blockquote>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/阅读/" rel="tag">#阅读</a>
          
            <a href="/tags/Spring/" rel="tag">#Spring</a>
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/spring-1/" rel="next" title="Spring进阶 - IoC容器(1)">
                <i class="fa fa-chevron-left"></i> Spring进阶 - IoC容器(1)
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/spring-3/" rel="prev" title="Spring进阶 - 资源">
                Spring进阶 - 资源 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2020/04/spring-2/" data-title="Spring进阶 - IoC容器(2)" data-url="https://HaleLu.github.io/2020/04/spring-2/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://avatars3.githubusercontent.com/u/10864533" alt="Hale Lu">
          <p class="site-author-name" itemprop="name">Hale Lu</p>
          <p class="site-description motion-element" itemprop="description">一只欠觉的开发狗</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/halelu" target="_blank" title="Github">
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/hao-lu-42-29" target="_blank" title="知乎">
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://wpa.qq.com/msgrd?v=3&uin=773622805&site=qq&menu=yes" target="_blank" title="QQ">
                  
                  QQ
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa fa-globe fa-fw"></i>
              各路大神
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://pmextra.github.io/" title="PM Extra's Blog" target="_blank">PM Extra's Blog</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://hzlclock.wordpress.com/" title="Hebert's Blog" target="_blank">Hebert's Blog</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.rexskz.info/" title="Rex's Blog" target="_blank">Rex's Blog</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义-bean-的行为-Nature"><span class="nav-number">1.</span> <span class="nav-text">自定义 bean 的行为(Nature)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期回调"><span class="nav-number">1.1.</span> <span class="nav-text">生命周期回调</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化回调"><span class="nav-number">1.1.1.</span> <span class="nav-text">初始化回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#销毁回调"><span class="nav-number">1.1.2.</span> <span class="nav-text">销毁回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认初始化和析构方法"><span class="nav-number">1.1.3.</span> <span class="nav-text">默认初始化和析构方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#组合生命周期机制"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">组合生命周期机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动和关闭回调"><span class="nav-number">1.1.4.</span> <span class="nav-text">启动和关闭回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在非-Web-应用程序中优雅地关闭-Spring-IoC-容器"><span class="nav-number">1.1.5.</span> <span class="nav-text">在非 Web 应用程序中优雅地关闭 Spring IoC 容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContextAware-和-BeanNameAware"><span class="nav-number">1.2.</span> <span class="nav-text">ApplicationContextAware 和 BeanNameAware</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他-Aware-接口"><span class="nav-number">1.3.</span> <span class="nav-text">其他 Aware 接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bean-定义的继承"><span class="nav-number">2.</span> <span class="nav-text">bean 定义的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器扩展点"><span class="nav-number">3.</span> <span class="nav-text">容器扩展点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-BeanPostProcessor-自定义-bean"><span class="nav-number">3.1.</span> <span class="nav-text">使用 BeanPostProcessor 自定义 bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#以编程方式注册-BeanPostProcessor-实例"><span class="nav-number">3.1.1.</span> <span class="nav-text">以编程方式注册 BeanPostProcessor 实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanPostProcessor-实例和-AOP-自动代理"><span class="nav-number">3.1.2.</span> <span class="nav-text">BeanPostProcessor 实例和 AOP 自动代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-BeanFactoryPostProcessor-定制配置项元数据"><span class="nav-number">4.</span> <span class="nav-text">使用 BeanFactoryPostProcessor 定制配置项元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：类名替换器-PropertyPlaceholderConfigurer"><span class="nav-number">4.1.</span> <span class="nav-text">示例：类名替换器 PropertyPlaceholderConfigurer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：PropertyOverrideConfigurer"><span class="nav-number">4.2.</span> <span class="nav-text">示例：PropertyOverrideConfigurer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-FactoryBean-自定义实例化逻辑"><span class="nav-number">4.3.</span> <span class="nav-text">使用 FactoryBean 自定义实例化逻辑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于注解的容器配置"><span class="nav-number">5.</span> <span class="nav-text">基于注解的容器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Required"><span class="nav-number">5.1.</span> <span class="nav-text">@Required</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired"><span class="nav-number">5.2.</span> <span class="nav-text">@Autowired</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Primary"><span class="nav-number">5.3.</span> <span class="nav-text">@Primary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限定符微调自动装配"><span class="nav-number">5.4.</span> <span class="nav-text">限定符微调自动装配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型微调自动装配"><span class="nav-number">5.5.</span> <span class="nav-text">泛型微调自动装配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-CustomAutowireConfigurer"><span class="nav-number">5.6.</span> <span class="nav-text">使用 CustomAutowireConfigurer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Resource-注入"><span class="nav-number">5.7.</span> <span class="nav-text">使用 @Resource 注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-PostConstruct-和-PreDestroy"><span class="nav-number">5.8.</span> <span class="nav-text">使用 @PostConstruct 和 @PreDestroy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类路径扫描和托管组件"><span class="nav-number">6.</span> <span class="nav-text">类路径扫描和托管组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Component-和更多的-Stereotype-注释"><span class="nav-number">6.1.</span> <span class="nav-text">@Component 和更多的 Stereotype 注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用元注释和组合注释"><span class="nav-number">6.2.</span> <span class="nav-text">使用元注释和组合注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动检测类并注册-Bean-定义"><span class="nav-number">6.3.</span> <span class="nav-text">自动检测类并注册 Bean 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用过滤器自定义扫描"><span class="nav-number">6.4.</span> <span class="nav-text">使用过滤器自定义扫描</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在组件中定义-Bean-元数据"><span class="nav-number">6.5.</span> <span class="nav-text">在组件中定义 Bean 元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名自动检测的组件"><span class="nav-number">6.6.</span> <span class="nav-text">命名自动检测的组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提供自动检测组件的范围"><span class="nav-number">6.7.</span> <span class="nav-text">提供自动检测组件的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提供带有注释的限定符元数据"><span class="nav-number">6.8.</span> <span class="nav-text">提供带有注释的限定符元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成候选组件的索引"><span class="nav-number">6.9.</span> <span class="nav-text">生成候选组件的索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-JSR-330-标准注释"><span class="nav-number">7.</span> <span class="nav-text">使用 JSR 330 标准注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与-Inject-和的依赖注入-Named"><span class="nav-number">8.</span> <span class="nav-text">与 @Inject 和的依赖注入 @Named</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Named-和-ManagedBean：-Component-注释的标准等效项"><span class="nav-number">8.1.</span> <span class="nav-text">@Named 和 @ManagedBean：@Component 注释的标准等效项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSR-330-标准注释的局限性"><span class="nav-number">8.2.</span> <span class="nav-text">JSR-330 标准注释的局限性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-Java-的容器配置"><span class="nav-number">9.</span> <span class="nav-text">基于 Java 的容器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念：-Bean-和-Configuration"><span class="nav-number">9.1.</span> <span class="nav-text">基本概念：@Bean 和 @Configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用实例化-Spring-容器-AnnotationConfigApplicationContext"><span class="nav-number">9.2.</span> <span class="nav-text">使用实例化 Spring 容器 AnnotationConfigApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单实现"><span class="nav-number">9.2.1.</span> <span class="nav-text">简单实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过使用-register-Class-lt-gt-…​-以编程方式构建容器"><span class="nav-number">9.2.2.</span> <span class="nav-text">通过使用 register(Class&lt;?&gt;…​) 以编程方式构建容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-scan-String…​-启用组件扫描"><span class="nav-number">9.2.3.</span> <span class="nav-text">使用 scan(String…​) 启用组件扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#支持-Web-应用程序的-AnnotationConfigWebApplicationContext"><span class="nav-number">9.2.4.</span> <span class="nav-text">支持 Web 应用程序的 AnnotationConfigWebApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Bean-注解"><span class="nav-number">9.3.</span> <span class="nav-text">使用 @Bean 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明一个-bean"><span class="nav-number">9.3.1.</span> <span class="nav-text">声明一个 bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-依赖"><span class="nav-number">9.3.2.</span> <span class="nav-text">Bean 依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收生命周期回调"><span class="nav-number">9.3.3.</span> <span class="nav-text">接收生命周期回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定-bean-的作用域"><span class="nav-number">9.3.4.</span> <span class="nav-text">指定 bean 的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-Scope-注解"><span class="nav-number">9.3.4.1.</span> <span class="nav-text">使用@Scope 注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scope-和-scope-代理"><span class="nav-number">9.3.4.2.</span> <span class="nav-text">@Scope 和 scope 代理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义-Bean-命名"><span class="nav-number">9.3.5.</span> <span class="nav-text">自定义 Bean 命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-别名"><span class="nav-number">9.3.6.</span> <span class="nav-text">Bean 别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-描述"><span class="nav-number">9.3.7.</span> <span class="nav-text">Bean 描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Configuration-注解"><span class="nav-number">9.4.</span> <span class="nav-text">使用 @Configuration 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注入-bean-间的依赖关系"><span class="nav-number">9.4.1.</span> <span class="nav-text">注入 bean 间的依赖关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找方法注入"><span class="nav-number">9.4.2.</span> <span class="nav-text">查找方法注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有关基于-Java-的配置在内部如何工作的更多信息"><span class="nav-number">9.4.3.</span> <span class="nav-text">有关基于 Java 的配置在内部如何工作的更多信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组成基于-Java-的配置"><span class="nav-number">9.5.</span> <span class="nav-text">组成基于 Java 的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-Import-注释"><span class="nav-number">9.5.1.</span> <span class="nav-text">使用 @Import 注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#注入对导入-Bean-定义的依赖"><span class="nav-number">9.5.1.1.</span> <span class="nav-text">注入对导入@Bean 定义的依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#便于浏览的完全合格的导入-bean"><span class="nav-number">9.5.1.2.</span> <span class="nav-text">便于浏览的完全合格的导入 bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有条件地包含-Configuration-类或-Bean-方法"><span class="nav-number">9.5.2.</span> <span class="nav-text">有条件地包含 @Configuration 类或 @Bean 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结合-Java-和-XML-配置"><span class="nav-number">9.5.3.</span> <span class="nav-text">结合 Java 和 XML 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#以-XML-为中心的-Configuration-类使用"><span class="nav-number">9.5.3.1.</span> <span class="nav-text">以 XML 为中心的 @Configuration 类使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#将-Configuration-类声明为纯-Spring-lt-bean-gt-元素"><span class="nav-number">9.5.3.1.1.</span> <span class="nav-text">将 @Configuration 类声明为纯 Spring &lt;bean/&gt; 元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使用-lt-context：component-scan-gt-拾取-Configuration-类"><span class="nav-number">9.5.3.1.2.</span> <span class="nav-text">使用 &lt;context：component-scan/&gt;拾取 @Configuration 类</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Configuration-以类为中心的-XML-与-ImportResource"><span class="nav-number">9.5.3.2.</span> <span class="nav-text">@Configuration 以类为中心的 XML 与 @ImportResource</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境抽象"><span class="nav-number">10.</span> <span class="nav-text">环境抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-定义配置文件（profiles）"><span class="nav-number">10.1.</span> <span class="nav-text">Bean 定义配置文件（profiles）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-Profile"><span class="nav-number">10.1.1.</span> <span class="nav-text">使用 @Profile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML-Bean-定义配置文件"><span class="nav-number">10.1.2.</span> <span class="nav-text">XML Bean 定义配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#激活-profile"><span class="nav-number">10.1.3.</span> <span class="nav-text">激活 profile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认-profile"><span class="nav-number">10.1.4.</span> <span class="nav-text">默认 profile</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PropertySource-抽象"><span class="nav-number">10.2.</span> <span class="nav-text">PropertySource 抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-PropertySource"><span class="nav-number">10.3.</span> <span class="nav-text">使用 @PropertySource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明中的占位符解析"><span class="nav-number">10.4.</span> <span class="nav-text">声明中的占位符解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册一个-LoadTimeWeaver"><span class="nav-number">11.</span> <span class="nav-text">注册一个 LoadTimeWeaver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ApplicationContext-的其他功能"><span class="nav-number">12.</span> <span class="nav-text">ApplicationContext 的其他功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-MessageSource-实现国际化"><span class="nav-number">12.1.</span> <span class="nav-text">使用 MessageSource 实现国际化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准和自定义事件"><span class="nav-number">12.2.</span> <span class="nav-text">标准和自定义事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于注释的事件侦听器"><span class="nav-number">12.2.1.</span> <span class="nav-text">基于注释的事件侦听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步侦听器"><span class="nav-number">12.2.2.</span> <span class="nav-text">异步侦听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#侦听器排序"><span class="nav-number">12.2.3.</span> <span class="nav-text">侦听器排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一般事件"><span class="nav-number">12.2.4.</span> <span class="nav-text">一般事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方便地访问低级资源"><span class="nav-number">12.3.</span> <span class="nav-text">方便地访问低级资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-应用程序的便捷-ApplicationContext-实例化"><span class="nav-number">12.4.</span> <span class="nav-text">Web 应用程序的便捷 ApplicationContext 实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将-Spring-ApplicationContext-部署为-Java-EE-RAR-文件"><span class="nav-number">12.5.</span> <span class="nav-text">将 Spring ApplicationContext 部署为 Java EE RAR 文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactory"><span class="nav-number">13.</span> <span class="nav-text">BeanFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-还是-ApplicationContext？"><span class="nav-number">13.1.</span> <span class="nav-text">BeanFactory 还是 ApplicationContext？</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hale Lu</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"halelu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("ABk8fYaVcvf6P6IuuGNY2rRa-gzGzoHsz", "3Vpj3qkDsPj8Rlh92mHOxAMV");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
